#pragma line 1 "sobel.cpp"
#pragma line 1 "<built-in>"
#pragma line 1 "<command-line>"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
/* autopilot_ssdm_op.h*/
/*
 * Copyright (C) 2011 XILINX, Inc. 
 *
 * $Id$
 */
#pragma line 98 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_op.h"
/*#define AP_SPEC_ATTR __attribute__ ((pure))*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern "C" {
    /****** SSDM Intrinsics: OPERATIONS ***/
    // Interface operations
    void _ssdm_op_FifoRead(...) __attribute__ ((nothrow));
    void _ssdm_op_FifoWrite(...) __attribute__ ((nothrow));
#pragma empty_line
    //typedef unsigned int __attribute__ ((bitwidth(1))) _uint1_;
    typedef bool _uint1_;
    _uint1_ _ssdm_op_FifoNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_FifoNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_FifoCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_FifoCanWrite(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_IfRead(...) __attribute__ ((nothrow));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow));
#pragma empty_line
    // Stream Intrinsics
    void _ssdm_StreamRead(...) __attribute__ ((nothrow));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbWrite(...) __attribute__ ((nothrow));
    //_uint1_  _ssdm_StreamCanRead(...) SSDM_OP_ATTR;
    //_uint1_  _ssdm_StreamCanWrite(...) SSDM_OP_ATTR;
#pragma empty_line
    // Misc
    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_Wait(...) __attribute__ ((nothrow));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_Return(...) __attribute__ ((nothrow));
#pragma empty_line
    /* SSDM Intrinsics: SPECIFICATIONS */
    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow));
#pragma empty_line
    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow));
#pragma empty_line
    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecBus(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecFifo(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecWire(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecBuff(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecMem(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow));
#pragma empty_line
#pragma empty_line
    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow));
    /*void* _ssdm_op_SpecProcess(...) SSDM_SPEC_ATTR;
    void* _ssdm_op_SpecEdge(...) SSDM_SPEC_ATTR; */
#pragma empty_line
    /* Presynthesis directive functions */
    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_RegionBegin(...) __attribute__ ((nothrow));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_Unroll(...) __attribute__ ((nothrow));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_InlineAll(...) __attribute__ ((nothrow));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow));
    void _ssdm_Inline(...) __attribute__ ((nothrow));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecStream(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecExpr(...) __attribute__ ((nothrow));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecDependence(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow));
#pragma empty_line
    void _ssdm_DataPack(...) __attribute__ ((nothrow));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow));
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*#define _ssdm_op_WaitUntil(X) while (!(X)) _ssdm_op_Wait(1);
#define _ssdm_op_Delayed(X) X */
#pragma line 1 "<command-line>" 2
#pragma line 1 "sobel.cpp"
/*******************************************************************************
Vendor: Xilinx 
Associated Filename: sobel.cpp
Purpose: Sobel edge detection algorithm for AutoESL
Revision History: February 13, 2012 - initial release
#pragma empty_line
*******************************************************************************
© Copyright 2008  2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
is protected under U.S. and international copyright and other intellectual 
property laws.
#pragma empty_line
DISCLAIMER
This disclaimer is not a license and does not grant any rights to the materials 
distributed herewith. Except as otherwise provided in a valid license issued to 
you by Xilinx, and to the maximum extent permitted by applicable law: 
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
in contract or tort, including negligence, or under any other theory of 
liability) for any loss or damage of any kind or nature related to, arising under 
or in connection with these materials, including for any direct, or any indirect, 
special, incidental, or consequential loss or damage (including loss of data, 
profits, goodwill, or any type of loss or damage suffered as a result of any 
action brought by a third party) even if such damage or loss was reasonably 
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
CRITICAL APPLICATIONS
Xilinx products are not designed or intended to be fail-safe, or for use in any 
application requiring fail-safe performance, such as life-support or safety 
devices or systems, Class III medical devices, nuclear facilities, applications 
related to the deployment of airbags, or any other applications that could lead 
to death, personal injury, or severe property or environmental damage 
(individually and collectively, "Critical Applications"). Customer assumes the 
sole risk and liability of any use of Xilinx products in Critical Applications, 
subject only to applicable laws and regulations governing limitations on product 
liability. 
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
ALL TIMES.
#pragma empty_line
*******************************************************************************/
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 1 3
/*
 * stdio.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Definitions of types and prototypes of functions for standard input and
 * output.
 *
 * NOTE: The file manipulation functions provided by Microsoft seem to
 * work with either slash (/) or backslash (\) as the directory separator.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 1 3
#pragma empty_line
/*
 * _mingw.h
 *
 * Mingw specific macros included by ALL include files.
 *
 * This file is part of the Mingw32 package.
 *
 * Contributors:
 *  Created by Mumit Khan  <khan@xraylith.wisc.edu>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#pragma line 31 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
#pragma empty_line
#pragma line 32 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
#pragma empty_line
#pragma empty_line
/* These are defined by the user (or the compiler)
   to specify how identifiers are imported from a DLL.
#pragma empty_line
   __DECLSPEC_SUPPORTED            Defined if dllimport attribute is supported.
   __MINGW_IMPORT                  The attribute definition to specify imported
                                   variables/functions.
   _CRTIMP                         As above.  For MS compatibility.
   __MINGW32_VERSION               Runtime version.
   __MINGW32_MAJOR_VERSION         Runtime major version.
   __MINGW32_MINOR_VERSION         Runtime minor version.
   __MINGW32_BUILD_DATE            Runtime build date.
#pragma empty_line
   Macros to enable MinGW features which deviate from standard MSVC
   compatible behaviour; these may be specified directly in user code,
   activated implicitly, (e.g. by specifying _POSIX_C_SOURCE or such),
   or by inclusion in __MINGW_FEATURES__:
#pragma empty_line
   __USE_MINGW_ANSI_STDIO          Select a more ANSI C99 compatible
                                   implementation of printf() and friends.
#pragma empty_line
   Other macros:
#pragma empty_line
   __int64                         define to be long long.  Using a typedef
                                   doesn't work for "unsigned __int64"
#pragma empty_line
   All headers should include this first, and then use __DECLSPEC_SUPPORTED
   to choose between the old ``__imp__name'' style or __MINGW_IMPORT
   style declarations.  */
#pragma empty_line
#pragma empty_line
/* Manifest definitions identifying the flag bits, controlling activation
 * of MinGW features, as specified by the user in __MINGW_FEATURES__.
 */
#pragma empty_line
/*
 * The following three are not yet formally supported; they are
 * included here, to document anticipated future usage.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Try to avoid problems with outdated checks for GCC __attribute__ support.  */
#pragma line 121 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
   /* Note the extern. This is needed to work around GCC's
      limitations in handling dllimport attribute.  */
#pragma line 140 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
/*
 * The next two defines can cause problems if user code adds the
 * __cdecl attribute like so:
 * void __attribute__ ((__cdecl)) foo(void); 
 */
#pragma line 230 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
/* Attribute `nonnull' was valid as of gcc 3.3.  We don't use GCC's
   variadiac macro facility, because variadic macros cause syntax
   errors with  --traditional-cpp.  */
#pragma line 252 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
/* TODO: Mark (almost) all CRT functions as __MINGW_NOTHROW.  This will
allow GCC to optimize away some EH unwind code, at least in DW2 case.  */
#pragma empty_line
#pragma empty_line
/*  High byte is the major version, low byte is the minor. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Activation of MinGW specific extended features:
 */
#pragma empty_line
/*
 * If user didn't specify it explicitly...
 */
#pragma line 277 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/_mingw.h" 3
   /*
    * otherwise use whatever __MINGW_FEATURES__ specifies...
    */
#pragma line 20 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 167 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 214 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
typedef unsigned int size_t;
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 281 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
#pragma line 308 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
#pragma line 355 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
typedef short unsigned int wint_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 27 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 2 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef __builtin_va_list __gnuc_va_list;
#pragma empty_line
#pragma empty_line
/* Define the standard macros for the user,
   if this invocation was from the user program.  */
#pragma line 29 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Flags for the iobuf structure  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The three standard file pointers provided by the run time library.
 * NOTE: These will go to the bit-bucket silently in GUI applications!
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Returned by various functions on end of file condition or error. */
#pragma empty_line
#pragma empty_line
/*
 * The maximum length of a file name. You should use GetVolumeInformation
 * instead of this constant. But hey, this works.
 * Also defined in io.h.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The maximum number of files that may be open at once. I have set this to
 * a conservative number. The actual value may be higher.
 */
#pragma empty_line
#pragma empty_line
/* After creating this many names, tmpnam and tmpfile return NULL */
#pragma empty_line
/*
 * Tmpnam, tmpfile and, sometimes, _tempnam try to create
 * temp files in the root directory of the current drive
 * (not in pwd, as suggested by some older MS doc's).
 * Redefining these macros does not effect the CRT functions.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The maximum size of name (including NUL) that will be put in the user
 * supplied buffer caName for tmpnam.
 * Inferred from the size of the static buffer returned by tmpnam
 * when passed a NULL argument. May actually be smaller.
 */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
/*
 * The buffer size as used by setbuf such that it is equivalent to
 * (void) setvbuf(fileSetBuffer, caBuffer, _IOFBF, BUFSIZ).
 */
#pragma empty_line
#pragma empty_line
/* Constants for nOrigin indicating the position relative to which fseek
 * sets the file position.  Defined unconditionally since ISO and POSIX
 * say they are defined here.  */
#pragma line 120 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
/*
 * The structure underlying the FILE type.
 *
 * Some believe that nobody in their right mind should make use of the
 * internals of this structure. Provided by Pedro A. Aranda Gutiirrez
 * <paag@tid.es>.
 */
#pragma empty_line
#pragma empty_line
typedef struct _iobuf
{
 char* _ptr;
 int _cnt;
 char* _base;
 int _flag;
 int _file;
 int _charbuf;
 int _bufsiz;
 char* _tmpfname;
} FILE;
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The standard file handles
 */
#pragma line 154 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
extern __attribute__ ((__dllimport__)) FILE _iob[]; /* An array of FILE imported from DLL. */
#pragma line 163 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
/*
 * File Operations
 */
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) freopen (const char*, const char*, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fflush (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fclose (FILE*);
/* MS puts remove & rename (but not wide versions) in io.h  also */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) remove (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rename (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpfile (void);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpnam (char*);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _unlink (const char*);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) unlink (const char*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setvbuf (FILE*, char*, int, size_t);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setbuf (FILE*, char*);
#pragma empty_line
/*
 * Formatted Output
 *
 * MSVCRT implementations are not ANSI C99 conformant...
 * we offer these conforming alternatives from libmingwex.a
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_fprintf(FILE*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_printf(const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_sprintf(char*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_snprintf(char*, size_t, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vfprintf(FILE*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vprintf(const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsprintf(char*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsnprintf(char*, size_t, const char*, __gnuc_va_list);
#pragma line 290 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
/*
 * Default configuration: simply direct all calls to MSVCRT...
 */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fprintf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) printf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sprintf (char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfprintf (FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vprintf (const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsprintf (char*, const char*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
/*
 * Regardless of user preference, always offer these alternative
 * entry points, for direct access to the MSVCRT implementations.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_fprintf(FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_printf(const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_sprintf(char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vfprintf(FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vprintf(const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vsprintf(char*, const char*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* The following pair ALWAYS refer to the MSVCRT implementations...
 */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snprintf (char*, size_t, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnprintf (char*, size_t, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscprintf (const char*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
/*
 * Microsoft does not provide implementations for the following,
 * which are required by C99.  Note in particular that the corresponding
 * Microsoft implementations of _snprintf() and _vsnprintf() are *not*
 * compatible with C99, but the following are; if you want the MSVCRT
 * behaviour, you *must* use the Microsoft uglified names.
 */
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snprintf (char *, size_t, const char *, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnprintf (char *, size_t, const char *, __gnuc_va_list);
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vscanf (const char * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfscanf (FILE * __restrict__, const char * __restrict__,
       __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsscanf (const char * __restrict__,
       const char * __restrict__, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Formatted Input
 */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fscanf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) scanf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sscanf (const char*, const char*, ...);
/*
 * Character Input and Output Functions
 */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetc (FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgets (char*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputc (int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputs (const char*, FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gets (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) puts (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetc (int, FILE*);
#pragma empty_line
/* Traditionally, getc and putc are defined as macros. but the
   standard doesn't say that they must be macros.
   We use inline functions here to allow the fast versions
   to be used in C++ with namespace qualification, eg., ::getc.
#pragma empty_line
   _filbuf and _flsbuf  are not thread-safe. */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filbuf (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flsbuf (int, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getc (FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) *__F->_ptr++
    : _filbuf (__F);
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    : _flsbuf (__c, __F);
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getchar (void)
{
  return (--(&_iob[0])->_cnt >= 0)
    ? (int) (unsigned char) *(&_iob[0])->_ptr++
    : _filbuf ((&_iob[0]));
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putchar(int __c)
{
  return (--(&_iob[1])->_cnt >= 0)
    ? (int) (unsigned char) (*(&_iob[1])->_ptr++ = (char)__c)
    : _flsbuf (__c, (&_iob[1]));}
#pragma line 408 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
/*
 * Direct Input and Output Functions
 */
#pragma empty_line
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fread (void*, size_t, size_t, FILE*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwrite (const void*, size_t, size_t, FILE*);
#pragma empty_line
/*
 * File Positioning Functions
 */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseek (FILE*, long, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftell (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rewind (FILE*);
#pragma line 445 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
/*
 * An opaque data type used for storing file positions... The contents of
 * this type are unknown, but we (the compiler) need to know the size
 * because the programmer using fgetpos and fsetpos will be setting aside
 * storage for fpos_t structres. Actually I tested using a byte array and
 * it is fairly evident that the fpos_t type is a long (in CRTDLL.DLL).
 * Perhaps an unsigned long? TODO? It's definitely a 64-bit number in
 * MSVCRT however, and for now `long long' will do.
 */
#pragma empty_line
typedef long long fpos_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetpos (FILE*, fpos_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fsetpos (FILE*, const fpos_t*);
#pragma empty_line
/*
 * Error Functions
 */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE*);
#pragma empty_line
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE* __F)
  { return __F->_flag & 0x0010 /* EOF reached on read */; }
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE* __F)
  { return __F->_flag & 0x0020 /* I/O error from system */; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clearerr (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) perror (const char*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Pipes
 */
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _pclose (FILE*);
#pragma empty_line
#pragma empty_line
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) pclose (FILE*);
#pragma empty_line
#pragma empty_line
/*
 * Other Non ANSI functions
 */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flushall (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fileno (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcloseall (void);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fsopen (const char*, const char*, int);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getmaxstdio (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _setmaxstdio (int);
#pragma line 522 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fileno (FILE*);
#pragma line 534 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/sys/types.h" 1 3
/*
 * types.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * The definition of constants, data types and global variables.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 152 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 22 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/sys/types.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long __time32_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long __time64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* FIXME __STRICT_ANSI__ ! */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef __time32_t time_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long _off_t;
#pragma empty_line
#pragma empty_line
typedef _off_t off_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned int _dev_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef _dev_t dev_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef short _ino_t;
#pragma empty_line
#pragma empty_line
typedef _ino_t ino_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _pid_t;
#pragma empty_line
#pragma empty_line
typedef _pid_t pid_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned short _mode_t;
#pragma empty_line
#pragma empty_line
typedef _mode_t mode_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _sigset_t;
#pragma empty_line
#pragma empty_line
typedef _sigset_t sigset_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long _ssize_t;
#pragma empty_line
#pragma empty_line
typedef _ssize_t ssize_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long fpos64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long off64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned int useconds_t;
#pragma line 535 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 2 3
inline FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen64 (const char* filename, const char* mode)
{
  return fopen (filename, mode);
}
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseeko64 (FILE*, off64_t, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline off64_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftello64 (FILE * stream)
{
  fpos_t pos;
  if (fgetpos(stream, &pos))
    return -1LL;
  else
   return ((off64_t) pos);
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Wide  versions */
#pragma empty_line
#pragma empty_line
/*  also in wchar.h - keep in sync */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwprintf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wprintf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snwprintf (wchar_t*, size_t, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwprintf (FILE*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnwprintf (wchar_t*, size_t, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwscanf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wscanf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swscanf (const wchar_t*, const wchar_t*, ...);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwc (wchar_t, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetwc (wchar_t, FILE*);
#pragma empty_line
/* These differ from the ISO C prototypes, which have a maxlen parameter (like snprintf).  */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swprintf (wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswprintf (wchar_t*, const wchar_t*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetws (wchar_t*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputws (const wchar_t*, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwchar (void);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getws (wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwc (wint_t, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putws (const wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwchar (wint_t);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfdopen(int, const wchar_t *);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfopen (const wchar_t*, const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfreopen (const wchar_t*, const wchar_t*, FILE*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfsopen (const wchar_t*, const wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtmpnam (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtempnam (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrename (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wremove (const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wperror (const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wpopen (const wchar_t*, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snwprintf (wchar_t* s, size_t n, const wchar_t* format, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnwprintf (wchar_t* s, size_t n, const wchar_t* format, __gnuc_va_list arg);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwscanf (const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwscanf (FILE * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswscanf (const wchar_t * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
#pragma line 625 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 3
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wpopen (const wchar_t*, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Other Non ANSI wide functions
 */
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putw (int, FILE*);
#pragma empty_line
#pragma empty_line
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putw (int, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 47 "sobel.cpp" 2
#pragma line 1 "sobel.h" 1
/*******************************************************************************
#pragma empty_line
Vendor: Xilinx 
#pragma empty_line
Associated Filename: sobel.h
#pragma empty_line
Purpose: Sobel algorithm header file for AutoESL
#pragma empty_line
Revision History: February 13, 2012 - initial release
#pragma empty_line
#pragma empty_line
#pragma empty_line
*******************************************************************************
#pragma empty_line
© Copyright 2008 - 2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
#pragma empty_line
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
#pragma empty_line
is protected under U.S. and international copyright and other intellectual 
#pragma empty_line
property laws.
#pragma empty_line
#pragma empty_line
#pragma empty_line
DISCLAIMER
#pragma empty_line
This disclaimer is not a license and does not grant any rights to the materials 
#pragma empty_line
distributed herewith. Except as otherwise provided in a valid license issued to 
#pragma empty_line
you by Xilinx, and to the maximum extent permitted by applicable law: 
#pragma empty_line
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
#pragma empty_line
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
#pragma empty_line
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
#pragma empty_line
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
#pragma empty_line
in contract or tort, including negligence, or under any other theory of 
#pragma empty_line
liability) for any loss or damage of any kind or nature related to, arising under 
#pragma empty_line
or in connection with these materials, including for any direct, or any indirect, 
#pragma empty_line
special, incidental, or consequential loss or damage (including loss of data, 
#pragma empty_line
profits, goodwill, or any type of loss or damage suffered as a result of any 
#pragma empty_line
action brought by a third party) even if such damage or loss was reasonably 
#pragma empty_line
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
#pragma empty_line
#pragma empty_line
CRITICAL APPLICATIONS
#pragma empty_line
Xilinx products are not designed or intended to be fail-safe, or for use in any 
#pragma empty_line
application requiring fail-safe performance, such as life-support or safety 
#pragma empty_line
devices or systems, Class III medical devices, nuclear facilities, applications 
#pragma empty_line
related to the deployment of airbags, or any other applications that could lead 
#pragma empty_line
to death, personal injury, or severe property or environmental damage 
#pragma empty_line
(individually and collectively, "Critical Applications"). Customer assumes the 
#pragma empty_line
sole risk and liability of any use of Xilinx products in Critical Applications, 
#pragma empty_line
subject only to applicable laws and regulations governing limitations on product 
#pragma empty_line
liability. 
#pragma empty_line
#pragma empty_line
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
#pragma empty_line
ALL TIMES.
#pragma empty_line
#pragma empty_line
#pragma empty_line
*******************************************************************************/
#pragma line 50 "sobel.h"
#pragma line 1 "ap_axi_sdata.h" 1
/*******************************************************************************
Vendor: Xilinx 
Associated Filename: ap_axi_sdata.h
Purpose: AXI data type for AutoESL
Revision History: February 13, 2012 - initial release
#pragma empty_line
*******************************************************************************
© Copyright 2008 - 2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
is protected under U.S. and international copyright and other intellectual 
property laws.
#pragma empty_line
DISCLAIMER
This disclaimer is not a license and does not grant any rights to the materials 
distributed herewith. Except as otherwise provided in a valid license issued to 
you by Xilinx, and to the maximum extent permitted by applicable law: 
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
in contract or tort, including negligence, or under any other theory of 
liability) for any loss or damage of any kind or nature related to, arising under 
or in connection with these materials, including for any direct, or any indirect, 
special, incidental, or consequential loss or damage (including loss of data, 
profits, goodwill, or any type of loss or damage suffered as a result of any 
action brought by a third party) even if such damage or loss was reasonably 
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
CRITICAL APPLICATIONS
Xilinx products are not designed or intended to be fail-safe, or for use in any 
application requiring fail-safe performance, such as life-support or safety 
devices or systems, Class III medical devices, nuclear facilities, applications 
related to the deployment of airbags, or any other applications that could lead 
to death, personal injury, or severe property or environmental damage 
(individually and collectively, "Critical Applications"). Customer assumes the 
sole risk and liability of any use of Xilinx products in Critical Applications, 
subject only to applicable laws and regulations governing limitations on product 
liability. 
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
ALL TIMES.
#pragma empty_line
*******************************************************************************/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int.h" 1
// -*- c++ -*-
/*
 * Copyright (C) 2011 XILINX, Inc.
 *
 */
#pragma line 14 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int.h"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 1
/* -*- c++ -*-*/
/*
 * Copyright (C) 2011 XILINX, Inc.
 *
 */
#pragma line 22 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iostream" 1 3
// Standard iostream objects -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iostream
 *  This is a Standard C++ Library header. 
 */
#pragma empty_line
//
// ISO C++ 14882: 27.3  Standard iostream objects
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iostream" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Pick up any OS-specific definitions.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/os_defines.h" 1 3
// Specific definitions for generic platforms  -*- C++ -*-
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file os_defines.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// System-specific #define, typedefs, corrections, etc, go here.  This
// file will come before all others.
#pragma empty_line
//  Define as 0, if you want, to enable inlining of gthread functions.
//  By default, don't pollute libstdc++ with win32api names.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Don't let win32api windef.h define min and max as macros
// if included after stl_algobase.h. 
#pragma empty_line
#pragma empty_line
#pragma empty_line
// See libstdc++/20806.
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 2 3
#pragma empty_line
// Pick up any CPU-specific definitions.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/cpu_defines.h" 1 3
// Specific definitions for generic platforms  -*- C++ -*-
#pragma empty_line
// Copyright (C) 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpu_defines.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 2 3
#pragma empty_line
// The current version of the C++ library in compressed ISO date format.
#pragma empty_line
#pragma empty_line
// Macros for visibility.
#pragma line 58 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 3
// Macros for controlling various namespace association schemes and modes.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Macros for namespace scope.
// _GLIBCXX_BEGIN_NAMESPACE
// _GLIBCXX_END_NAMESPACE
// _GLIBCXX_BEGIN_NESTED_NAMESPACE
// _GLIBCXX_END_NESTED_NAMESPACE
#pragma line 87 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 3
// Namespace associations for versioning mode.
#pragma line 112 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 3
// Namespace associations for debug mode.
#pragma line 144 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 3
/* Define if compatibility should be provided for -mlong-double-64. */
#pragma empty_line
#pragma empty_line
// XXX GLIBCXX_ABI Deprecated
// Namespace associations for long double 128 mode.
namespace std {
#pragma line 161 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 3
}
#pragma empty_line
#pragma empty_line
// Allow use of "export template." This is currently not a feature
// that g++ supports.
// #define _GLIBCXX_EXPORT_TEMPLATE 1
#pragma empty_line
// Allow use of the GNU syntax extension, "extern template." This
// extension is fully documented in the g++ manual, but in a nutshell,
// it inhibits all implicit instantiations and is used throughout the
// library to avoid multiple weak definitions for required types that
// are already explicitly instantiated in the library binary. This
// substantially reduces the binary size of resulting executables.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Certain function definitions that are meant to be overridable from
// user code are decorated with this macro.  For some targets, this
// macro causes these definitions to be weak.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// The remainder of the prewritten config is automatic; all the
// user hooks are listed above.
#pragma empty_line
// Create a boolean flag to be used to determine if --fast-math is set.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// This marks string literals in header files to be extracted for eventual
// translation.  It is primarily used for messages in thrown exceptions; see
// src/functexcept.cc.  We use __N because the more traditional _N is used
// for something else under certain OSes (see BADNAMES).
#pragma empty_line
#pragma empty_line
// For example, <windows.h> is known to #define min and max as macros...
#pragma empty_line
#pragma empty_line
#pragma empty_line
// End of prewritten config; the discovered settings follow.
/* config.h.  Generated by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */
#pragma empty_line
/* Define to 1 if you have the `acosf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `acosl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `asinf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `asinl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `atan2f' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `atan2l' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `atanf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `atanl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `ceilf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `ceill' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <complex.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `copysign' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `copysignf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `copysignl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `cosf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `coshf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `coshl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `cosl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <endian.h> header file. */
/* #undef _GLIBCXX_HAVE_ENDIAN_H */
#pragma empty_line
/* Define to 1 if you have the `expf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `expl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `fabsf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `fabsl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <fenv.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `finite' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `finitef' function. */
/* #undef _GLIBCXX_HAVE_FINITEF */
#pragma empty_line
/* Define to 1 if you have the `finitel' function. */
/* #undef _GLIBCXX_HAVE_FINITEL */
#pragma empty_line
/* Define to 1 if you have the <float.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `floorf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `floorl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `fmodf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `fmodl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `fpclass' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <fp.h> header file. */
/* #undef _GLIBCXX_HAVE_FP_H */
#pragma empty_line
/* Define to 1 if you have the `frexpf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `frexpl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <gconv.h> header file. */
/* #undef _GLIBCXX_HAVE_GCONV_H */
#pragma empty_line
/* Define if _Unwind_GetIPInfo is available. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `getpagesize' function. */
#pragma empty_line
#pragma empty_line
/* Define if gthr-default.h exists (meaning that threading support is
   enabled). */
/* #undef _GLIBCXX_HAVE_GTHR_DEFAULT */
#pragma empty_line
/* Define to 1 if you have the `hypot' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `hypotf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `hypotl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `iconv' function. */
/* #undef _GLIBCXX_HAVE_ICONV */
#pragma empty_line
/* Define to 1 if you have the `iconv_close' function. */
/* #undef _GLIBCXX_HAVE_ICONV_CLOSE */
#pragma empty_line
/* Define to 1 if you have the `iconv_open' function. */
/* #undef _GLIBCXX_HAVE_ICONV_OPEN */
#pragma empty_line
/* Define to 1 if you have the <ieeefp.h> header file. */
/* #undef _GLIBCXX_HAVE_IEEEFP_H */
#pragma empty_line
/* Define if int64_t is available in <stdint.h>. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <inttypes.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `isinf' function. */
/* #undef _GLIBCXX_HAVE_ISINF */
#pragma empty_line
/* Define to 1 if you have the `isinff' function. */
/* #undef _GLIBCXX_HAVE_ISINFF */
#pragma empty_line
/* Define to 1 if you have the `isinfl' function. */
/* #undef _GLIBCXX_HAVE_ISINFL */
#pragma empty_line
/* Define to 1 if you have the `isnan' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `isnanf' function. */
/* #undef _GLIBCXX_HAVE_ISNANF */
#pragma empty_line
/* Define to 1 if you have the `isnanl' function. */
/* #undef _GLIBCXX_HAVE_ISNANL */
#pragma empty_line
/* Defined if iswblank exists. */
#pragma empty_line
#pragma empty_line
/* Define if LC_MESSAGES is available in <locale.h>. */
/* #undef _GLIBCXX_HAVE_LC_MESSAGES */
#pragma empty_line
/* Define to 1 if you have the `ldexpf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `ldexpl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <libintl.h> header file. */
/* #undef _GLIBCXX_HAVE_LIBINTL_H */
#pragma empty_line
/* Define to 1 if you have the `m' library (-lm). */
#pragma empty_line
#pragma empty_line
/* Only used in build directory testsuite_hooks.h. */
/* #undef _GLIBCXX_HAVE_LIMIT_AS */
#pragma empty_line
/* Only used in build directory testsuite_hooks.h. */
/* #undef _GLIBCXX_HAVE_LIMIT_DATA */
#pragma empty_line
/* Only used in build directory testsuite_hooks.h. */
/* #undef _GLIBCXX_HAVE_LIMIT_FSIZE */
#pragma empty_line
/* Only used in build directory testsuite_hooks.h. */
/* #undef _GLIBCXX_HAVE_LIMIT_RSS */
#pragma empty_line
/* Only used in build directory testsuite_hooks.h. */
/* #undef _GLIBCXX_HAVE_LIMIT_VMEM */
#pragma empty_line
/* Define to 1 if you have the <locale.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `log10f' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `log10l' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `logf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `logl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <machine/endian.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_ENDIAN_H */
#pragma empty_line
/* Define to 1 if you have the <machine/param.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_PARAM_H */
#pragma empty_line
/* Define if mbstate_t exists in wchar.h. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <memory.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have a working `mmap' system call. */
/* #undef _GLIBCXX_HAVE_MMAP */
#pragma empty_line
/* Define to 1 if you have the `modf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `modff' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `modfl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <nan.h> header file. */
/* #undef _GLIBCXX_HAVE_NAN_H */
#pragma empty_line
/* Define to 1 if you have the `nl_langinfo' function. */
/* #undef _GLIBCXX_HAVE_NL_LANGINFO */
#pragma empty_line
/* Define if poll is available in <poll.h>. */
/* #undef _GLIBCXX_HAVE_POLL */
#pragma empty_line
/* Define to 1 if you have the `powf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `powl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `qfpclass' function. */
/* #undef _GLIBCXX_HAVE_QFPCLASS */
#pragma empty_line
/* Define to 1 if you have the `setenv' function. */
/* #undef _GLIBCXX_HAVE_SETENV */
#pragma empty_line
/* Define if sigsetjmp is available. */
/* #undef _GLIBCXX_HAVE_SIGSETJMP */
#pragma empty_line
/* Define to 1 if you have the `sincos' function. */
/* #undef _GLIBCXX_HAVE_SINCOS */
#pragma empty_line
/* Define to 1 if you have the `sincosf' function. */
/* #undef _GLIBCXX_HAVE_SINCOSF */
#pragma empty_line
/* Define to 1 if you have the `sincosl' function. */
/* #undef _GLIBCXX_HAVE_SINCOSL */
#pragma empty_line
/* Define to 1 if you have the `sinf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `sinhf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `sinhl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `sinl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `sqrtf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `sqrtl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <stdbool.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <stdint.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <stdlib.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define if strerror_l is available in <string.h>. */
/* #undef _GLIBCXX_HAVE_STRERROR_L */
#pragma empty_line
/* Define if strerror_r is available in <string.h>. */
/* #undef _GLIBCXX_HAVE_STRERROR_R */
#pragma empty_line
/* Define to 1 if you have the <strings.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <string.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `strtof' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `strtold' function. */
#pragma empty_line
#pragma empty_line
/* Define if strxfrm_l is available in <string.h>. */
/* #undef _GLIBCXX_HAVE_STRXFRM_L */
#pragma empty_line
/* Define to 1 if you have the <sys/filio.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_FILIO_H */
#pragma empty_line
/* Define to 1 if you have the <sys/ioctl.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_IOCTL_H */
#pragma empty_line
/* Define to 1 if you have the <sys/ipc.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_IPC_H */
#pragma empty_line
/* Define to 1 if you have the <sys/isa_defs.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_ISA_DEFS_H */
#pragma empty_line
/* Define to 1 if you have the <sys/machine.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_MACHINE_H */
#pragma empty_line
/* Define to 1 if you have the <sys/param.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_PARAM_H */
#pragma empty_line
/* Define to 1 if you have the <sys/resource.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_RESOURCE_H */
#pragma empty_line
/* Define to 1 if you have the <sys/sem.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_SEM_H */
#pragma empty_line
/* Define to 1 if you have the <sys/stat.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <sys/time.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <sys/types.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <sys/uio.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_UIO_H */
#pragma empty_line
/* Define if S_IFREG is available in <sys/stat.h>. */
/* #undef _GLIBCXX_HAVE_S_IFREG */
#pragma empty_line
/* Define if S_IFREG is available in <sys/stat.h>. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `tanf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `tanhf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `tanhl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `tanl' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if the target supports thread-local storage. */
/* #undef _GLIBCXX_HAVE_TLS */
#pragma empty_line
/* Define to 1 if you have the <unistd.h> header file. */
#pragma empty_line
#pragma empty_line
/* Defined if vfwscanf exists. */
#pragma empty_line
#pragma empty_line
/* Defined if vswscanf exists. */
#pragma empty_line
#pragma empty_line
/* Defined if vwscanf exists. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <wchar.h> header file. */
#pragma empty_line
#pragma empty_line
/* Defined if wcstof exists. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the <wctype.h> header file. */
#pragma empty_line
#pragma empty_line
/* Define if writev is available in <sys/uio.h>. */
/* #undef _GLIBCXX_HAVE_WRITEV */
#pragma empty_line
/* Define to 1 if you have the `_acosf' function. */
/* #undef _GLIBCXX_HAVE__ACOSF */
#pragma empty_line
/* Define to 1 if you have the `_acosl' function. */
/* #undef _GLIBCXX_HAVE__ACOSL */
#pragma empty_line
/* Define to 1 if you have the `_asinf' function. */
/* #undef _GLIBCXX_HAVE__ASINF */
#pragma empty_line
/* Define to 1 if you have the `_asinl' function. */
/* #undef _GLIBCXX_HAVE__ASINL */
#pragma empty_line
/* Define to 1 if you have the `_atan2f' function. */
/* #undef _GLIBCXX_HAVE__ATAN2F */
#pragma empty_line
/* Define to 1 if you have the `_atan2l' function. */
/* #undef _GLIBCXX_HAVE__ATAN2L */
#pragma empty_line
/* Define to 1 if you have the `_atanf' function. */
/* #undef _GLIBCXX_HAVE__ATANF */
#pragma empty_line
/* Define to 1 if you have the `_atanl' function. */
/* #undef _GLIBCXX_HAVE__ATANL */
#pragma empty_line
/* Define to 1 if you have the `_ceilf' function. */
/* #undef _GLIBCXX_HAVE__CEILF */
#pragma empty_line
/* Define to 1 if you have the `_ceill' function. */
/* #undef _GLIBCXX_HAVE__CEILL */
#pragma empty_line
/* Define to 1 if you have the `_copysign' function. */
/* #undef _GLIBCXX_HAVE__COPYSIGN */
#pragma empty_line
/* Define to 1 if you have the `_copysignl' function. */
/* #undef _GLIBCXX_HAVE__COPYSIGNL */
#pragma empty_line
/* Define to 1 if you have the `_cosf' function. */
/* #undef _GLIBCXX_HAVE__COSF */
#pragma empty_line
/* Define to 1 if you have the `_coshf' function. */
/* #undef _GLIBCXX_HAVE__COSHF */
#pragma empty_line
/* Define to 1 if you have the `_coshl' function. */
/* #undef _GLIBCXX_HAVE__COSHL */
#pragma empty_line
/* Define to 1 if you have the `_cosl' function. */
/* #undef _GLIBCXX_HAVE__COSL */
#pragma empty_line
/* Define to 1 if you have the `_expf' function. */
/* #undef _GLIBCXX_HAVE__EXPF */
#pragma empty_line
/* Define to 1 if you have the `_expl' function. */
/* #undef _GLIBCXX_HAVE__EXPL */
#pragma empty_line
/* Define to 1 if you have the `_fabsf' function. */
/* #undef _GLIBCXX_HAVE__FABSF */
#pragma empty_line
/* Define to 1 if you have the `_fabsl' function. */
/* #undef _GLIBCXX_HAVE__FABSL */
#pragma empty_line
/* Define to 1 if you have the `_finite' function. */
/* #undef _GLIBCXX_HAVE__FINITE */
#pragma empty_line
/* Define to 1 if you have the `_finitef' function. */
/* #undef _GLIBCXX_HAVE__FINITEF */
#pragma empty_line
/* Define to 1 if you have the `_finitel' function. */
/* #undef _GLIBCXX_HAVE__FINITEL */
#pragma empty_line
/* Define to 1 if you have the `_floorf' function. */
/* #undef _GLIBCXX_HAVE__FLOORF */
#pragma empty_line
/* Define to 1 if you have the `_floorl' function. */
/* #undef _GLIBCXX_HAVE__FLOORL */
#pragma empty_line
/* Define to 1 if you have the `_fmodf' function. */
/* #undef _GLIBCXX_HAVE__FMODF */
#pragma empty_line
/* Define to 1 if you have the `_fmodl' function. */
/* #undef _GLIBCXX_HAVE__FMODL */
#pragma empty_line
/* Define to 1 if you have the `_fpclass' function. */
/* #undef _GLIBCXX_HAVE__FPCLASS */
#pragma empty_line
/* Define to 1 if you have the `_frexpf' function. */
/* #undef _GLIBCXX_HAVE__FREXPF */
#pragma empty_line
/* Define to 1 if you have the `_frexpl' function. */
/* #undef _GLIBCXX_HAVE__FREXPL */
#pragma empty_line
/* Define to 1 if you have the `_hypot' function. */
/* #undef _GLIBCXX_HAVE__HYPOT */
#pragma empty_line
/* Define to 1 if you have the `_hypotf' function. */
/* #undef _GLIBCXX_HAVE__HYPOTF */
#pragma empty_line
/* Define to 1 if you have the `_hypotl' function. */
/* #undef _GLIBCXX_HAVE__HYPOTL */
#pragma empty_line
/* Define to 1 if you have the `_isinf' function. */
/* #undef _GLIBCXX_HAVE__ISINF */
#pragma empty_line
/* Define to 1 if you have the `_isinff' function. */
/* #undef _GLIBCXX_HAVE__ISINFF */
#pragma empty_line
/* Define to 1 if you have the `_isinfl' function. */
/* #undef _GLIBCXX_HAVE__ISINFL */
#pragma empty_line
/* Define to 1 if you have the `_isnan' function. */
/* #undef _GLIBCXX_HAVE__ISNAN */
#pragma empty_line
/* Define to 1 if you have the `_isnanf' function. */
/* #undef _GLIBCXX_HAVE__ISNANF */
#pragma empty_line
/* Define to 1 if you have the `_isnanl' function. */
/* #undef _GLIBCXX_HAVE__ISNANL */
#pragma empty_line
/* Define to 1 if you have the `_ldexpf' function. */
/* #undef _GLIBCXX_HAVE__LDEXPF */
#pragma empty_line
/* Define to 1 if you have the `_ldexpl' function. */
/* #undef _GLIBCXX_HAVE__LDEXPL */
#pragma empty_line
/* Define to 1 if you have the `_log10f' function. */
/* #undef _GLIBCXX_HAVE__LOG10F */
#pragma empty_line
/* Define to 1 if you have the `_log10l' function. */
/* #undef _GLIBCXX_HAVE__LOG10L */
#pragma empty_line
/* Define to 1 if you have the `_logf' function. */
/* #undef _GLIBCXX_HAVE__LOGF */
#pragma empty_line
/* Define to 1 if you have the `_logl' function. */
/* #undef _GLIBCXX_HAVE__LOGL */
#pragma empty_line
/* Define to 1 if you have the `_modf' function. */
/* #undef _GLIBCXX_HAVE__MODF */
#pragma empty_line
/* Define to 1 if you have the `_modff' function. */
/* #undef _GLIBCXX_HAVE__MODFF */
#pragma empty_line
/* Define to 1 if you have the `_modfl' function. */
/* #undef _GLIBCXX_HAVE__MODFL */
#pragma empty_line
/* Define to 1 if you have the `_powf' function. */
/* #undef _GLIBCXX_HAVE__POWF */
#pragma empty_line
/* Define to 1 if you have the `_powl' function. */
/* #undef _GLIBCXX_HAVE__POWL */
#pragma empty_line
/* Define to 1 if you have the `_qfpclass' function. */
/* #undef _GLIBCXX_HAVE__QFPCLASS */
#pragma empty_line
/* Define to 1 if you have the `_sincos' function. */
/* #undef _GLIBCXX_HAVE__SINCOS */
#pragma empty_line
/* Define to 1 if you have the `_sincosf' function. */
/* #undef _GLIBCXX_HAVE__SINCOSF */
#pragma empty_line
/* Define to 1 if you have the `_sincosl' function. */
/* #undef _GLIBCXX_HAVE__SINCOSL */
#pragma empty_line
/* Define to 1 if you have the `_sinf' function. */
/* #undef _GLIBCXX_HAVE__SINF */
#pragma empty_line
/* Define to 1 if you have the `_sinhf' function. */
/* #undef _GLIBCXX_HAVE__SINHF */
#pragma empty_line
/* Define to 1 if you have the `_sinhl' function. */
/* #undef _GLIBCXX_HAVE__SINHL */
#pragma empty_line
/* Define to 1 if you have the `_sinl' function. */
/* #undef _GLIBCXX_HAVE__SINL */
#pragma empty_line
/* Define to 1 if you have the `_sqrtf' function. */
/* #undef _GLIBCXX_HAVE__SQRTF */
#pragma empty_line
/* Define to 1 if you have the `_sqrtl' function. */
/* #undef _GLIBCXX_HAVE__SQRTL */
#pragma empty_line
/* Define to 1 if you have the `_tanf' function. */
/* #undef _GLIBCXX_HAVE__TANF */
#pragma empty_line
/* Define to 1 if you have the `_tanhf' function. */
/* #undef _GLIBCXX_HAVE__TANHF */
#pragma empty_line
/* Define to 1 if you have the `_tanhl' function. */
/* #undef _GLIBCXX_HAVE__TANHL */
#pragma empty_line
/* Define to 1 if you have the `_tanl' function. */
/* #undef _GLIBCXX_HAVE__TANL */
#pragma empty_line
/* Define if the compiler/host combination has __builtin_abs. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_cos. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_cosf. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_cosl. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_fabs. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_fabsf. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_fabsl. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_labs. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sin. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sinf. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sinl. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sqrt. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sqrtf. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler/host combination has __builtin_sqrtl. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `__signbit' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `__signbitf' function. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the `__signbitl' function. */
#pragma empty_line
#pragma empty_line
/* Name of package */
/* #undef _GLIBCXX_PACKAGE */
#pragma empty_line
/* Define to the address where bug reports for this package should be sent. */
#pragma empty_line
#pragma empty_line
/* Define to the full name of this package. */
#pragma empty_line
#pragma empty_line
/* Define to the full name and version of this package. */
#pragma empty_line
#pragma empty_line
/* Define to the one symbol short name of this package. */
#pragma empty_line
#pragma empty_line
/* Define to the version of this package. */
#pragma empty_line
#pragma empty_line
/* Define to 1 if you have the ANSI C header files. */
#pragma empty_line
#pragma empty_line
/* Version number of package */
/* #undef _GLIBCXX_VERSION */
#pragma empty_line
/* Define if builtin atomic operations are supported on this host. */
#pragma empty_line
#pragma empty_line
/* Define to use concept checking code from the boost libraries. */
/* #undef _GLIBCXX_CONCEPT_CHECKS */
#pragma empty_line
/* Define if a fully dynamic basic_string is wanted. */
/* #undef _GLIBCXX_FULLY_DYNAMIC_STRING */
#pragma empty_line
/* Define to 1 if a full hosted library is built, or 0 if freestanding. */
#pragma empty_line
#pragma empty_line
/* Define if compatibility should be provided for -mlong-double-64. */
#pragma empty_line
/* Define if ptrdiff_t is int. */
#pragma empty_line
#pragma empty_line
/* Define if using setrlimit to set resource limits during "make check" */
/* #undef _GLIBCXX_RES_LIMITS */
#pragma empty_line
/* Define if size_t is unsigned int. */
#pragma empty_line
#pragma empty_line
/* Define if the compiler is configured for setjmp/longjmp exceptions. */
/* #undef _GLIBCXX_SJLJ_EXCEPTIONS */
#pragma empty_line
/* Define to use symbol versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER */
#pragma empty_line
/* Define to use darwin versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_DARWIN */
#pragma empty_line
/* Define to use GNU versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_GNU */
#pragma empty_line
/* Define to use GNU namespace versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_GNU_NAMESPACE */
#pragma empty_line
/* Define if C99 functions or macros from <wchar.h>, <math.h>, <complex.h>,
   <stdio.h>, and <stdlib.h> can be used or exposed. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions in <complex.h> should be used in <complex>. Using
   compiler builtins for these functions requires corresponding C99 library
   functions to be present. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions in <complex.h> should be used in <tr1/complex>.
   Using compiler builtins for these functions requires corresponding C99
   library functions to be present. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions in <ctype.h> should be imported in <tr1/cctype> in
   namespace std::tr1. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions in <fenv.h> should be imported in <tr1/cfenv> in
   namespace std::tr1. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std. */
#pragma empty_line
#pragma empty_line
/* Define if C99 functions or macros in <math.h> should be imported in
   <tr1/cmath> in namespace std::tr1. */
#pragma empty_line
#pragma empty_line
/* Define if C99 types in <stdint.h> should be imported in <tr1/cstdint> in
   namespace std::tr1. */
#pragma empty_line
#pragma empty_line
/* Define if iconv and related functions exist and are usable. */
/* #undef _GLIBCXX_USE_ICONV */
#pragma empty_line
/* Define if LFS support is available. */
/* #undef _GLIBCXX_USE_LFS */
#pragma empty_line
/* Define if code specialized for long long should be used. */
#pragma empty_line
#pragma empty_line
/* Define if NLS translations are to be used. */
/* #undef _GLIBCXX_USE_NLS */
#pragma empty_line
/* Define if dev/random and dev/urandom are available for the random_device of
   TR1 (Chapter 5.1). */
/* #undef _GLIBCXX_USE_RANDOM_TR1 */
#pragma empty_line
/* Define if code specialized for wchar_t should be used. */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iostream" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 1 3
// Output streams -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ostream
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.6.2  Output streams
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ios
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4  Iostreams base classes
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 1 3
// Wrapper for underlying C-language localization -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++locale.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.8  Standard locale categories.
//
#pragma empty_line
// Written by Benjamin Kosnik <bkoz@redhat.com>
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/clocale" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file clocale
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c locale.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.2.2  Implementation properties: C library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/clocale" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/clocale" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/locale.h" 1 3
/* 
 * locale.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Functions and types for localization (ie. changing the appearance of
 * output based on the standards of a certain country).
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
/*
 * NOTE: I have tried to test this, but I am limited by my knowledge of
 *       locale issues. The structure does not bomb if you look at the
 *       values, and 'decimal_point' even seems to be correct. But the
 *       rest of the values are, by default, not particularly useful
 *       (read meaningless and not related to the international settings
 *       of the system).
 */
#pragma line 38 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/locale.h" 3
/* According to C89 std, NULL is defined in locale.h too.  */
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 167 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 41 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/locale.h" 2 3
#pragma empty_line
/*
 * The structure returned by 'localeconv'.
 */
struct lconv
{
 char* decimal_point;
 char* thousands_sep;
 char* grouping;
 char* int_curr_symbol;
 char* currency_symbol;
 char* mon_decimal_point;
 char* mon_thousands_sep;
 char* mon_grouping;
 char* positive_sign;
 char* negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
};
#pragma empty_line
#pragma empty_line
extern "C" {
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setlocale (int, const char*);
 struct lconv* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localeconv (void);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 167 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 77 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/locale.h" 2 3
  wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsetlocale(int, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/clocale" 2 3
#pragma empty_line
// Get rid of those macros defined in <locale.h> in lieu of real functions.
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
#pragma empty_line
}
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstring
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* snaroff@next.com says the NeXT needs this.  */
#pragma empty_line
/* Irix 5.1 needs this.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  using ::ptrdiff_t;
  using ::size_t;
#pragma empty_line
}
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/string.h" 1 3
/*
 * string.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Definitions for memory and string functions.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
/*
 * Define size_t, wchar_t and NULL
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 25 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/string.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern "C" {
#pragma empty_line
#pragma empty_line
/*
 * Prototypes of the ANSI Standard C library string functions.
 */
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memchr (const void*, int, size_t) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcmp (const void*, const void*, size_t) __attribute__ ((__pure__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcpy (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memmove (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memset (void*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcat (char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strchr (const char*, int) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmp (const char*, const char*) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcoll (const char*, const char*); /* Compare using locale */
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcpy (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strerror (int); /* NOTE: NOT an old name wrapper. */
#pragma empty_line
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlen (const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncat (char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncmp (const char*, const char*, size_t) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncpy (char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strpbrk (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrchr (const char*, int) __attribute__ ((__pure__));
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strstr (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtok (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strxfrm (char*, const char*, size_t);
#pragma empty_line
#pragma empty_line
/*
 * Extra non-ANSI functions provided by the CRTDLL library
 */
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strerror (const char *);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricmp (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicmp (const char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strupr (char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _swab (const char*, char*, size_t);
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strncoll(const char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicoll(const char*, const char*, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Non-underscored versions of non-ANSI functions. They live in liboldnames.a
 * and provide a little extra portability. Also a few extra UNIX-isms like
 * strcasecmp.
 */
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricmp (const char*, const char*);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcasecmp (const char*, const char *);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnicmp (const char*, const char*, size_t);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncasecmp (const char *, const char *, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strupr (char*);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swab (const char*, char*, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Unicode versions of the standard calls.
 * Also in wchar.h, where they belong according to ISO standard.
 */
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscat (wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcschr (const wchar_t*, wchar_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscpy (wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscspn (const wchar_t*, const wchar_t*);
/* Note:  _wcserror requires __MSVCRT_VERSION__ >= 0x0700.  */
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslen (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncat (wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncmp(const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncpy(wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcspbrk(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrchr(const wchar_t*, wchar_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsspn(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsstr(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstok(wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsxfrm(wchar_t*, const wchar_t*, size_t);
#pragma empty_line
#pragma empty_line
/*
 * Unicode versions of non-ANSI string functions provided by CRTDLL.
 */
#pragma empty_line
/* NOTE: _wcscmpi not provided by CRTDLL, this define is for portability */
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsupr (wchar_t*);
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsncoll(const wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicoll(const wchar_t*, const wchar_t*, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* NOTE: There is no _wcscmpi, but this is for compatibility. */
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsupr (wchar_t*);
#pragma line 196 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/string.h" 3
}
#pragma line 53 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 2 3
#pragma empty_line
// Get rid of those macros defined in <string.h> in lieu of real functions.
#pragma line 78 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 3
namespace std {
#pragma empty_line
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;
#pragma empty_line
  using ::memchr;
#pragma empty_line
  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }
#pragma empty_line
  using ::strchr;
#pragma empty_line
  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }
#pragma empty_line
  using ::strpbrk;
#pragma empty_line
  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }
#pragma empty_line
  using ::strrchr;
#pragma empty_line
  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }
#pragma empty_line
  using ::strstr;
#pragma empty_line
  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
#pragma empty_line
}
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 27.8.2  C Library files
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 2 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdio.h" 1 3
/*
 * stdio.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Definitions of types and prototypes of functions for standard input and
 * output.
 *
 * NOTE: The file manipulation functions provided by Microsoft seem to
 * work with either slash (/) or backslash (\) as the directory separator.
 *
 */
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 2 3
#pragma empty_line
// Get rid of those macros defined in <stdio.h> in lieu of real functions.
#pragma line 98 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 3
namespace std {
#pragma empty_line
  using ::FILE;
  using ::fpos_t;
#pragma empty_line
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
#pragma empty_line
}
#pragma line 155 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 3
namespace __gnu_cxx {
#pragma line 170 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace std {
#pragma empty_line
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
#pragma empty_line
}
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdarg" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cstdarg
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdarg.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdarg" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdarg" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Define the standard macros for the user,
   if this invocation was from the user program.  */
#pragma line 58 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 3 4
/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
#pragma line 92 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stdarg.h" 3 4
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */
#pragma empty_line
/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */
#pragma empty_line
/* The macro _VA_LIST is used in SCO Unix 3.2.  */
#pragma empty_line
/* The macro _VA_LIST_T_H is used in the Bull dpx2  */
#pragma empty_line
/* The macro __va_list__ is used by BeOS.  */
#pragma empty_line
typedef __gnuc_va_list va_list;
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdarg" 2 3
#pragma empty_line
// Adhere to section 17.4.1.2 clause 5 of ISO 14882:1998
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  using ::va_list;
#pragma empty_line
}
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  typedef int* __c_locale;
#pragma empty_line
  // Convert numeric value of type double and long double to string and
  // return length of string.  If vsnprintf is available use it, otherwise
  // fall back to the unsafe vsprintf which, in general, can be dangerous
  // and should be avoided.
  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (std::strcmp(__old, "C"))
      {
 __sav = new char[std::strlen(__old) + 1];
 std::strcpy(__sav, __old);
 std::setlocale(4, "C");
      }
#pragma empty_line
    va_list __args;
    __builtin_va_start(__args,__fmt);
#pragma empty_line
#pragma empty_line
    const int __ret = std::vsnprintf(__out, __size, __fmt, __args);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    __builtin_va_end(__args);
#pragma empty_line
    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }
#pragma empty_line
}
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++io.h" 1 3
// Underlying io library details -*- C++ -*-
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++io.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// c_io_stdio.h - Defines for using "C" stdio.h
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 27.8.2  C Library files
//
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++io.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++io.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr.h" 1 3
/* Threads compatibility routines for libgcc2.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997, 1998, 2004 Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.
#pragma empty_line
GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you link this library with other files,
   some of which are compiled with GCC, to produce an executable,
   this library does not by itself cause the resulting executable
   to be covered by the GNU General Public License.
   This exception does not however invalidate any other reasons why
   the executable file might be covered by the GNU General Public License.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
#pragma empty_line
/* If this file is compiled with threads support, it must
       #define __GTHREADS 1
   to indicate that threads support is present.  Also it has define
   function
     int __gthread_active_p ()
   that returns 1 if thread system is active, 0 if not.
#pragma empty_line
   The threads interface must define the following types:
     __gthread_key_t
     __gthread_once_t
     __gthread_mutex_t
     __gthread_recursive_mutex_t
#pragma empty_line
   The threads interface must define the following macros:
#pragma empty_line
     __GTHREAD_ONCE_INIT
     		to initialize __gthread_once_t
     __GTHREAD_MUTEX_INIT
     		to initialize __gthread_mutex_t to get a fast
		non-recursive mutex.
     __GTHREAD_MUTEX_INIT_FUNCTION
     		some systems can't initialize a mutex without a
		function call.  On such systems, define this to a
		function which looks like this:
		  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)
		Don't define __GTHREAD_MUTEX_INIT in this case
     __GTHREAD_RECURSIVE_MUTEX_INIT
     __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION
     		as above, but for a recursive mutex.
#pragma empty_line
   The threads interface must define the following static functions:
#pragma empty_line
     int __gthread_once (__gthread_once_t *once, void (*func) ())
#pragma empty_line
     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))
     int __gthread_key_delete (__gthread_key_t key)
#pragma empty_line
     void *__gthread_getspecific (__gthread_key_t key)
     int __gthread_setspecific (__gthread_key_t key, const void *ptr)
#pragma empty_line
     int __gthread_mutex_lock (__gthread_mutex_t *mutex);
     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);
     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);
#pragma empty_line
     int __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);
#pragma empty_line
   All functions returning int should return zero on success or the error
   number.  If the operation is not supported, -1 is returned.
#pragma empty_line
   Currently supported threads packages are
     TPF threads with -D__tpf__
     POSIX/Unix98 threads with -D_PTHREADS
     POSIX/Unix95 threads with -D_PTHREADS95
     DCE threads with -D_DCE_THREADS
     Solaris/UI threads with -D_SOLARIS_THREADS
*/
#pragma empty_line
/* Check first for thread specific defines.  */
#pragma line 118 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr.h" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr-single.h" 1 3
/* Threads compatibility routines for libgcc2 and libobjc.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997, 1999, 2000, 2004 Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.
#pragma empty_line
GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you link this library with other files,
   some of which are compiled with GCC, to produce an executable,
   this library does not by itself cause the resulting executable
   to be covered by the GNU General Public License.
   This exception does not however invalidate any other reasons why
   the executable file might be covered by the GNU General Public License.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Just provide compatibility for mutex handling.  */
#pragma empty_line
typedef int __gthread_mutex_t;
typedef int __gthread_recursive_mutex_t;
#pragma line 212 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr-single.h" 3
static inline int
__gthread_active_p (void)
{
  return 0;
}
#pragma empty_line
static inline int
__gthread_mutex_lock (__gthread_mutex_t * )
{
  return 0;
}
#pragma empty_line
static inline int
__gthread_mutex_trylock (__gthread_mutex_t * )
{
  return 0;
}
#pragma empty_line
static inline int
__gthread_mutex_unlock (__gthread_mutex_t * )
{
  return 0;
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
#pragma line 119 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma GCC visibility pop
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++io.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  typedef __gthread_mutex_t __c_lock;
#pragma empty_line
  // for basic_file.h
  typedef FILE __c_file;
#pragma empty_line
}
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cctype" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: <ccytpe>
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cctype" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cctype" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 1 3
/* 
 * ctype.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Functions for testing character types and converting characters.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 21 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The following flags are used to tell iswctype and _isctype what character
 * types you are looking for.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* _BLANK is set for SP and non-ASCII horizontal space chars (eg,
   "no-break space", 0xA0, in CP1250) but not for HT.  */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalnum(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalpha(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscntrl(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isdigit(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isgraph(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) islower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isprint(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ispunct(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isspace(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isupper(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isxdigit(int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isblank (int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _isctype (int, int);
#pragma empty_line
#pragma empty_line
/* These are the ANSI versions, with correct checking of argument */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toupper(int);
#pragma empty_line
/*
 * NOTE: The above are not old name type wrappers, but functions exported
 * explicitly by MSVCRT/CRTDLL. However, underscored versions are also
 * exported.
 */
#pragma empty_line
/*
 *  These are the cheap non-std versions: The return values are undefined
 *  if the argument is not ASCII char or is not of appropriate case
 */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _toupper(int);
#pragma empty_line
#pragma empty_line
/* Also defined in stdlib.h */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
   extern __attribute__ ((__dllimport__)) int __mb_cur_max;
#pragma line 112 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#pragma line 135 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
/*
 * Use inlines here rather than macros, because macros will upset 
 * C++ usage (eg, ::isalnum), and so usually get undefined
 *
 * According to standard for SB chars, these function are defined only
 * for input values representable by unsigned char or EOF.
 * Thus, there is no range test.
 * This reproduces behaviour of MSVCRT.dll lib implemention for SB chars.
 *
 * If no MB char support is needed, these can be simplified even
 * more by command line define -DMB_CUR_MAX=1.  The compiler will then
 * optimise away the constant condition.			
 */
#pragma line 181 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
/* Wide character equivalents */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef wchar_t wctype_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t); /* Obsolete! */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);
#pragma empty_line
#pragma empty_line
/* Older MS docs uses wchar_t for arg and return type, while newer
   online MS docs say arg is wint_t and return is int.
   ISO C uses wint_t for both.  */
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);
#pragma empty_line
/* Also in wctype.h */
#pragma line 246 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsymf (int); /* Valid first character in C symbol */
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsym (int); /* Valid character in C symbol (after first) */
#pragma line 259 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/ctype.h" 3
/* Not _CRTIMP */
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsym (int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cctype" 2 3
#pragma empty_line
// Get rid of those macros defined in <ctype.h> in lieu of real functions.
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cctype" 3
namespace std {
#pragma empty_line
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
#pragma empty_line
}
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stringfwd.h" 1 3
// String support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file stringfwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21 Strings library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stringfwd.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stringfwd.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _Alloc>
    class allocator;
#pragma empty_line
  template<class _CharT>
    struct char_traits;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;
#pragma empty_line
  template<> struct char_traits<char>;
#pragma empty_line
  typedef basic_string<char> string;
#pragma empty_line
#pragma empty_line
  template<> struct char_traits<wchar_t>;
#pragma empty_line
  typedef basic_string<wchar_t> wstring;
#pragma empty_line
#pragma empty_line
}
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/postypes.h" 1 3
// Position types -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file postypes.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4.1 - Types
// ISO C++ 14882: 27.4.3 - Template class fpos
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/postypes.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 21.4
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/ctime
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c time.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.5  Date and time
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 1 3
/* 
 * time.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Date and time functions and types.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 22 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 2 3
#pragma empty_line
#pragma empty_line
/*
 * Number of clock ticks per second. A clock tick is the unit by which
 * processor time is measured and is returned by 'clock'.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * A type for storing the current time and date. This is the number of
 * seconds since midnight Jan 1, 1970.
 * NOTE: This is also defined in non-ISO sys/types.h.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* A 64-bit time_t to get to Y3K */
#pragma line 67 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
/*
 * A type for measuring processor time (in clock ticks).
 */
#pragma empty_line
typedef long clock_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * A structure for storing all kinds of useful information about the
 * current (or another) time.
 */
struct tm
{
 int tm_sec; /* Seconds: 0-59 (K&R says 0-61?) */
 int tm_min; /* Minutes: 0-59 */
 int tm_hour; /* Hours since midnight: 0-23 */
 int tm_mday; /* Day of the month: 1-31 */
 int tm_mon; /* Months *since* january: 0-11 */
 int tm_year; /* Years since 1900 */
 int tm_wday; /* Days since Sunday (0-6) */
 int tm_yday; /* Days since Jan. 1: 0-365 */
 int tm_isdst; /* +1 Daylight Savings Time, 0 No DST,
				 * -1 don't know */
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern "C" {
#pragma empty_line
#pragma empty_line
 clock_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clock (void);
#pragma empty_line
 time_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) time (time_t*);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) difftime (time_t, time_t);
 time_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mktime (struct tm*);
#pragma empty_line
#pragma empty_line
/*
 * These functions write to and return pointers to static buffers that may
 * be overwritten by other function calls. Yikes!
 *
 * NOTE: localtime, and perhaps the others of the four functions grouped
 * below may return NULL if their argument is not 'acceptable'. Also note
 * that calling asctime with a NULL pointer will produce an Invalid Page
 * Fault and crap out your program. Guess how I know. Hint: stat called on
 * a directory gives 'invalid' times in st_atime etc...
 */
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) asctime (const struct tm*);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ctime (const time_t*);
 struct tm* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gmtime (const time_t*);
 struct tm* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localtime (const time_t*);
#pragma empty_line
#pragma empty_line
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strftime (char*, size_t, const char*, const struct tm*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tzset (void);
#pragma empty_line
#pragma empty_line
extern void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tzset (void);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdate(char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strtime(char*);
#pragma empty_line
/* These require newer versions of msvcrt.dll (6.10 or higher). */
#pragma line 146 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
/* These require newer versions of msvcrt.dll (8.00 or higher). */
#pragma line 177 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
/*
 * _daylight: non zero if daylight savings time is used.
 * _timezone: difference in seconds between GMT and local time.
 * _tzname: standard/daylight savings time zone names (an array with two
 *          elements).
 */
#pragma empty_line
#pragma empty_line
/* These are for compatibility with pre-VC 5.0 suppied MSVCRT. */
extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__daylight (void);
extern long* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__timezone (void);
extern char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__tzname (void);
#pragma empty_line
extern __attribute__ ((__dllimport__)) int _daylight;
extern __attribute__ ((__dllimport__)) long _timezone;
extern __attribute__ ((__dllimport__)) char *_tzname[2];
#pragma line 223 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
/* These go in the oldnames import library for MSVCRT. */
extern __attribute__ ((__dllimport__)) int daylight;
extern __attribute__ ((__dllimport__)) long timezone;
extern __attribute__ ((__dllimport__)) char *tzname[2];
#pragma line 246 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
/* wide function prototypes, also declared in wchar.h */
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wasctime(const struct tm*);
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wctime(const time_t*);
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrdate(wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrtime(wchar_t*);
#pragma line 268 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/time.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsftime (wchar_t*, size_t, const wchar_t*, const struct tm*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 2 3
#pragma empty_line
// Get rid of those macros defined in <time.h> in lieu of real functions.
#pragma line 64 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 3
namespace std {
#pragma empty_line
  using ::clock_t;
  using ::time_t;
  using ::tm;
#pragma empty_line
  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
#pragma empty_line
}
#pragma line 53 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 1 3
/*
 * wchar.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Defines of all functions for supporting wide characters. Actually it
 * just includes all those headers, which is not a good thing to do from a
 * processing time point of view, but it does mean that everything will be
 * in sync.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma line 26 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 27 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 2 3
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
/*
 * MSDN says that isw* char classifications are in wchar.h and wctype.h.
 * Although the wctype names are ANSI, their exposure in this header is
 * not.
 */
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 1 3
/* 
 * wctype.h
 *
 * Functions for testing wide character types and converting characters.
 *
 * This file is part of the Mingw32 package.
 *
 * Contributors:
 *  Created by Mumit Khan <khan@xraylith.wisc.edu>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 33 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 2 3
#pragma empty_line
#pragma empty_line
/*
 * The following flags are used to tell iswctype and _isctype what character
 * types you are looking for.
 */
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 3
extern "C" {
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 3
/* Wide character equivalents - also in ctype.h */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t); /* Obsolete! */
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);
#pragma empty_line
#pragma empty_line
/* Older MS docs uses wchar_t for arg and return type, while newer
   online MS docs say arg is wint_t and return is int.
   ISO C uses wint_t for both.  */
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);
#pragma empty_line
/* Also in ctype.h */
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#pragma line 148 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 3
typedef wchar_t wctrans_t;
#pragma empty_line
/* These are resolved by libmingwex.a.  Note, that they are also exported
   by the MS C++ runtime lib (msvcp60.dll).  The msvcp60.dll implementations
   of wctrans and towctrans are not C99 compliant in that wctrans("tolower")
   returns 0, while std specifies that a non-zero value should be returned
   for a valid string descriptor.  If you want the MS behaviour (and you have
   msvcp60.dll in your path) add -lmsvcp60 to your command line.  */
#pragma empty_line
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towctrans(wint_t, wctrans_t);
wctrans_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctrans(const char*);
wctype_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctype(const char*);
#pragma empty_line
#pragma empty_line
}
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 2 3
#pragma empty_line
#pragma empty_line
/* This is necessary to support the the non-ANSI wchar declarations
   here. */
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/sys/types.h" 1 3
/*
 * types.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * The definition of constants, data types and global variables.
 *
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 2 3
#pragma line 63 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
extern "C" {
#pragma line 164 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstol (const wchar_t*, wchar_t**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoul (const wchar_t*, wchar_t**, int);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstod (const wchar_t*, wchar_t**);
#pragma empty_line
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstof (const wchar_t * __restrict__, wchar_t ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetenv(const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wputenv(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsystem(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfullpath (wchar_t*, const wchar_t*, size_t);
#pragma line 286 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
/* These are resolved by -lmingwex. Alternatively, they can be resolved by
   adding -lmsvcp60 to your command line, which will give you the VC++
   versions of these functions. If you want the latter and don't have
   msvcp60.dll in your windows system directory, you can easily obtain
   it with a search from your favorite search engine.  */
#pragma empty_line
typedef wchar_t _Wint_t;
#pragma empty_line
#pragma empty_line
typedef int mbstate_t;
#pragma empty_line
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) btowc(int);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrlen(const char * __restrict__, size_t,
        mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrtowc(wchar_t * __restrict__, const char * __restrict__,
         size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsrtowcs(wchar_t * __restrict__, const char ** __restrict__,
    size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcrtomb(char * __restrict__, wchar_t,
         mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrtombs(char * __restrict__, const wchar_t ** __restrict__,
    size_t, mbstate_t * __restrict__);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctob(wint_t);
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwide(FILE*, int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsinit(const mbstate_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemset(wchar_t *, wchar_t, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemchr(const wchar_t*, wchar_t, size_t);
int wmemcmp(const wchar_t*, const wchar_t *, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemcpy(wchar_t* __restrict__,
           const wchar_t* __restrict__,
    size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemmove(wchar_t* s1, const wchar_t *, size_t);
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoll(const wchar_t * __restrict__,
     wchar_t** __restrict__, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoull(const wchar_t * __restrict__,
       wchar_t ** __restrict__, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* non-ANSI wide char functions from io.h, direct.h, sys/stat.h and locale.h.  */
#pragma empty_line
#pragma empty_line
typedef unsigned long _fsize_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct _wfinddata_t {
 unsigned attrib;
 time_t time_create; /* -1 for FAT file systems */
 time_t time_access; /* -1 for FAT file systems */
 time_t time_write;
 _fsize_t size;
 wchar_t name[260]; /* may include spaces. */
};
struct _wfinddatai64_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 long long size;
 wchar_t name[260];
};
#pragma line 400 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
/* Wide character versions. Also defined in io.h. */
/* CHECK: I believe these only exist in MSVCRT, and not in CRTDLL. Also
   applies to other wide character versions? */
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 1 3
/* ISO C9x  7.18  Integer types <stdint.h>
 * Based on ISO/IEC SC22/WG14 9899 Committee draft (SC22 N2794)
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  Contributor: Danny Smith <danny_r_smith_2001@yahoo.co.nz>
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Date: 2000-12-02
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 25 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 2 3
#pragma empty_line
/* 7.18.1.1  Exact-width integer types */
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;
#pragma empty_line
/* 7.18.1.2  Minimum-width integer types */
typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;
#pragma empty_line
/*  7.18.1.3  Fastest minimum-width integer types 
 *  Not actually guaranteed to be fastest for all purposes
 *  Here we use the exact-width types for 8 and 16-bit ints. 
 */
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;
#pragma empty_line
/* 7.18.1.4  Integer types capable of holding object pointers */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef int intptr_t;
#pragma line 75 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 3
  typedef unsigned int uintptr_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* 7.18.1.5  Greatest-width integer types */
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
#pragma empty_line
/* 7.18.2  Limits of specified-width integer types */
#pragma line 174 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 3
/* 7.18.4  Macros for integer constants */
#pragma line 406 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 2 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _waccess (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchmod (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcreat (const wchar_t*, int);
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirst (const wchar_t*, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnext (long, struct _wfinddata_t *);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wunlink (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wopen (const wchar_t*, int, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsopen (const wchar_t*, int, int, ...);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmktemp (wchar_t*);
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirsti64 (const wchar_t*, struct _wfinddatai64_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnexti64 (long, struct _wfinddatai64_t*);
#pragma line 451 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
/* Also in direct.h */
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchdir (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetcwd (wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetdcwd (int, wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmkdir (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrmdir (const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The structure manipulated and returned by stat and fstat.
 *
 * NOTE: If called on a directory the values in the time fields are not only
 * invalid, they will cause localtime et. al. to return NULL. And calling
 * asctime with a NULL pointer causes an Invalid Page Fault. So watch it!
 */
struct _stat
{
 _dev_t st_dev; /* Equivalent to drive number 0=A 1=B ... */
 _ino_t st_ino; /* Always zero ? */
 _mode_t st_mode; /* See above constants */
 short st_nlink; /* Number of links. */
 short st_uid; /* User: Maybe significant on NT ? */
 short st_gid; /* Group: Ditto */
 _dev_t st_rdev; /* Seems useless (not even filled in) */
 _off_t st_size; /* File size in bytes */
 time_t st_atime; /* Accessed date (always 00:00 hrs local
				 * on FAT) */
 time_t st_mtime; /* Modified time */
 time_t st_ctime; /* Creation time */
};
#pragma empty_line
#pragma empty_line
/* NOTE: Must be the same as _stat above. */
struct stat
{
 dev_t st_dev; /* Equivalent to drive number 0=A 1=B ... */
 ino_t st_ino; /* Always zero ? */
 mode_t st_mode; /* See above constants */
 short st_nlink; /* Number of links. */
 short st_uid; /* User: Maybe significant on NT ? */
 short st_gid; /* Group: Ditto */
 dev_t st_rdev; /* Seems useless (not even filled in) */
 off_t st_size; /* File size in bytes */
 time_t st_atime; /* Accessed date (always 00:00 hrs local
				 * on FAT) */
 time_t st_mtime; /* Modified time */
 time_t st_ctime; /* Creation time */
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct _stati64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
};
#pragma line 585 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
/* also declared in sys/stat.h */
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstat (const wchar_t*, struct _stat*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstati64 (const wchar_t*, struct _stati64*);
#pragma line 616 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 1 3
/* ISO C9x  7.18  Integer types <stdint.h>
 * Based on ISO/IEC SC22/WG14 9899 Committee draft (SC22 N2794)
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  Contributor: Danny Smith <danny_r_smith_2001@yahoo.co.nz>
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Date: 2000-12-02
 */
#pragma line 617 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wchar.h" 2 3
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecl (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecle (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclp (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclpe (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecv (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecve (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvp (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvpe (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
#pragma empty_line
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnl (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnle (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlp (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlpe (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnv (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnve (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvp (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvpe (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
} /* end of extern "C" */
#pragma line 56 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 2 3
#pragma empty_line
#pragma empty_line
// Need to do a bit of trickery here with mbstate_t as char_traits
// assumes it is in wchar.h, regardless of wchar_t specializations.
#pragma line 70 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 3
namespace std {
#pragma empty_line
  using ::mbstate_t;
#pragma empty_line
}
#pragma empty_line
// Get rid of those macros defined in <wchar.h> in lieu of real functions.
#pragma line 144 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 3
namespace std {
#pragma empty_line
  using ::wint_t;
#pragma empty_line
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
#pragma empty_line
  using ::vfwscanf;
#pragma empty_line
  using ::vswprintf;
#pragma empty_line
  using ::vswscanf;
#pragma empty_line
  using ::vwprintf;
#pragma empty_line
  using ::vwscanf;
#pragma empty_line
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
#pragma empty_line
  using ::wcstof;
#pragma empty_line
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
#pragma empty_line
  using ::wcschr;
#pragma empty_line
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }
#pragma empty_line
  using ::wcspbrk;
#pragma empty_line
  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }
#pragma empty_line
  using ::wcsrchr;
#pragma empty_line
  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }
#pragma empty_line
  using ::wcsstr;
#pragma empty_line
  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }
#pragma empty_line
  using ::wmemchr;
#pragma empty_line
  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::wcstold;
#pragma line 262 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace std {
#pragma empty_line
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
#pragma empty_line
}
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/postypes.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdint.h" 1 3
/* ISO C9x  7.18  Integer types <stdint.h>
 * Based on ISO/IEC SC22/WG14 9899 Committee draft (SC22 N2794)
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  Contributor: Danny Smith <danny_r_smith_2001@yahoo.co.nz>
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Date: 2000-12-02
 */
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/postypes.h" 2 3
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  // The types streamoff, streampos and wstreampos and the class
  // template fpos<> are described in clauses 21.1.2, 21.1.3, 27.1.2,
  // 27.2, 27.4.1, 27.4.3 and D.6. Despite all this verbage, the
  // behaviour of these types is mostly implementation defined or
  // unspecified. The behaviour in this implementation is as noted
  // below.
#pragma empty_line
  /**
   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.
   *
   *  @if maint
   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an
   *  implementation defined type.
   *  Note: In versions of GCC up to and including GCC 3.3, streamoff
   *  was typedef long.
   *  @endif
  */
#pragma empty_line
  typedef int64_t streamoff;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /// Integral type for I/O operation counts and buffer sizes.
  typedef ptrdiff_t streamsize; // Signed integral type
#pragma empty_line
  template<typename _StateT>
    class fpos;
#pragma empty_line
  /**
   *  @brief  Class representing stream positions.
   *
   *  The standard places no requirements upon the template parameter StateT.
   *  In this implementation StateT must be DefaultConstructible,
   *  CopyConstructible and Assignable.  The standard only requires that fpos
   *  should contain a member of type StateT. In this implementation it also
   *  contains an offset stored as a signed integer.
   *
   *  @param  StateT  Type passed to and returned from state().
   */
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;
#pragma empty_line
    public:
      // The standard doesn't require that fpos objects can be default
      // constructed. This implementation provides a default
      // constructor that initializes the offset to 0 and default
      // constructs the state.
      fpos()
      : _M_off(0), _M_state() { }
#pragma empty_line
      // The standard requires that fpos objects can be constructed
      // from streamoff objects using the constructor syntax, and
      // fails to give any meaningful semantics. In this
      // implementation implicit conversion is also allowed, and this
      // constructor stores the streamoff as the offset and default
      // constructs the state.
      /// Construct position from offset.
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }
#pragma empty_line
      /// Convert to streamoff.
      operator streamoff() const { return _M_off; }
#pragma empty_line
      /// Remember the value of @a st.
      void
      state(_StateT __st)
      { _M_state = __st; }
#pragma empty_line
      /// Return the last set value of @a st.
      _StateT
      state() const
      { return _M_state; }
#pragma empty_line
      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implemenation it just adds it's
      // argument to the stored offset and returns *this.
      /// Add offset to this position.
      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }
#pragma empty_line
      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implemenation it just subtracts
      // it's argument from the stored offset and returns *this.
      /// Subtract offset from this position.
      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }
#pragma empty_line
      // The standard requires that this operator must be defined, but
      // defines it's semantics only in terms of operator-. In this
      // implementation it constructs a copy of *this, adds the
      // argument to that copy using operator+= and then returns the
      // copy.
      /// Add position and offset.
      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }
#pragma empty_line
      // The standard requires that this operator must be defined, but
      // defines it's semantics only in terms of operator+. In this
      // implementation it constructs a copy of *this, subtracts the
      // argument from that copy using operator-= and then returns the
      // copy.
      /// Subtract offset from position.
      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }
#pragma empty_line
      // The standard requires that this operator must be defined, but
      // defines it's semantics only in terms of operator+. In this
      // implementation it returns the difference between the offset
      // stored in *this and in the argument.
      /// Subtract position to return offset.
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };
#pragma empty_line
  // The standard only requires that operator== must be an
  // equivalence relation. In this implementation two fpos<StateT>
  // objects belong to the same equivalence class if the contained
  // offsets compare equal.
  /// Test if equivalent to another position.
  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }
#pragma empty_line
  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }
#pragma empty_line
  // Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos
  // as implementation defined types, but clause 27.2 requires that
  // they must both be typedefs for fpos<mbstate_t>
  /// File position for char streams.
  typedef fpos<mbstate_t> streampos;
  /// File position for wchar_t streams.
  typedef fpos<mbstate_t> wstreampos;
#pragma empty_line
}
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/functexcept.h" 1 3
// Function-Based Exception Support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file functexcept.h
 *  This header provides support for -fno-exceptions.
 */
#pragma empty_line
//
// ISO C++ 14882: 19.1  Exception classes
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/functexcept.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/exception_defines.h" 1 3
// -fno-exceptions Support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2003 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
//
// ISO C++ 14882: 19.1  Exception classes
//
#pragma empty_line
/** @file exception_defines.h
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Iff -fno-exceptions, transform error handling code to work without it.
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/functexcept.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // Helper for exception objects in <except>
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));
#pragma empty_line
  // Helper for exception objects in <new>
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));
#pragma empty_line
  // Helper for exception objects in <typeinfo>
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));
#pragma empty_line
  // Helpers for exception objects in <stdexcept>
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_length_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_range_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  // Helpers for exception objects in basic_ios
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));
#pragma empty_line
}
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;
#pragma empty_line
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // Not included.   (??? Apparently no LWG number?)
  class ios_base;
#pragma empty_line
  /** 
   *  @defgroup s27_2_iosfwd I/O Forward Declarations
   *
   *  Nearly all of the I/O classes are parameterized on the type of
   *  characters they read and write.  (The major exception is ios_base at
   *  the top of the hierarchy.)  This is a change from pre-Standard
   *  streams, which were not templates.
   *
   *  For ease of use and compatibility, all of the basic_* I/O-related
   *  classes are given typedef names for both of the builtin character
   *  widths (wide and narrow).  The typedefs are the same as the
   *  pre-Standard names, for example:
   *
   *  @code
   *     typedef basic_ifstream<char>  ifstream;
   *  @endcode
   *
   *  Because properly forward-declaring these classes can be difficult, you
   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;
   *  header, which contains only declarations of all the I/O classes as
   *  well as the typedefs.  Trying to forward-declare the typedefs
   *  themselves (e.g., "class ostream;") is not valid ISO C++.
   *
   *  For more specific declarations, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#10
   *
   *  @{
  */
  typedef basic_ios<char> ios; ///< @isiosfwd
  typedef basic_streambuf<char> streambuf; ///< @isiosfwd
  typedef basic_istream<char> istream; ///< @isiosfwd
  typedef basic_ostream<char> ostream; ///< @isiosfwd
  typedef basic_iostream<char> iostream; ///< @isiosfwd
  typedef basic_stringbuf<char> stringbuf; ///< @isiosfwd
  typedef basic_istringstream<char> istringstream; ///< @isiosfwd
  typedef basic_ostringstream<char> ostringstream; ///< @isiosfwd
  typedef basic_stringstream<char> stringstream; ///< @isiosfwd
  typedef basic_filebuf<char> filebuf; ///< @isiosfwd
  typedef basic_ifstream<char> ifstream; ///< @isiosfwd
  typedef basic_ofstream<char> ofstream; ///< @isiosfwd
  typedef basic_fstream<char> fstream; ///< @isiosfwd
#pragma empty_line
#pragma empty_line
  typedef basic_ios<wchar_t> wios; ///< @isiosfwd
  typedef basic_streambuf<wchar_t> wstreambuf; ///< @isiosfwd
  typedef basic_istream<wchar_t> wistream; ///< @isiosfwd
  typedef basic_ostream<wchar_t> wostream; ///< @isiosfwd
  typedef basic_iostream<wchar_t> wiostream; ///< @isiosfwd
  typedef basic_stringbuf<wchar_t> wstringbuf; ///< @isiosfwd
  typedef basic_istringstream<wchar_t> wistringstream; ///< @isiosfwd
  typedef basic_ostringstream<wchar_t> wostringstream; ///< @isiosfwd
  typedef basic_stringstream<wchar_t> wstringstream; ///< @isiosfwd
  typedef basic_filebuf<wchar_t> wfilebuf; ///< @isiosfwd
  typedef basic_ifstream<wchar_t> wifstream; ///< @isiosfwd
  typedef basic_ofstream<wchar_t> wofstream; ///< @isiosfwd
  typedef basic_fstream<wchar_t> wfstream; ///< @isiosfwd
#pragma empty_line
  /** @}  */
#pragma empty_line
}
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/exception" 1 3
// Exception Handling support header for -*- C++ -*-
#pragma empty_line
// Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
// 2004, 2005, 2006, 2007
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file exception
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/exception" 2 3
#pragma empty_line
extern "C++" {
#pragma empty_line
namespace std
{
  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();
    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
    virtual const char* what() const throw();
  };
#pragma empty_line
  /** If an %exception is thrown which is not listed in a function's
   *  %exception specification, one of these may be thrown.  */
  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }
    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_exception() throw();
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };
#pragma empty_line
  /// If you write a replacement %terminate handler, it must be of this type.
  typedef void (*terminate_handler) ();
  /// If you write a replacement %unexpected handler, it must be of this type.
  typedef void (*unexpected_handler) ();
#pragma empty_line
  /// Takes a new handler function as an argument, returns the old function.
  terminate_handler set_terminate(terminate_handler) throw();
  /** The runtime will call this function if %exception handling must be
   *  abandoned for any reason.  It can also be called by the user.  */
  void terminate() __attribute__ ((__noreturn__));
#pragma empty_line
  /// Takes a new handler function as an argument, returns the old function.
  unexpected_handler set_unexpected(unexpected_handler) throw();
  /** The runtime will call this function if an %exception is thrown which
   *  violates the function's %exception specification.  */
  void unexpected() __attribute__ ((__noreturn__));
#pragma empty_line
  /** [18.6.4]/1:  "Returns true after completing evaluation of a
   *  throw-expression until either completing initialization of the
   *  exception-declaration in the matching handler or entering @c unexpected()
   *  due to the throw; or after entering @c terminate() for any reason
   *  other than an explicit call to @c terminate().  [Note: This includes
   *  stack unwinding [15.2].  end note]"
   *
   *  2:  "When @c uncaught_exception() is true, throwing an %exception can
   *  result in a call of @c terminate() (15.5.1)."
   */
  bool uncaught_exception() throw();
} // namespace std
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  /** A replacement for the standard terminate_handler which prints more
      information about the terminating exception (if any) on stderr.  Call
      @code
        std::set_terminate (__gnu_cxx::__verbose_terminate_handler)
      @endcode
      to use.  For more info, see
      http://gcc.gnu.org/onlinedocs/libstdc++/19_diagnostics/howto.html#4
#pragma empty_line
      In 3.4 and later, this is on by default.
  */
  void __verbose_terminate_handler ();
#pragma empty_line
}
#pragma empty_line
} // extern "C++"
#pragma empty_line
#pragma GCC visibility pop
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 1 3
// Character Traits for use by standard string and iostream -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file char_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21  Strings library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstring
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 1 3
// Bits and pieces used in algorithms -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstring
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma line 67 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/climits" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/climits
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c limits.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.2.2  Implementation properties: C library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/climits" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/limits.h" 1 3
/* 
 * limits.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Functions for manipulating paths and directories (included from io.h)
 * plus functions for setting the current drive.
 *
 * Defines constants for the sizes of integral types.
 *
 * NOTE: GCC should supply a version of this header and it should be safe to
 *       use that version instead of this one (maybe safer).
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
/*
 * File system limits
 *
 * TODO: NAME_MAX and OPEN_MAX are file system limits or not? Are they the
 *       same as FILENAME_MAX and FOPEN_MAX from stdio.h?
 * NOTE: Apparently the actual size of PATH_MAX is 260, but a space is
 *       required for the NUL. TODO: Test?
 */
#pragma empty_line
#pragma empty_line
/*
 * Characteristics of the char data type.
 *
 * TODO: Is MB_LEN_MAX correct?
 */
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/limits.h" 3
/* TODO: Is this safe? I think it might just be testing the preprocessor,
 *       not the compiler itself... */
#pragma line 56 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/limits.h" 3
/*
 * Maximum and minimum values for ints.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Maximum and minimum values for shorts.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Maximum and minimum values for longs and unsigned longs.
 *
 * TODO: This is not correct for Alphas, which have 64 bit longs.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* POSIX wants this.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* ISO C9x macro names */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * The GNU C compiler also allows 'long long int'
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* MSVC compatibility */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/climits" 2 3
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cstdlib
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdlib.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 2 3
#pragma line 72 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 1 3
/*
 * stdlib.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Definitions for common types, variables, and functions.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
#pragma empty_line
GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */
#pragma empty_line
/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
#pragma empty_line
/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On FreeBSD 5, machine/ansi.h does not exist anymore... */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
#pragma line 97 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
#pragma line 122 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */
#pragma empty_line
/* Signed type of difference of two pointers.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 162 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Unsigned type of `sizeof' something.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 240 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */
#pragma empty_line
/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
#pragma line 360 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
#pragma line 395 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* A null pointer constant.  */
#pragma line 413 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
#pragma line 22 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 2 3
#pragma empty_line
#pragma empty_line
/*
 * RAND_MAX is the maximum value that may be returned by rand.
 * The minimum is zero.
 */
#pragma empty_line
#pragma empty_line
/*
 * These values may be used as exit status codes.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Definitions for path name functions.
 * NOTE: All of these values have simply been chosen to be conservatively high.
 *       Remember that with long file names we can no longer depend on
 *       extensions being short.
 */
#pragma line 60 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * This seems like a convenient place to declare these variables, which
 * give programs using WinMain (or main for that matter) access to main-ish
 * argc and argv. environ is a pointer to a table of environment variables.
 * NOTE: Strings in _argv and environ are ANSI strings.
 */
extern int _argc;
extern char** _argv;
#pragma empty_line
/* imports from runtime dll of the above variables */
#pragma empty_line
#pragma empty_line
extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argc(void);
extern char*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argv(void);
extern wchar_t*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___wargv(void);
#pragma line 105 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
/*
 * Also defined in ctype.h.
 */
#pragma line 129 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
/* 
 * MS likes to declare errno in stdlib.h as well. 
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);
#pragma empty_line
#pragma empty_line
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __doserrno(void);
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Use environ from the DLL, not as a global. 
 */
#pragma empty_line
#pragma empty_line
  extern char *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__environ(void);
  extern wchar_t *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wenviron(void);
#pragma line 166 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
/* One of the MSVCRTxx libraries */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) int _sys_nerr;
#pragma line 196 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) char* _sys_errlist[];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * OS version and such constants.
 */
#pragma empty_line
#pragma empty_line
/* msvcrtxx.dll */
#pragma empty_line
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__osver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winmajor(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winminor(void);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern __attribute__ ((__dllimport__)) unsigned int _osver;
extern __attribute__ ((__dllimport__)) unsigned int _winver;
extern __attribute__ ((__dllimport__)) unsigned int _winmajor;
extern __attribute__ ((__dllimport__)) unsigned int _winminor;
#pragma line 258 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
/* although the _pgmptr is exported as DATA,
 * be safe and use the access function __p__pgmptr() to get it. */
 char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__pgmptr(void);
#pragma empty_line
 wchar_t** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wpgmptr(void);
#pragma line 275 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
/*
 * This variable determines the default file mode.
 * TODO: Which flags work?
 */
#pragma line 293 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) int _fmode;
#pragma line 303 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atof (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoi (const char*);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atol (const char*);
#pragma empty_line
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtof (const wchar_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi (const wchar_t *);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtol (const wchar_t *);
#pragma empty_line
#pragma empty_line
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __strtod (const char*, char**);
#pragma empty_line
/* We require a function with external linkage. */
#pragma empty_line
#pragma empty_line
#pragma empty_line
__inline__ double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
strtod (const char* __restrict__ __nptr, char** __restrict__ __endptr)
{
  return __strtod(__nptr, __endptr);
}
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof (const char * __restrict__, char ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold (const char * __restrict__, char ** __restrict__);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtol (const char*, char**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoul (const char*, char**, int);
#pragma line 353 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstombs (char*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctomb (char*, wchar_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mblen (const char*, size_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbstowcs (wchar_t*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbtowc (wchar_t*, const char*, size_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rand (void);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) srand (unsigned int);
#pragma empty_line
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) calloc (size_t, size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) malloc (size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) realloc (void*, size_t);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) free (void*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abort (void) __attribute__ ((__noreturn__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit (int) __attribute__ ((__noreturn__));
#pragma empty_line
/* Note: This is in startup code, not imported directly from dll */
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atexit (void (*)(void));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) system (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getenv (const char*);
#pragma empty_line
/* bsearch and qsort are also in non-ANSI header search.h  */
 void* __attribute__((__cdecl__)) bsearch (const void*, const void*, size_t, size_t,
          int (*)(const void*, const void*));
 void __attribute__((__cdecl__)) qsort(void*, size_t, size_t,
      int (*)(const void*, const void*));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abs (int) __attribute__ ((__const__));
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) labs (long) __attribute__ ((__const__));
#pragma empty_line
/*
 * div_t and ldiv_t are structures used to return the results of div and
 * ldiv.
 *
 * NOTE: div and ldiv appear not to work correctly unless
 *       -fno-pcc-struct-return is specified. This is included in the
 *       mingw32 specs file.
 */
typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
#pragma empty_line
 div_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) div (int, int) __attribute__ ((__const__));
 ldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ldiv (long, long) __attribute__ ((__const__));
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * NOTE: Officially the three following functions are obsolete. The Win32 API
 *       functions SetErrorMode, Beep and Sleep are their replacements.
 */
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _beep (unsigned int, unsigned int) __attribute__ ((__deprecated__));
/* Not to be confused with  _set_error_mode (int).  */
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _seterrormode (int) __attribute__ ((__deprecated__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _sleep (unsigned long) __attribute__ ((__deprecated__));
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit (int) __attribute__ ((__noreturn__));
#pragma empty_line
/* _onexit is MS extension. Use atexit for portability.  */
/* Note: This is in startup code, not imported directly from dll */
typedef int (* _onexit_t)(void);
_onexit_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _onexit( _onexit_t );
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _searchenv (const char*, const char*, char*);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _gcvt (double, int, char*);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _makepath (char*, const char*, const char*, const char*, const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _splitpath (const char*, char*, char*, char*, char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fullpath (char*, const char*, size_t);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltoa (long, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultoa(unsigned long, char*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itow (int, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltow (long, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultow (unsigned long, wchar_t*, int);
#pragma empty_line
#pragma empty_line
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _atoi64(const char *);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64toa(long long, char *, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64toa(unsigned long long, char *, int);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi64(const wchar_t *);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64tow(long long, wchar_t *, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64tow(unsigned long long, wchar_t *, int);
#pragma empty_line
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rotl(unsigned int, int) __attribute__ ((__const__));
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rotr(unsigned int, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lrotl(unsigned long, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _lrotr(unsigned long, int) __attribute__ ((__const__));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _set_error_mode (int);
#pragma line 485 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) searchenv (const char*, const char*, char*);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ltoa (long, char*, int);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gcvt (double, int, char*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* C99 names */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* C99 name for _exit */
void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _Exit(int) __attribute__ ((__noreturn__));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef struct { long long quot, rem; } lldiv_t;
#pragma empty_line
lldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lldiv (long long, long long) __attribute__ ((__const__));
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) llabs(long long);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoll (const char* __restrict__, char** __restrict, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoull (const char* __restrict__, char** __restrict__, int);
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoll (const char *);
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wtoll (const wchar_t *);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltoa (long long, char *, int);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltoa (unsigned long long , char *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltow (long long, wchar_t *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltow (unsigned long long, wchar_t *, int);
#pragma empty_line
  /* inline using non-ansi functions */
#pragma line 557 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 3
}
#pragma line 73 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 2 3
#pragma empty_line
// Get rid of those macros defined in <stdlib.h> in lieu of real functions.
#pragma line 104 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 3
namespace std {
#pragma empty_line
  using ::div_t;
  using ::ldiv_t;
#pragma empty_line
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
#pragma empty_line
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
#pragma empty_line
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
#pragma empty_line
  using ::wcstombs;
  using ::wctomb;
#pragma empty_line
#pragma empty_line
  inline long
  abs(long __i) { return labs(__i); }
#pragma empty_line
  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
#pragma empty_line
}
#pragma line 161 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 3
namespace __gnu_cxx {
#pragma empty_line
#pragma empty_line
  using ::lldiv_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::_Exit;
#pragma empty_line
#pragma empty_line
  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }
#pragma empty_line
#pragma empty_line
  using ::llabs;
#pragma empty_line
  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
#pragma empty_line
  using ::lldiv;
#pragma line 194 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
#pragma empty_line
  using ::strtof;
  using ::strtold;
#pragma empty_line
}
#pragma empty_line
namespace std {
#pragma empty_line
#pragma empty_line
  using ::__gnu_cxx::lldiv_t;
#pragma empty_line
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;
#pragma empty_line
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
#pragma empty_line
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
#pragma empty_line
}
#pragma line 69 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 70 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 71 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_pair.h" 1 3
// Pair implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  /// pair holds two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type; ///<  @c first_type is the first bound type
      typedef _T2 second_type; ///<  @c second_type is the second bound type
#pragma empty_line
      _T1 first; ///< @c first is a copy of the first object
      _T2 second; ///< @c second is a copy of the second object
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 265.  std::pair::pair() effects overly restrictive
      /** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */
      pair()
      : first(), second() { }
#pragma empty_line
      /** Two objects may be passed to a @c pair constructor to be copied.  */
      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
#pragma empty_line
      /** There is also a templated copy ctor for the @c pair class itself.  */
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };
#pragma empty_line
  /// Two pairs of the same type are equal iff their members are equal.
  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
#pragma empty_line
  /// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>
  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }
#pragma empty_line
  /// Uses @c operator== to find the result.
  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }
#pragma empty_line
  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }
#pragma empty_line
  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }
#pragma empty_line
  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
#pragma empty_line
  /**
   *  @brief A convenience wrapper for creating a pair from two objects.
   *  @param  x  The first object.
   *  @param  y  The second object.
   *  @return   A newly-constructed pair<> object of the appropriate type.
   *
   *  The standard requires that the objects be passed by reference-to-const,
   *  but LWG issue #181 says they should be passed by const value.  We follow
   *  the LWG by default.
   */
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 181.  make_pair() unintended behavior
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
#pragma empty_line
}
#pragma line 72 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 2 3
#pragma empty_line
//
// This file provides some compile-time information about various types.
// These representations were designed, on purpose, to be constant-expressions
// and not types as found in <bits/type_traits.h>.  In particular, they
// can be used in control structures and the optimizer hopefully will do
// the obvious thing.
//
// Why integral expressions, and not functions nor types?
// Firstly, these compile-time entities are used as template-arguments
// so function return values won't work:  We need compile-time entities.
// We're left with types and constant  integral expressions.
// Secondly, from the point of view of ease of use, type-based compile-time
// information is -not- *that* convenient.  On has to write lots of
// overloaded functions and to hope that the compiler will select the right
// one. As a net effect, the overall structure isn't very clear at first
// glance.
// Thirdly, partial ordering and overload resolution (of function templates)
// is highly costly in terms of compiler-resource.  It is a Good Thing to
// keep these resource consumption as least as possible.
//
// See valarray_array.h for a case use.
//
// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
//
// Update 2005: types are also provided and <bits/type_traits.h> has been
// removed.
//
#pragma empty_line
// Forward declaration hack, should really include this from somewhere.
namespace __gnu_cxx {
#pragma empty_line
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
#pragma empty_line
}
#pragma empty_line
namespace std {
#pragma empty_line
namespace __detail
{
  // NB: g++ can not compile these if declared within the class
  // __is_pod itself.
  typedef char __one;
  typedef char __two[2];
#pragma empty_line
  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
} // namespace __detail
#pragma empty_line
#pragma empty_line
  struct __true_type { };
  struct __false_type { };
#pragma empty_line
  template<bool>
    struct __truth_type
    { typedef __false_type __type; };
#pragma empty_line
  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };
#pragma empty_line
  // N.B. The conversions to bool are needed due to the issue
  // explained in c++/19404.
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };
#pragma empty_line
  // Compare for equality of types.
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  // Holds if the template-argument is a void type.
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  //
  // Integer types
  //
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  // Thirteen specializations (yes there are eleven standard integer
  // types; 'long long' and 'unsigned long long' are supported as
  // extensions)
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  //
  // Floating point types
  //
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  // three specializations (float, double and 'long double')
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  //
  // Pointer types
  //
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  //
  // Normal iterator type
  //
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  //
  // An arithmetic type is an integer type or a floating point type
  //
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };
#pragma empty_line
  //
  // A fundamental type is `void' or and arithmetic type
  //
  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };
#pragma empty_line
  //
  // A scalar type is an arithmetic type or a pointer type
  // 
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };
#pragma empty_line
  // For the immediate use, the following is a good approximation.
  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__detail::__test_type<_Tp>(0))
       != sizeof(__detail::__one))
 };
    };
#pragma empty_line
  //
  // A stripped-down version of std::tr1::is_empty
  //
  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };
#pragma empty_line
    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };
#pragma empty_line
  //
  // For use in std::copy and std::find overloads for streambuf iterators.
  //
  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
}
#pragma line 73 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 1 3
// -*- C++ -*-
#pragma empty_line
// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later
// version.
#pragma empty_line
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free
// software library without restriction.  Specifically, if other files
// instantiate templates or use macros or inline functions from this
// file, or you compile this file and link it with other files to
// produce an executable, this file does not by itself cause the
// resulting executable to be covered by the GNU General Public
// License.  This exception does not however invalidate any other
// reasons why the executable file might be covered by the GNU General
// Public License.
#pragma empty_line
/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 41 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/utility" 1 3
// <utility> -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file include/utility
 *  This is a Standard C++ Library header. 
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 64 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/utility" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/utility" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_relops.h" 1 3
// std::rel_ops implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */
#pragma empty_line
/** @file stl_relops.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  @if maint
 *  Inclusion of this file has been removed from
 *  all of the other STL headers for safety reasons, except std_utility.h.
 *  For more information, see the thread of about twenty messages starting
 *  with http://gcc.gnu.org/ml/libstdc++/2001-01/msg00223.html , or the
 *  FAQ at http://gcc.gnu.org/onlinedocs/libstdc++/faq/index.html#4_4 .
 *
 *  Short summary:  the rel_ops operators should be avoided for the present.
 *  @endif
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  namespace rel_ops
  {
    /** @namespace std::rel_ops
     *  @brief  The generated relational operators are sequestered here.
     */
#pragma empty_line
    /**
     *  @brief Defines @c != for arbitrary types, in terms of @c ==.
     *  @param  x  A thing.
     *  @param  y  Another thing.
     *  @return   x != y
     *
     *  This function uses @c == to determine its result.
     */
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
#pragma empty_line
    /**
     *  @brief Defines @c > for arbitrary types, in terms of @c <.
     *  @param  x  A thing.
     *  @param  y  Another thing.
     *  @return   x > y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
#pragma empty_line
    /**
     *  @brief Defines @c <= for arbitrary types, in terms of @c <.
     *  @param  x  A thing.
     *  @param  y  Another thing.
     *  @return   x <= y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
#pragma empty_line
    /**
     *  @brief Defines @c >= for arbitrary types, in terms of @c <.
     *  @param  x  A thing.
     *  @param  y  Another thing.
     *  @return   x >= y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
#pragma empty_line
  } // namespace rel_ops
#pragma empty_line
}
#pragma line 67 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/utility" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_pair.h" 1 3
// Pair implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/utility" 2 3
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 2 3
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  // Define a nested type if some predicate holds.
  template<bool, typename>
    struct __enable_if
    { };
#pragma empty_line
  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };
#pragma empty_line
#pragma empty_line
  // Conditional expression for types. If true, first, if false, second.
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };
#pragma empty_line
  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };
#pragma empty_line
#pragma empty_line
  // Given an integral builtin type, return the corresponding unsigned type.
  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
#pragma empty_line
    public:
      typedef typename __if_type::__type __type;
    };
#pragma empty_line
  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };
#pragma empty_line
  // Declare but don't define.
  template<>
    struct __add_unsigned<bool>;
#pragma empty_line
  template<>
    struct __add_unsigned<wchar_t>;
#pragma empty_line
#pragma empty_line
  // Given an integral builtin type, return the corresponding signed type.
  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
#pragma empty_line
    public:
      typedef typename __if_type::__type __type;
    };
#pragma empty_line
  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };
#pragma empty_line
  // Declare but don't define.
  template<>
    struct __remove_unsigned<bool>;
#pragma empty_line
  template<>
    struct __remove_unsigned<wchar_t>;
#pragma empty_line
}
#pragma line 74 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
// Types used in iterator implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_iterator_base_types.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  This file contains all of the general iterator-related utility types,
 *  such as iterator_traits and struct iterator.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
#pragma empty_line
namespace std {
#pragma empty_line
  //@{
  /**
   *  @defgroup iterator_tags Iterator Tags
   *  These are empty types, used to distinguish different iterators.  The
   *  distinction is not made by what they contain, but simply by what they
   *  are.  Different underlying algorithms can then be used based on the
   *  different operations supporetd by different iterator types.
  */
  ///  Marking input iterators.
  struct input_iterator_tag {};
  ///  Marking output iterators.
  struct output_iterator_tag {};
  /// Forward iterators support a superset of input iterator operations.
  struct forward_iterator_tag : public input_iterator_tag {};
  /// Bidirectional iterators support a superset of forward iterator
  /// operations.
  struct bidirectional_iterator_tag : public forward_iterator_tag {};
  /// Random-access iterators support a superset of bidirectional iterator
  /// operations.
  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
  //@}
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
  */
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      /// One of the @link iterator_tags tag types@endlink.
      typedef _Category iterator_category;
      /// The type "pointed to" by the iterator.
      typedef _Tp value_type;
      /// Distance between iterators is represented as this type.
      typedef _Distance difference_type;
      /// This type represents a pointer-to-value_type.
      typedef _Pointer pointer;
      /// This type represents a reference-to-value_type.
      typedef _Reference reference;
    };
#pragma empty_line
  /**
   *  This class does nothing but define nested typedefs.  The general
   *  version simply "forwards" the nested typedefs from the Iterator
   *  argument.  Specialized versions for pointers and pointers-to-const
   *  provide tighter, more correct semantics.
  */
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };
#pragma empty_line
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };
#pragma empty_line
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };
#pragma empty_line
  /**
   *  @if maint
   *  This function is not a part of the C++ standard but is syntactic
   *  sugar for internal library use only.
   *  @endif
  */
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
#pragma empty_line
}
#pragma line 75 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 1 3
// Functions used by iterators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_iterator_base_funcs.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  This file contains all of the general iterator-related utility
 *  functions, such as distance() and advance().
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 69 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/concept_check.h" 1 3
// Concept-checking control -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file concept_check.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/concept_check.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 41 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/concept_check.h" 2 3
#pragma empty_line
// All places in libstdc++-v3 where these are used, or /might/ be used, or
// don't need to be used, or perhaps /should/ be used, are commented with
// "concept requirements" (and maybe some more text).  So grep like crazy
// if you're looking for additional places to use these.
#pragma empty_line
// Concept-checking code is off by default unless users turn it on via
// configure options or editing c++config.h.
#pragma line 70 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }
#pragma empty_line
  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      return __last - __first;
    }
#pragma empty_line
  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  first  An input iterator.
   *  @param  last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that first + n == last.  This requires that @p last
   *  must be reachable from @p first.  Note that @c n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
      // concept requirements -- taken care of in __distance
      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }
#pragma empty_line
  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
      // concept requirements
#pragma empty_line
      while (__n--)
 ++__i;
    }
#pragma empty_line
  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      __i += __n;
    }
#pragma empty_line
  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  i  An input iterator.
   *  @param  n  The "delta" by which to change @p i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p n may be negative, in which case @p i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
#pragma empty_line
}
#pragma line 76 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator.h" 1 3
// Iterators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 70 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 1 3
// -*- C++ -*-
#pragma empty_line
// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later
// version.
#pragma empty_line
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free
// software library without restriction.  Specifically, if other files
// instantiate templates or use macros or inline functions from this
// file, or you compile this file and link it with other files to
// produce an executable, this file does not by itself cause the
// resulting executable to be covered by the GNU General Public
// License.  This exception does not however invalidate any other
// reasons why the executable file might be covered by the GNU General
// Public License.
#pragma empty_line
/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma line 71 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 24.4.1 Reverse iterators
  /**
   *  "Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array." [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
  */
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;
#pragma empty_line
    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;
#pragma empty_line
    public:
      /**
       *  The default constructor default-initializes member @p current.
       *  If it is a pointer, that means it is zero-initialized.
      */
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 235 No specification of default ctor for reverse_iterator
      reverse_iterator() : current() { }
#pragma empty_line
      /**
       *  This %iterator will move in the opposite direction that @p x does.
      */
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }
#pragma empty_line
      /**
       *  The copy constructor is normal.
      */
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }
#pragma empty_line
      /**
       *  A reverse_iterator across other types can be copied in the normal
       *  fashion.
      */
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }
#pragma empty_line
      /**
       *  @return  @c current, the %iterator used for underlying work.
      */
      iterator_type
      base() const
      { return current; }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      pointer
      operator->() const
      { return &(operator*()); }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }
#pragma empty_line
      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
#pragma empty_line
  //@{
  /**
   *  @param  x  A %reverse_iterator.
   *  @param  y  A %reverse_iterator.
   *  @return  A simple bool.
   *
   *  Reverse iterators forward many operations to their underlying base()
   *  iterators.  Others are implemented in terms of one another.
   *
  */
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }
#pragma empty_line
  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
#pragma empty_line
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
  //@}
#pragma empty_line
  // 24.4.2.2.1 back_insert_iterator
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
#pragma empty_line
    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;
#pragma empty_line
      /// The only way to create this %iterator is with a container.
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
#pragma empty_line
      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a "position" in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      */
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
#pragma empty_line
      /// Simply returns *this.
      back_insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      back_insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
#pragma empty_line
  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of back_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating back_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
#pragma empty_line
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator prepends it to the container using
   *  push_front.
   *
   *  Tip:  Using the front_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
#pragma empty_line
    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;
#pragma empty_line
      /// The only way to create this %iterator is with a container.
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
#pragma empty_line
      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a "position" in the
       *  container (you can think of the position as being permanently at
       *  the front, if you like).  Assigning a value to the %iterator will
       *  always prepend the value to the front of the container.
      */
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
#pragma empty_line
      /// Simply returns *this.
      front_insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      front_insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
#pragma empty_line
  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of front_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating front_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
#pragma empty_line
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;
#pragma empty_line
    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;
#pragma empty_line
      /**
       *  The only way to create this %iterator is with a container and an
       *  initial position (a normal %iterator into the container).
      */
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
#pragma empty_line
      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator maintains its own position in the
       *  container.  Assigning a value to the %iterator will insert the
       *  value into the container at the place before the %iterator.
       *
       *  The position is maintained such that subsequent assignments will
       *  insert values immediately after one another.  For example,
       *  @code
       *     // vector v contains A and Z
       *
       *     insert_iterator i (v, ++v.begin());
       *     i = 1;
       *     i = 2;
       *     i = 3;
       *
       *     // vector v contains A, 1, 2, 3, and Z
       *  @endcode
      */
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
#pragma empty_line
      /// Simply returns *this.
      insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
      /// Simply returns *this.  (This %iterator does not "move".)
      insert_iterator&
      operator++(int)
      { return *this; }
    };
#pragma empty_line
  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
#pragma empty_line
}
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;
#pragma empty_line
    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;
#pragma empty_line
      __normal_iterator() : _M_current(_Iterator()) { }
#pragma empty_line
      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
#pragma empty_line
      // Allow iterator to const_iterator conversion
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }
#pragma empty_line
      // Forward iterator requirements
      reference
      operator*() const
      { return *_M_current; }
#pragma empty_line
      pointer
      operator->() const
      { return _M_current; }
#pragma empty_line
      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }
#pragma empty_line
      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }
#pragma empty_line
      // Bidirectional iterator requirements
      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }
#pragma empty_line
      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }
#pragma empty_line
      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }
#pragma empty_line
      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }
#pragma empty_line
      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }
#pragma empty_line
      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }
#pragma empty_line
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }
#pragma empty_line
      const _Iterator&
      base() const
      { return _M_current; }
    };
#pragma empty_line
  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby
#pragma empty_line
  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
#pragma empty_line
  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
#pragma empty_line
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
#pragma empty_line
}
#pragma line 77 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/concept_check.h" 1 3
// Concept-checking control -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file concept_check.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 78 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/** Macros and namespaces used by the implementation outside of debug
 *  wrappers to verify certain properties. The __glibcxx_requires_xxx
 *  macros are merely wrappers around the __glibcxx_check_xxx wrappers
 *  when we are compiling with debug mode, but disappear when we are
 *  in release mode so that there is no checking performed in, e.g.,
 *  the standard library algorithms.
*/
#pragma empty_line
// Debug mode namespaces.
namespace std
{
  namespace __debug { }
}
#pragma empty_line
namespace __gnu_cxx
{
  namespace __debug { };
}
#pragma empty_line
namespace __gnu_debug
{
  using namespace std::__debug;
  using namespace __gnu_cxx::__debug;
}
#pragma line 79 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @brief Swaps two values.
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @return   Nothing.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  any type which has a copy constructor and an assignment operator.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
#pragma empty_line
  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
  // nutshell, we are partially implementing the resolution of DR 187,
  // when it's safe, i.e., the value_types are equal.
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };
#pragma empty_line
  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
#pragma empty_line
  /**
   *  @brief Swaps the contents of two iterators.
   *  @param  a  An iterator.
   *  @param  b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
#pragma empty_line
  /**
   *  @brief This does what you think it does.
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
#pragma empty_line
      //return __b < __a ? __b : __a;
      if (__b < __a)
 return __b;
      return __a;
    }
#pragma empty_line
  /**
   *  @brief This does what you think it does.
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
#pragma empty_line
      //return  __a < __b ? __b : __a;
      if (__a < __b)
 return __b;
      return __a;
    }
#pragma empty_line
  /**
   *  @brief This does what you think it does.
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
   *  @return   The lesser of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__b, __a) ? __b : __a;
      if (__comp(__b, __a))
 return __b;
      return __a;
    }
#pragma empty_line
  /**
   *  @brief This does what you think it does.
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__a, __b) ? __b : __a;
      if (__comp(__a, __b))
 return __b;
      return __a;
    }
#pragma empty_line
  // All of these auxiliary structs serve two purposes.  (1) Replace
  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
  // because the input and output ranges are permitted to overlap.)
  // (2) If we're using random access iterators, then write the loop as
  // a for loop with an explicit count.
#pragma empty_line
  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
#pragma empty_line
  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
#pragma empty_line
  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };
#pragma empty_line
  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);
#pragma empty_line
      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }
#pragma empty_line
  // Helpers for streambuf iterators (either istream or ostream).
  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT*, _CharT*, ostreambuf_iterator<_CharT>);
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT*, const _CharT*, ostreambuf_iterator<_CharT>);
#pragma empty_line
  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
        _CharT*);
#pragma empty_line
  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };
#pragma empty_line
  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };
#pragma empty_line
  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };
#pragma empty_line
  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
#pragma empty_line
  /**
   *  @brief Copies the range [first,last) into result.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  result An output iterator.
   *  @return   result + (first - last)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::__copy_n(__first, __last,
       __result);
    }
#pragma empty_line
  // Overload for streambuf iterators.
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                 ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  ostreambuf_iterator<_CharT>);
#pragma empty_line
  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
#pragma empty_line
  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
#pragma empty_line
  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };
#pragma empty_line
  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
#pragma empty_line
      return std::__copy_backward<__simple, _Category>::__copy_b(__first,
         __last,
         __result);
    }
#pragma empty_line
  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };
#pragma empty_line
  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };
#pragma empty_line
  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };
#pragma empty_line
  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
#pragma empty_line
  /**
   *  @brief Copies the range [first,last) into result.
   *  @param  first  A bidirectional iterator.
   *  @param  last   A bidirectional iterator.
   *  @param  result A bidirectional iterator.
   *  @return   result - (first - last)
   *
   *  The function has the same effect as copy, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range [first,last).  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::__copy_b_n(__first,
           __last,
           __result);
    }
#pragma empty_line
  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };
#pragma empty_line
  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
#pragma empty_line
  /**
   *  @brief Fills the range [first,last) with copies of value.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @param  value  A reference-to-const of arbitrary type.
   *  @return   Nothing.
   *
   *  This function fills a range with copies of the same value.  For one-byte
   *  types filling contiguous areas of memory, this becomes an inline call to
   *  @c memset.
  */
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }
#pragma empty_line
  // Specialization: for one-byte types we can use memset.
  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }
#pragma empty_line
  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
#pragma empty_line
  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
#pragma empty_line
  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };
#pragma empty_line
  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
#pragma empty_line
  /**
   *  @brief Fills the range [first,first+n) with copies of value.
   *  @param  first  An output iterator.
   *  @param  n      The count of copies to perform.
   *  @param  value  A reference-to-const of arbitrary type.
   *  @return   The iterator at first+n.
   *
   *  This function fills a range with copies of the same value.  For one-byte
   *  types filling contiguous areas of memory, this becomes an inline call to
   *  @c memset.
  */
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }
#pragma empty_line
  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
#pragma empty_line
  template<typename _Size>
    inline signed char*
    fill_n(signed char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
#pragma empty_line
  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
#pragma empty_line
  /**
   *  @brief Finds the places in ranges which don't match.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#pragma empty_line
  /**
   *  @brief Finds the places in ranges which don't match.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  binary_pred  A binary predicate @link s20_3_1_base functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#pragma empty_line
  /**
   *  @brief Tests a range for element-wise equality.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
#pragma empty_line
  /**
   *  @brief Tests a range for element-wise equality.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  binary_pred  A binary predicate @link s20_3_1_base functor@endlink.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
#pragma empty_line
  /**
   *  @brief Performs "dictionary" comparison on ranges.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  "Returns true if the sequence of elements defined by the range
   *  [first1,last1) is lexicographically less than the sequence of elements
   *  defined by the range [first2,last2).  Returns false otherwise."
   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
   *  then this is an inline call to @c memcmp.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
#pragma empty_line
  /**
   *  @brief Performs "dictionary" comparison on ranges.
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  last2   An input iterator.
   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
   *  @return   A boolean true or false.
   *
   *  The same as the four-parameter @c lexigraphical_compare, but uses the
   *  comp parameter instead of @c <.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
#pragma empty_line
  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;
#pragma empty_line
    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }
#pragma empty_line
  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;
#pragma empty_line
#pragma empty_line
    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  }
#pragma empty_line
}
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/postypes.h" 1 3
// Position types -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file postypes.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4.1 - Types
// ISO C++ 14882: 27.4.3 - Template class fpos
//
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 2 3
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  /**
   *  @brief  Mapping from character type to associated types.
   *
   *  @note This is an implementation class for the generic version
   *  of char_traits.  It defines int_type, off_type, pos_type, and
   *  state_type.  By default these are unsigned long, streamoff,
   *  streampos, and mbstate_t.  Users who need a different set of
   *  types, but who don't need to change the definitions of any function
   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
   *  while leaving __gnu_cxx::char_traits alone. */
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamentl types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5
   *  for advice on how to make use of this class for "unusual" character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   */
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static std::size_t
      length(const char_type* __s);
#pragma empty_line
      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
#pragma empty_line
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof()
      { return static_cast<int_type>((-1)); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };
#pragma empty_line
  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }
#pragma empty_line
  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }
#pragma empty_line
  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
#pragma empty_line
}
#pragma empty_line
namespace std {
#pragma empty_line
  // 21.1
  /**
   *  @brief  Basis for explicit traits specializations.
   *
   *  @note  For any given actual character type, this definition is
   *  probably wrong.  Since this is just a thin wrapper around
   *  __gnu_cxx::char_traits, it is possible to achieve a more
   *  appropriate definition by specializing __gnu_cxx::char_traits.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5
   *  for advice on how to make use of this class for "unusual" character
   *  types. Also, check out include/ext/pod_char_traits.h.
  */
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };
#pragma empty_line
#pragma empty_line
  /// @brief  21.1.3.1  char_traits specializations
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }
#pragma empty_line
      static size_t
      length(const char_type* __s)
      { return strlen(__s); }
#pragma empty_line
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }
#pragma empty_line
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
#pragma empty_line
      // To keep both the byte 0xff and the eof symbol 0xffffffff
      // from ending up as 0xffffffff.
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof() { return static_cast<int_type>((-1)); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /// @brief  21.1.3.2  char_traits specializations
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }
#pragma empty_line
      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }
#pragma empty_line
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }
#pragma empty_line
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }
#pragma empty_line
      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof() { return static_cast<int_type>((wchar_t)(0xFFFF)); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
#pragma empty_line
#pragma empty_line
}
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstdio" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 27.8.2  C Library files
//
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++locale.h" 1 3
// Wrapper for underlying C-language localization -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++locale.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.8  Standard locale categories.
//
#pragma empty_line
// Written by Benjamin Kosnik <bkoz@redhat.com>
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/functexcept.h" 1 3
// Function-Based Exception Support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file functexcept.h
 *  This header provides support for -fno-exceptions.
 */
#pragma empty_line
//
// ISO C++ 14882: 19.1  Exception classes
//
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 22.1.1 Locale
  class locale;
#pragma empty_line
  // 22.1.3 Convenience interfaces
  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);
#pragma empty_line
  // 22.2.1 and 22.2.1.3 ctype
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;
#pragma empty_line
  template<> class ctype<wchar_t>;
#pragma empty_line
  template<typename _CharT>
    class ctype_byname;
  // NB: Specialized for char and wchar_t in locale_facets.h.
#pragma empty_line
  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;
#pragma empty_line
  template<> class codecvt<wchar_t, char, mbstate_t>;
#pragma empty_line
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;
#pragma empty_line
  // 22.2.2 and 22.2.3 numeric
#pragma empty_line
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
#pragma empty_line
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
#pragma empty_line
  // 22.2.4 collation
  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;
#pragma empty_line
  // 22.2.5 date and time
  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;
#pragma empty_line
  // 22.2.6 money
  class money_base;
#pragma empty_line
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
#pragma empty_line
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
#pragma empty_line
  // 22.2.7 message retrieval
  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
#pragma empty_line
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
#pragma empty_line
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
#pragma empty_line
  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
#pragma empty_line
}
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ios_base.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4  Iostreams base classes
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 1 3
// Support for atomic operations -*- C++ -*-
#pragma empty_line
// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file atomicity.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/gthr.h" 1 3
/* Threads compatibility routines for libgcc2.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997, 1998, 2004 Free Software Foundation, Inc.
#pragma empty_line
This file is part of GCC.
#pragma empty_line
GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.
#pragma empty_line
GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
#pragma empty_line
You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.  */
#pragma empty_line
/* As a special exception, if you link this library with other files,
   some of which are compiled with GCC, to produce an executable,
   this library does not by itself cause the resulting executable
   to be covered by the GNU General Public License.
   This exception does not however invalidate any other reasons why
   the executable file might be covered by the GNU General Public License.  */
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/atomic_word.h" 1 3
// Low-level type for atomic operations -*- C++ -*-
#pragma empty_line
// Copyright (C) 2004 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file atomic_word.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _Atomic_word;
#pragma empty_line
// Define these two macros using the appropriate memory barrier for the target.
// The commented out versions below are the defaults.
// See ia64/atomic_word.h for an alternative approach.
#pragma empty_line
// This one prevents loads from being hoisted across the barrier;
// in other words, this is a Load-Load acquire barrier.
// This is necessary iff TARGET_RELAXED_ORDERING is defined in tm.h.  
// #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")
#pragma empty_line
// This one prevents stores from being sunk across the barrier; in other
// words, a Store-Store release barrier.
// #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")
#pragma line 41 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 2 3
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  // Functions for portable atomic access.
  // To abstract locking primatives across all thread policies, use:
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#pragma empty_line
  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }
#pragma empty_line
  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }
#pragma empty_line
  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }
#pragma empty_line
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    return __exchange_and_add_single(__mem, __val);
#pragma empty_line
  }
#pragma empty_line
  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    __atomic_add_single(__mem, __val);
#pragma empty_line
  }
#pragma empty_line
}
#pragma empty_line
// Even if the CPU doesn't need a memory barrier, we need to ensure
// that the compiler doesn't reorder memory accesses across the
// barriers.
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_classes.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstring
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 1 3
// Components for manipulating sequences of characters -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/string
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 21  Strings library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stringfwd.h" 1 3
// String support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file stringfwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21 Strings library
//
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/char_traits.h" 1 3
// Character Traits for use by standard string and iostream -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file char_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21  Strings library
//
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 1 3
// <memory> -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 * Copyright (c) 1997-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */
#pragma empty_line
/** @file include/memory
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 1 3
// Bits and pieces used in algorithms -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/allocator.h" 1 3
// Allocators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file allocator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Define the base class to std::allocator.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++allocator.h" 1 3
// Base to std::allocator -*- C++ -*-
#pragma empty_line
// Copyright (C) 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++allocator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Define new_allocator as the base class to std::allocator.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/new_allocator.h" 1 3
// Allocator that wraps operator new -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ext/new_allocator.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/new" 1 3
// The -*- C++ -*- dynamic memory management header.
#pragma empty_line
// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007
// Free Software Foundation
#pragma empty_line
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file new
 *  This is a Standard C++ Library header.
 *
 *  The header @c new defines several functions to manage dynamic memory and
 *  handling memory allocation errors; see
 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstddef" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 18.1  Types
//
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/new" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/exception" 1 3
// Exception Handling support header for -*- C++ -*-
#pragma empty_line
// Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
// 2004, 2005, 2006, 2007
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file exception
 *  This is a Standard C++ Library header.
 */
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/new" 2 3
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
extern "C++" {
#pragma empty_line
namespace std
{
  /**
   *  @brief  Exception possibly thrown by @c new.
   *
   *  @c bad_alloc (or classes derived from it) is used to report allocation
   *  errors from the throwing forms of @c new.  */
  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }
    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_alloc() throw();
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };
#pragma empty_line
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  /** If you write your own error handler to be called by @c new, it must
   *  be of this type.  */
  typedef void (*new_handler)();
  /// Takes a replacement handler as the argument, returns the previous handler.
  new_handler set_new_handler(new_handler) throw();
} // namespace std
#pragma empty_line
//@{
/** These are replaceable signatures:
 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 *  - normal array new and delete (same)
 *  - @c nothrow single new and delete (take a @c nothrow argument, return
 *    @c NULL on error)
 *  - @c nothrow array new and delete (same)
 *
 *  Placement new and delete signatures (take a memory address argument,
 *  does nothing) may not be replaced by a user's program.
*/
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();
#pragma empty_line
// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
#pragma empty_line
// Default placement versions of operator delete.
inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }
//@}
} // extern "C++"
#pragma empty_line
#pragma GCC visibility pop
#pragma line 38 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/new_allocator.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/functexcept.h" 1 3
// Function-Based Exception Support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file functexcept.h
 *  This header provides support for -fno-exceptions.
 */
#pragma empty_line
//
// ISO C++ 14882: 19.1  Exception classes
//
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/new_allocator.h" 2 3
#pragma empty_line
namespace __gnu_cxx {
#pragma empty_line
  using std::size_t;
  using std::ptrdiff_t;
#pragma empty_line
  /**
   *  @brief  An allocator that uses global new, as per [20.4].
   *
   *  This is precisely the allocator defined in the C++ Standard. 
   *    - all allocation calls operator new
   *    - all deallocation calls operator delete
   */
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };
#pragma empty_line
      new_allocator() throw() { }
#pragma empty_line
      new_allocator(const new_allocator&) throw() { }
#pragma empty_line
      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }
#pragma empty_line
      ~new_allocator() throw() { }
#pragma empty_line
      pointer
      address(reference __x) const { return &__x; }
#pragma empty_line
      const_pointer
      address(const_reference __x) const { return &__x; }
#pragma empty_line
      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();
#pragma empty_line
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }
#pragma empty_line
      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
#pragma empty_line
      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_] allocator::construct
      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }
#pragma empty_line
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
#pragma empty_line
}
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++allocator.h" 2 3
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/allocator.h" 2 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 56 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/allocator.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _Tp>
    class allocator;
#pragma empty_line
  /// allocator<void> specialization.
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
#pragma empty_line
  /**
   * @brief  The "standard" allocator, as per [20.4].
   *
   *  Further details:
   *  http://gcc.gnu.org/onlinedocs/libstdc++/20_util/allocator.html
   */
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
#pragma empty_line
      allocator() throw() { }
#pragma empty_line
      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }
#pragma empty_line
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
#pragma empty_line
      ~allocator() throw() { }
#pragma empty_line
      // Inherit everything else.
    };
#pragma empty_line
  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }
#pragma empty_line
  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB: This syntax is a GNU extension.
#pragma empty_line
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
#pragma empty_line
#pragma empty_line
  // Undefine.
#pragma empty_line
#pragma empty_line
  // To implement Option 3 of DR 431.
  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };
#pragma empty_line
  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {
 // Precondition: swappable allocators.
 if (__one != __two)
   swap(__one, __two);
      }
    };
#pragma empty_line
}
#pragma line 55 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_construct.h" 1 3
// nonstandard construct and destroy functions -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_construct.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 65 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_construct.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/new" 1 3
// The -*- C++ -*- dynamic memory management header.
#pragma empty_line
// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007
// Free Software Foundation
#pragma empty_line
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file new
 *  This is a Standard C++ Library header.
 *
 *  The header @c new defines several functions to manage dynamic memory and
 *  handling memory allocation errors; see
 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
 */
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_construct.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   * @if maint
   * Constructs an object in existing memory by invoking an allocated
   * object's constructor with an initializer.
   * @endif
   */
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_]allocator::construct
      ::new(static_cast<void*>(__p)) _T1(__value);
    }
#pragma empty_line
  /**
   * @if maint
   * Constructs an object in existing memory by invoking an allocated
   * object's default constructor (no initializers).
   * @endif
   */
  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_]allocator::construct
      ::new(static_cast<void*>(__p)) _T1();
    }
#pragma empty_line
  /**
   * @if maint
   * Destroy the object pointed to by a pointer type.
   * @endif
   */
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
#pragma empty_line
  /**
   * @if maint
   * Destroy a range of objects with nontrivial destructors.
   *
   * This is a helper function used only by _Destroy().
   * @endif
   */
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
#pragma empty_line
  /**
   * @if maint
   * Destroy a range of objects with trivial destructors.  Since the destructors
   * are trivial, there's nothing to do and hopefully this function will be
   * entirely optimized away.
   *
   * This is a helper function used only by _Destroy().
   * @endif
   */
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
#pragma empty_line
  /**
   * @if maint
   * Destroy a range of objects.  If the value_type of the object has
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   * @endif
   */
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;
#pragma empty_line
      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
#pragma empty_line
  /**
   * @if maint
   * Destroy a range of objects using the supplied allocator.  For
   * nondefault allocators we do not optimize away invocation of 
   * destroy() even if _Tp has a trivial destructor.
   * @endif
   */
#pragma empty_line
  template <typename _Tp> class allocator;
#pragma empty_line
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }
#pragma empty_line
}
#pragma line 56 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
// Types used in iterator implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_iterator_base_types.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  This file contains all of the general iterator-related utility types,
 *  such as iterator_traits and struct iterator.
 */
#pragma line 57 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
// Raw memory manipulators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cstring" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cstring
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.4.6  C library
//
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_uninitialized.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // uninitialized_copy
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }
#pragma empty_line
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
   ;
 }
    }
#pragma empty_line
  /**
   *  @brief Copies the range [first,last) into result.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  result An output iterator.
   *  @return   result + (first - last)
   *
   *  Like copy(), but does not require an initialized output range.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }
#pragma empty_line
  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }
#pragma empty_line
  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }
#pragma empty_line
  // Valid if copy construction is equivalent to assignment, and if the
  // destructor is trivial.
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur);
   ;
 }
    }
#pragma empty_line
  /**
   *  @brief Copies the value x into the range [first,last).
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  x      The source value.
   *  @return   Nothing.
   *
   *  Like fill(), but does not require an initialized output range.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }
#pragma empty_line
  // Valid if copy construction is equivalent to assignment, and if the
  //  destructor is trivial.
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }
#pragma empty_line
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur);
   ;
 }
    }
#pragma empty_line
  /**
   *  @brief Copies the value x into the range [first,first+n).
   *  @param  first  An input iterator.
   *  @param  n      The number of copies to make.
   *  @param  x      The source value.
   *  @return   Nothing.
   *
   *  Like fill_n(), but does not require an initialized output range.
  */
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
#pragma empty_line
  // Extensions: versions of uninitialized_copy, uninitialized_fill,
  //  and uninitialized_fill_n that take an allocator parameter.
  //  We dispatch back to the standard versions when we're given the
  //  default allocator.  For nondefault allocators we do not use 
  //  any of the POD optimizations.
#pragma empty_line
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
   ;
 }
    }
#pragma empty_line
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    { return std::uninitialized_copy(__first, __last, __result); }
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    { std::uninitialized_fill(__first, __last, __x); }
#pragma empty_line
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }
#pragma empty_line
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    { std::uninitialized_fill_n(__first, __n, __x); }
#pragma empty_line
#pragma empty_line
  // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill,
  // __uninitialized_fill_copy.  All of these algorithms take a user-
  // supplied allocator, which is used for construction and destruction.
#pragma empty_line
  // __uninitialized_copy_copy
  // Copies [first1, last1) into [result, result + (last1 - first1)), and
  //  copies [first2, last2) into
  //  [result, result + (last1 - first1) + (last2 - first2)).
#pragma empty_line
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }
#pragma empty_line
  // __uninitialized_fill_copy
  // Fills [result, mid) with x, and copies [first, last) into
  //  [mid, mid + (last - first)).
  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }
#pragma empty_line
  // __uninitialized_copy_fill
  // Copies [first1, last1) into [first2, first2 + (last1 - first1)), and
  //  fills [first2 + (last1 - first1), last2) with x.
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   ;
 }
    }
#pragma empty_line
}
#pragma line 58 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_raw_storage_iter.h" 1 3
// -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_raw_storage_iter.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  This iterator class lets algorithms store their results into
   *  uninitialized memory.
  */
  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;
#pragma empty_line
    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}
#pragma empty_line
      raw_storage_iterator&
      operator*() { return *this; }
#pragma empty_line
      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }
#pragma empty_line
      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }
#pragma empty_line
      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
#pragma empty_line
}
#pragma line 59 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma line 60 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 1 3
// The template and inlines for the numeric_limits classes. -*- C++ -*- 
#pragma empty_line
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2005 
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file limits
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>
#pragma empty_line
//
// ISO 14882:1998
// 18.2.1
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 2 3
#pragma empty_line
//
// The numeric_limits<> traits document implementation-defined aspects
// of fundamental arithmetic data types (integers and floating points).
// From Standard C++ point of view, there are 13 such types:
//   * integers
//         bool						        (1)
//         char, signed char, unsigned char			(3)
//         short, unsigned short				(2)
//         int, unsigned					(2)
//         long, unsigned long					(2)
//
//   * floating points
//         float						(1)
//         double						(1)
//         long double						(1)
//
// GNU C++ undertstands (where supported by the host C-library)
//   * integer
//         long long, unsigned long long			(2)
//
// which brings us to 15 fundamental arithmetic data types in GNU C++.
//
//
// Since a numeric_limits<> is a bit tricky to get right, we rely on
// an interface composed of macros which should be defined in config/os
// or config/cpu when they differ from the generic (read arbitrary)
// definitions given here.
//
#pragma empty_line
// These values can be overridden in the target configuration file.
// The default values are appropriate for many 32-bit targets.
#pragma empty_line
// GCC only intrinsicly supports modulo integral types.  The only remaining
// integral exceptional values is division by zero.  Only targets that do not
// signal division by zero in some "hard to ignore" way should use false.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// float
//
#pragma empty_line
// Default values.  Should be overriden in configuration files if necessary.
#pragma line 104 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 3
// double
#pragma empty_line
// Default values.  Should be overriden in configuration files if necessary.
#pragma line 118 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 3
// long double
#pragma empty_line
// Default values.  Should be overriden in configuration files if necessary.
#pragma line 132 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 3
// You should not need to define any macros below this point.
#pragma line 145 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 3
// The fraction 643/2136 approximates log10(2) to 7 significant digits.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @brief Describes the rounding style for floating-point types.
   *
   *  This is used in the std::numeric_limits class.
  */
  enum float_round_style
  {
    round_indeterminate = -1, ///< Self-explanatory.
    round_toward_zero = 0, ///< Self-explanatory.
    round_to_nearest = 1, ///< To the nearest representable value.
    round_toward_infinity = 2, ///< Self-explanatory.
    round_toward_neg_infinity = 3 ///< Self-explanatory.
  };
#pragma empty_line
  /**
   *  @brief Describes the denormalization for floating-point types.
   *
   *  These values represent the presence or absence of a variable number
   *  of exponent bits.  This type is used in the std::numeric_limits class.
  */
  enum float_denorm_style
  {
    /// Indeterminate at compile time whether denormalized values are allowed.
    denorm_indeterminate = -1,
    /// The type does not allow denormalized values.
    denorm_absent = 0,
    /// The type allows denormalized values.
    denorm_present = 1
  };
#pragma empty_line
  /**
   *  @brief Part of std::numeric_limits.
   *
   *  The @c static @c const members are usable as integral constant
   *  expressions.
   *
   *  @note This is a seperate class for purposes of efficiency; you
   *        should only access these members as part of an instantiation
   *        of the std::numeric_limits class.
  */
  struct __numeric_limits_base
  {
    /** This will be true for all fundamental types (which have
        specializations), and false for everything else.  */
    static const bool is_specialized = false;
#pragma empty_line
    /** The number of @c radix digits that be represented without change:  for
        integer types, the number of non-sign bits in the mantissa; for
        floating types, the number of @c radix digits in the mantissa.  */
    static const int digits = 0;
    /** The number of base 10 digits that can be represented without change. */
    static const int digits10 = 0;
    /** True if the type is signed.  */
    static const bool is_signed = false;
    /** True if the type is integer.
     *  @if maint
     *  Is this supposed to be "if the type is integral"?
     *  @endif
    */
    static const bool is_integer = false;
    /** True if the type uses an exact representation.  "All integer types are
        exact, but not all exact types are integer.  For example, rational and
        fixed-exponent representations are exact but not integer."
        [18.2.1.2]/15  */
    static const bool is_exact = false;
    /** For integer types, specifies the base of the representation.  For
        floating types, specifies the base of the exponent representation.  */
    static const int radix = 0;
#pragma empty_line
    /** The minimum negative integer such that @c radix raised to the power of
        (one less than that integer) is a normalized floating point number.  */
    static const int min_exponent = 0;
    /** The minimum negative integer such that 10 raised to that power is in
        the range of normalized floating point numbers.  */
    static const int min_exponent10 = 0;
    /** The maximum positive integer such that @c radix raised to the power of
        (one less than that integer) is a representable finite floating point
	number.  */
    static const int max_exponent = 0;
    /** The maximum positive integer such that 10 raised to that power is in
        the range of representable finite floating point numbers.  */
    static const int max_exponent10 = 0;
#pragma empty_line
    /** True if the type has a representation for positive infinity.  */
    static const bool has_infinity = false;
    /** True if the type has a representation for a quiet (non-signaling)
        "Not a Number."  */
    static const bool has_quiet_NaN = false;
    /** True if the type has a representation for a signaling
        "Not a Number."  */
    static const bool has_signaling_NaN = false;
    /** See std::float_denorm_style for more information.  */
    static const float_denorm_style has_denorm = denorm_absent;
    /** "True if loss of accuracy is detected as a denormalization loss,
        rather than as an inexact result." [18.2.1.2]/42  */
    static const bool has_denorm_loss = false;
#pragma empty_line
    /** True if-and-only-if the type adheres to the IEC 559 standard, also
        known as IEEE 754.  (Only makes sense for floating point types.)  */
    static const bool is_iec559 = false;
    /** "True if the set of values representable by the type is finite.   All
        built-in types are bounded, this member would be false for arbitrary
	precision types." [18.2.1.2]/54  */
    static const bool is_bounded = false;
    /** True if the type is @e modulo, that is, if it is possible to add two
        positive numbers and have a result that wraps around to a third number
        that is less.  Typically false for floating types, true for unsigned
        integers, and true for signed integers.  */
    static const bool is_modulo = false;
#pragma empty_line
    /** True if trapping is implemented for this type.  */
    static const bool traps = false;
    /** True if tinyness is detected before rounding.  (see IEC 559)  */
    static const bool tinyness_before = false;
    /** See std::float_round_style for more information.  This is only
        meaningful for floating types; integer types will all be
	round_toward_zero.  */
    static const float_round_style round_style = round_toward_zero;
  };
#pragma empty_line
  /**
   *  @brief Properties of fundamental types.
   *
   *  This class allows a program to obtain information about the
   *  representation of a fundamental type on a given platform.  For
   *  non-fundamental types, the functions will return 0 and the data
   *  members will all be @c false.
   *
   *  @if maint
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS:  DRs 201 and 184 (hi Gaby!) are
   *  noted, but not incorporated in this documented (yet).
   *  @endif
  */
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      /** The minimum finite value, or for floating types with
          denormalization, the minimum positive normalized value.  */
      static _Tp min() throw() { return static_cast<_Tp>(0); }
      /** The maximum finite value.  */
      static _Tp max() throw() { return static_cast<_Tp>(0); }
      /** The @e machine @e epsilon:  the difference between 1 and the least
          value greater than 1 that is representable.  */
      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
      /** The maximum rounding error measurement (see LIA-1).  */
      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
      /** The representation of positive infinity, if @c has_infinity.  */
      static _Tp infinity() throw() { return static_cast<_Tp>(0); }
      /** The representation of a quiet "Not a Number," if @c has_quiet_NaN. */
      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
      /** The representation of a signaling "Not a Number," if
          @c has_signaling_NaN. */
      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
      /** The minimum positive denormalized value.  For types where
          @c has_denorm is false, this is the minimum positive normalized
	  value.  */
      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };
#pragma empty_line
  // Now there follow 15 explicit specializations.  Yes, 15.  Make sure
  // you get the count right.
#pragma empty_line
  /// numeric_limits<bool> specialization.
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }
#pragma empty_line
      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      // It is not clear what it means for a boolean type to trap.
      // This is a DR on the LWG issue list.  Here, I use integer
      // promotion semantics.
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<char> specialization.
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }
#pragma empty_line
      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<signed char> specialization.
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }
#pragma empty_line
      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<unsigned char> specialization.
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }
#pragma empty_line
      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<wchar_t> specialization.
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }
#pragma empty_line
      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<short> specialization.
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }
#pragma empty_line
      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<unsigned short> specialization.
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }
#pragma empty_line
      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<int> specialization.
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }
#pragma empty_line
      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<unsigned int> specialization.
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }
#pragma empty_line
      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<long> specialization.
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }
#pragma empty_line
      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<unsigned long> specialization.
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }
#pragma empty_line
      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<long long> specialization.
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }
#pragma empty_line
      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<unsigned long long> specialization.
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }
#pragma empty_line
      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
#pragma empty_line
  /// numeric_limits<float> specialization.
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }
#pragma empty_line
      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }
#pragma empty_line
      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /// numeric_limits<double> specialization.
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }
#pragma empty_line
      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }
#pragma empty_line
      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /// numeric_limits<long double> specialization.
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }
#pragma empty_line
      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }
#pragma empty_line
      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;
#pragma empty_line
      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 61 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function.  The unused second parameter exists to
   *  permit the real get_temporary_buffer to use template parameter deduction.
   *
   *  XXX This should perhaps use the pool.
   *  @endif
   */
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;
#pragma empty_line
      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
#pragma empty_line
  /**
   *  @brief Allocates a temporary buffer.
   *  @param  len  The number of objects of type Tp.
   *  @return See full description.
   *
   *  Reinventing the wheel, but this time with prettier spokes!
   *
   *  This function tries to obtain storage for @c len adjacent Tp
   *  objects.  The objects themselves are not constructed, of course.
   *  A pair<> is returned containing "the buffer s address and
   *  capacity (in the units of sizeof(Tp)), or a pair of 0 values if
   *  no storage can be obtained."  Note that the capacity obtained
   *  may be less than that requested if the memory is unavailable;
   *  you should compare len with the .second return value.
   *
   * Provides the nothrow exception guarantee.
   */
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
#pragma empty_line
  /**
   *  @brief The companion to get_temporary_buffer().
   *  @param  p  A buffer previously allocated by get_temporary_buffer.
   *  @return   None.
   *
   *  Frees the memory pointed to by p.
   */
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
#pragma empty_line
  /**
   *  A wrapper class to provide auto_ptr with reference semantics.
   *  For example, an auto_ptr can be assigned (or constructed from)
   *  the result of a function which returns an auto_ptr by value.
   *
   *  All the auto_ptr_ref stuff should happen behind the scenes.
   */
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;
#pragma empty_line
      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  A simple smart pointer providing strict ownership semantics.
   *
   *  The Standard says:
   *  <pre>
   *  An @c auto_ptr owns the object it holds a pointer to.  Copying
   *  an @c auto_ptr copies the pointer and transfers ownership to the
   *  destination.  If more than one @c auto_ptr owns the same object
   *  at the same time the behavior of the program is undefined.
   *
   *  The uses of @c auto_ptr include providing temporary
   *  exception-safety for dynamically allocated memory, passing
   *  ownership of dynamically allocated memory to a function, and
   *  returning dynamically allocated memory from a function.  @c
   *  auto_ptr does not meet the CopyConstructible and Assignable
   *  requirements for Standard Library <a
   *  href="tables.html#65">container</a> elements and thus
   *  instantiating a Standard Library container with an @c auto_ptr
   *  results in undefined behavior.
   *  </pre>
   *  Quoted from [20.4.5]/3.
   *
   *  Good examples of what can and cannot be done with auto_ptr can
   *  be found in the libstdc++ testsuite.
   *
   *  @if maint
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  127.  auto_ptr<> conversion issues
   *  These resolutions have all been incorporated.
   *  @endif
   */
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;
#pragma empty_line
    public:
      /// The pointed-to type.
      typedef _Tp element_type;
#pragma empty_line
      /**
       *  @brief  An %auto_ptr is usually constructed from a raw pointer.
       *  @param  p  A pointer (defaults to NULL).
       *
       *  This object now @e owns the object pointed to by @a p.
       */
      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
#pragma empty_line
      /**
       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.
       *  @param  a  Another %auto_ptr of the same type.
       *
       *  This object now @e owns the object previously owned by @a a,
       *  which has given up ownsership.
       */
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
#pragma empty_line
      /**
       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.
       *  @param  a  Another %auto_ptr of a different but related type.
       *
       *  A pointer-to-Tp1 must be convertible to a
       *  pointer-to-Tp/element_type.
       *
       *  This object now @e owns the object previously owned by @a a,
       *  which has given up ownsership.
       */
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
#pragma empty_line
      /**
       *  @brief  %auto_ptr assignment operator.
       *  @param  a  Another %auto_ptr of the same type.
       *
       *  This object now @e owns the object previously owned by @a a,
       *  which has given up ownsership.  The object that this one @e
       *  used to own and track has been deleted.
       */
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
#pragma empty_line
      /**
       *  @brief  %auto_ptr assignment operator.
       *  @param  a  Another %auto_ptr of a different but related type.
       *
       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.
       *
       *  This object now @e owns the object previously owned by @a a,
       *  which has given up ownsership.  The object that this one @e
       *  used to own and track has been deleted.
       */
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
#pragma empty_line
      /**
       *  When the %auto_ptr goes out of scope, the object it owns is
       *  deleted.  If it no longer owns anything (i.e., @c get() is
       *  @c NULL), then this has no effect.
       *
       *  @if maint
       *  The C++ standard says there is supposed to be an empty throw
       *  specification here, but omitting it is standard conforming.  Its
       *  presence can be detected only if _Tp::~_Tp() throws, but this is
       *  prohibited.  [17.4.3.6]/2
       *  @endif
       */
      ~auto_ptr() { delete _M_ptr; }
#pragma empty_line
      /**
       *  @brief  Smart pointer dereferencing.
       *
       *  If this %auto_ptr no longer owns anything, then this
       *  operation will crash.  (For a smart pointer, "no longer owns
       *  anything" is the same as being a null pointer, and you know
       *  what happens when you dereference one of those...)
       */
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }
#pragma empty_line
      /**
       *  @brief  Smart pointer dereferencing.
       *
       *  This returns the pointer itself, which the language then will
       *  automatically cause to be dereferenced.
       */
      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
#pragma empty_line
      /**
       *  @brief  Bypassing the smart pointer.
       *  @return  The raw pointer being managed.
       *
       *  You can get a copy of the pointer that this object owns, for
       *  situations such as passing to a function which only accepts
       *  a raw pointer.
       *
       *  @note  This %auto_ptr still owns the memory.
       */
      element_type*
      get() const throw() { return _M_ptr; }
#pragma empty_line
      /**
       *  @brief  Bypassing the smart pointer.
       *  @return  The raw pointer being managed.
       *
       *  You can get a copy of the pointer that this object owns, for
       *  situations such as passing to a function which only accepts
       *  a raw pointer.
       *
       *  @note  This %auto_ptr no longer owns the memory.  When this object
       *  goes out of scope, nothing will happen.
       */
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
#pragma empty_line
      /**
       *  @brief  Forcibly deletes the managed object.
       *  @param  p  A pointer (defaults to NULL).
       *
       *  This object now @e owns the object pointed to by @a p.  The
       *  previous object has been deleted.
       */
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
#pragma empty_line
      /** 
       *  @brief  Automatic conversions
       *
       *  These operations convert an %auto_ptr into and from an auto_ptr_ref
       *  automatically as needed.  This allows constructs such as
       *  @code
       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);
       *    ...
       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);
       *  @endcode
       */
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }
#pragma empty_line
      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }
#pragma empty_line
      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }
#pragma empty_line
      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };
#pragma empty_line
}
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream_insert.h" 1 3
// Helpers for ostream inserters -*- C++ -*-
#pragma empty_line
// Copyright (C) 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ostream_insert.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 39 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream_insert.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 41 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream_insert.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB:  This syntax is a GNU extension.
#pragma empty_line
  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);
#pragma empty_line
#pragma empty_line
  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_iterator.h" 1 3
// Iterators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 */
#pragma line 53 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_function.h" 1 3
// Functor implementations -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_function.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std {
#pragma empty_line
  // 20.3.1 base classes
  /** @defgroup s20_3_1_base Functor Base Classes
   *  Function objects, or @e functors, are objects with an @c operator()
   *  defined and accessible.  They can be passed as arguments to algorithm
   *  templates and used in place of a function pointer.  Not only is the
   *  resulting expressiveness of the library increased, but the generated
   *  code can be more efficient than what you might write by hand.  When we
   *  refer to "functors," then, generally we include function pointers in
   *  the description as well.
   *
   *  Often, functors are only created as temporaries passed to algorithm
   *  calls, rather than being created as named variables.
   *
   *  Two examples taken from the standard itself follow.  To perform a
   *  by-element addition of two vectors @c a and @c b containing @c double,
   *  and put the result in @c a, use
   *  \code
   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
   *  \endcode
   *  To negate every element in @c a, use
   *  \code
   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
   *  \endcode
   *  The addition and negation functions will be inlined directly.
   *
   *  The standard functors are derived from structs named @c unary_function
   *  and @c binary_function.  These two classes contain nothing but typedefs,
   *  to aid in generic (template) programming.  If you write your own
   *  functors, you might consider doing the same.
   *
   *  @{
   */
  /**
   *  This is one of the @link s20_3_1_base functor base classes@endlink.
   */
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type; ///< @c argument_type is the type of the
                                    ///     argument (no surprises here)
#pragma empty_line
      typedef _Result result_type; ///< @c result_type is the return type
    };
#pragma empty_line
  /**
   *  This is one of the @link s20_3_1_base functor base classes@endlink.
   */
  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type; ///< the type of the first argument
                                           ///  (no surprises here)
#pragma empty_line
      typedef _Arg2 second_argument_type; ///< the type of the second argument
      typedef _Result result_type; ///< type of the return type
    };
  /** @}  */
#pragma empty_line
  // 20.3.2 arithmetic
  /** @defgroup s20_3_2_arithmetic Arithmetic Classes
   *  Because basic math often needs to be done during an algorithm, the library
   *  provides functors for those operations.  See the documentation for
   *  @link s20_3_1_base the base classes@endlink for examples of their use.
   *
   *  @{
   */
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_2_arithmetic math functors@endlink.
  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
  /** @}  */
#pragma empty_line
  // 20.3.3 comparisons
  /** @defgroup s20_3_3_comparisons Comparison Classes
   *  The library provides six wrapper functors for all the basic comparisons
   *  in C++, like @c <.
   *
   *  @{
   */
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
  /** @}  */
#pragma empty_line
  // 20.3.4 logical operations
  /** @defgroup s20_3_4_logical Boolean Operations Classes
   *  Here are wrapper functors for Boolean operations:  @c &&, @c ||, and @c !.
   *
   *  @{
   */
  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };
#pragma empty_line
  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
  /** @}  */
#pragma empty_line
  // 20.3.5 negators
  /** @defgroup s20_3_5_negators Negators
   *  The functions @c not1 and @c not2 each take a predicate functor
   *  and return an instance of @c unary_negate or
   *  @c binary_negate, respectively.  These classes are functors whose
   *  @c operator() performs the stored predicate function and then returns
   *  the negation of the result.
   *
   *  For example, given a vector of integers and a trivial predicate,
   *  \code
   *  struct IntGreaterThanThree
   *    : public std::unary_function<int, bool>
   *  {
   *      bool operator() (int x) { return x > 3; }
   *  };
   *
   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
   *  \endcode
   *  The call to @c find_if will locate the first index (i) of @c v for which
   *  "!(v[i] > 3)" is true.
   *
   *  The not1/unary_negate combination works on predicates taking a single
   *  argument.  The not2/binary_negate combination works on predicates which
   *  take two arguments.
   *
   *  @{
   */
  /// One of the @link s20_3_5_negators negation functors@endlink.
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}
#pragma empty_line
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };
#pragma empty_line
  /// One of the @link s20_3_5_negators negation functors@endlink.
  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }
#pragma empty_line
  /// One of the @link s20_3_5_negators negation functors@endlink.
  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }
#pragma empty_line
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };
#pragma empty_line
  /// One of the @link s20_3_5_negators negation functors@endlink.
  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  /** @}  */
#pragma empty_line
  // 20.3.6 binders
  /** @defgroup s20_3_6_binder Binder Classes
   *  Binders turn functions/functors with two arguments into functors with
   *  a single argument, storing an argument to be applied later.  For
   *  example, a variable @c B of type @c binder1st is constructed from a
   *  functor @c f and an argument @c x.  Later, B's @c operator() is called
   *  with a single argument @c y.  The return value is the value of @c f(x,y).
   *  @c B can be "called" with various arguments (y1, y2, ...) and will in
   *  turn call @c f(x,y1), @c f(x,y2), ...
   *
   *  The function @c bind1st is provided to save some typing.  It takes the
   *  function and an argument as parameters, and returns an instance of
   *  @c binder1st.
   *
   *  The type @c binder2nd and its creator function @c bind2nd do the same
   *  thing, but the stored argument is passed as the second parameter instead
   *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a
   *  functor whose @c operator() accepts a floating-point number, subtracts
   *  1.3 from it, and returns the result.  (If @c bind1st had been used,
   *  the functor would perform "1.3 - x" instead.
   *
   *  Creator-wrapper functions like @c bind1st are intended to be used in
   *  calling algorithms.  Their return values will be temporary objects.
   *  (The goal is to not require you to type names like
   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the
   *  return value from @c bind1st(std::plus<int>,5).
   *
   *  These become more useful when combined with the composition functions.
   *
   *  @{
   */
  /// One of the @link s20_3_6_binder binder functors@endlink.
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}
#pragma empty_line
      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };
#pragma empty_line
  /// One of the @link s20_3_6_binder binder functors@endlink.
  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
#pragma empty_line
  /// One of the @link s20_3_6_binder binder functors@endlink.
  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}
#pragma empty_line
      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };
#pragma empty_line
  /// One of the @link s20_3_6_binder binder functors@endlink.
  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
  /** @}  */
#pragma empty_line
  // 20.3.7 adaptors pointers functions
  /** @defgroup s20_3_7_adaptors Adaptors for pointers to functions
   *  The advantage of function objects over pointers to functions is that
   *  the objects in the standard library declare nested typedefs describing
   *  their argument and result types with uniform names (e.g., @c result_type
   *  from the base classes @c unary_function and @c binary_function).
   *  Sometimes those typedefs are required, not just optional.
   *
   *  Adaptors are provided to turn pointers to unary (single-argument) and
   *  binary (double-argument) functions into function objects.  The
   *  long-winded functor @c pointer_to_unary_function is constructed with a
   *  function pointer @c f, and its @c operator() called with argument @c x
   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
   *  thing, but with a double-argument @c f and @c operator().
   *
   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
   *  an instance of the appropriate functor.
   *
   *  @{
   */
  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}
#pragma empty_line
      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}
#pragma empty_line
      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };
#pragma empty_line
  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }
#pragma empty_line
  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}
#pragma empty_line
      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
#pragma empty_line
      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };
#pragma empty_line
  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
  /** @}  */
#pragma empty_line
  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }
#pragma empty_line
      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };
#pragma empty_line
  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }
#pragma empty_line
      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };
#pragma empty_line
  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }
#pragma empty_line
      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
#pragma empty_line
  // 20.3.8 adaptors pointers members
  /** @defgroup s20_3_8_memadaptors Adaptors for pointers to members
   *  There are a total of 8 = 2^3 function objects in this family.
   *   (1) Member functions taking no arguments vs member functions taking
   *        one argument.
   *   (2) Call through pointer vs call through reference.
   *   (3) Const vs non-const member function.
   *
   *  All of this complexity is in the function objects themselves.  You can
   *   ignore it by using the helper function mem_fun and mem_fun_ref,
   *   which create whichever type of adaptor is appropriate.
   *
   *  @{
   */
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
#pragma empty_line
  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}
#pragma empty_line
      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
#pragma empty_line
  // Mem_fun adaptor helper functions.  There are only two:
  // mem_fun and mem_fun_ref.
  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  /** @}  */
#pragma empty_line
}
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.h" 1 3
// Components for manipulating sequences of characters -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file basic_string.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21 Strings library
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 1 3
// Support for atomic operations -*- C++ -*-
#pragma empty_line
// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file atomicity.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup Containers
   *  @ingroup Sequences
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and array access are supported.
   *
   *  @doctodo
   *
   *
   *  @if maint
   *  Documentation?  What's that?
   *  Nathan Myers <ncm@cantrip.org>.
   *
   *  A string looks like this:
   *
   *  @code
   *                                        [_Rep]
   *                                        _M_length
   *   [basic_string<char_type>]            _M_capacity
   *   _M_dataplus                          _M_refcount
   *   _M_p ---------------->               unnamed array of char_type
   *  @endcode
   *
   *  Where the _M_p points to the first character in the string, and
   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
   *  pointer to the header.
   *
   *  This approach has the enormous advantage that a string object
   *  requires only one allocation.  All the ugliness is confined
   *  within a single pair of inline functions, which each compile to
   *  a single "add" instruction: _Rep::_M_data(), and
   *  string::_M_rep(); and the allocation function which gets a
   *  block of raw bytes and with room enough and constructs a _Rep
   *  object at the front.
   *
   *  The reason you want _M_data pointing to the character array and
   *  not the _Rep is so that the debugger can see the string
   *  contents. (Probably we should add a non-inline member to get
   *  the _Rep for the debugger to use, so users can check the actual
   *  string length.)
   *
   *  Note that the _Rep object is a POD so that you can have a
   *  static "empty string" _Rep object already "constructed" before
   *  static constructors have run.  The reference-count encoding is
   *  chosen so that a 0 indicates one reference, so you never try to
   *  destroy the empty-string _Rep object.
   *
   *  All but the last paragraph is considered pretty conventional
   *  for a C++ string implementation.
   *  @endif
  */
  // 21.3  Template class basic_string
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
#pragma empty_line
      // Types:
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
#pragma empty_line
    private:
      // _Rep: string representation
      //   Invariants:
      //   1. String really contains _M_length + 1 characters: due to 21.3.4
      //      must be kept null-terminated.
      //   2. _M_capacity >= _M_length
      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
      //   3. _M_refcount has three states:
      //      -1: leaked, one reference, no ref-copies allowed, non-const.
      //       0: one reference, non-const.
      //     n>0: n + 1 references, operations require a lock, const.
      //   4. All fields==0 is an empty string, given the extra storage
      //      beyond-the-end for a null terminator; thus, the shared
      //      empty string representation needs no constructor.
#pragma empty_line
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };
#pragma empty_line
      struct _Rep : _Rep_base
      {
 // Types:
 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
#pragma empty_line
 // (Public) Data members:
#pragma empty_line
 // The maximum number of individual char_type elements of an
 // individual string is determined by _S_max_size. This is the
 // value that will be returned by max_size().  (Whereas npos
 // is the maximum number of bytes the allocator can allocate.)
 // If one was to divvy up the theoretical largest size string,
 // with a terminating character and m _CharT elements, it'd
 // look like this:
 // npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
 // Solving for m:
 // m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
 // In addition, this implementation quarters this amount.
 static const size_type _S_max_size;
 static const _CharT _S_terminal;
#pragma empty_line
 // The following storage is init'd to 0 by the linker, resulting
        // (carefully) in an empty string with one reference.
        static size_type _S_empty_rep_storage[];
#pragma empty_line
        static _Rep&
        _S_empty_rep()
        {
   // NB: Mild hack to avoid strict-aliasing warnings.  Note that
   // _S_empty_rep_storage is never modified and the punning should
   // be reasonably safe in this case.
   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }
#pragma empty_line
        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }
#pragma empty_line
        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }
#pragma empty_line
        void
 _M_set_leaked()
        { this->_M_refcount = -1; }
#pragma empty_line
        void
 _M_set_sharable()
        { this->_M_refcount = 0; }
#pragma empty_line
 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable(); // One reference.
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);
   // grrr. (per 21.3.4)
   // You cannot leave those LWG people alone for a second.
 }
#pragma empty_line
 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }
#pragma empty_line
 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }
#pragma empty_line
 // Create & Destroy
 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);
#pragma empty_line
 void
 _M_dispose(const _Alloc& __a)
 {
#pragma empty_line
   if (__builtin_expect(this != &_S_empty_rep(), false))
#pragma empty_line
     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 } // XXX MT
#pragma empty_line
 void
 _M_destroy(const _Alloc&) throw();
#pragma empty_line
 _CharT*
 _M_refcopy() throw()
 {
#pragma empty_line
   if (__builtin_expect(this != &_S_empty_rep(), false))
#pragma empty_line
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 } // XXX MT
#pragma empty_line
 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };
#pragma empty_line
      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }
#pragma empty_line
 _CharT* _M_p; // The actual data.
      };
#pragma empty_line
    public:
      // Data Members (public):
      // NB: This is an unsigned type, and thus represents the maximum
      // size that the allocator can hold.
      ///  Value returned by various member functions when they fail.
      static const size_type npos = static_cast<size_type>(-1);
#pragma empty_line
    private:
      // Data Members (private):
      mutable _Alloc_hider _M_dataplus;
#pragma empty_line
      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }
#pragma empty_line
      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }
#pragma empty_line
      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
#pragma empty_line
      // For the internal use we have functions similar to `begin'/`end'
      // but they do not call _M_leak.
      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }
#pragma empty_line
      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }
#pragma empty_line
      void
      _M_leak() // for use in begin() & non-const op[]
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }
#pragma empty_line
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }
#pragma empty_line
      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }
#pragma empty_line
      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }
#pragma empty_line
      // True if _Rep and source do not overlap.
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }
#pragma empty_line
      // When __n = 1 way faster than the general multichar
      // traits_type::copy/move/assign.
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }
#pragma empty_line
      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }
#pragma empty_line
      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }
#pragma empty_line
      // _S_copy_chars is a separate template to permit specialization
      // to optimize for the common case of pointers as iterators.
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1); // These types are off.
 }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
#pragma empty_line
      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
#pragma empty_line
      void
      _M_leak_hard();
#pragma empty_line
      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }
#pragma empty_line
    public:
      // Construct/copy/destroy:
      // NB: We overload ctors in some cases instead of using default
      // arguments, per 17.4.4.4 para. 2 item 2.
#pragma empty_line
      /**
       *  @brief  Default constructor creates an empty string.
       */
      inline
      basic_string();
#pragma empty_line
      /**
       *  @brief  Construct an empty string using allocator @a a.
       */
      explicit
      basic_string(const _Alloc& __a);
#pragma empty_line
      // NB: per LWG issue 42, semantics different from IS:
      /**
       *  @brief  Construct string with copy of value of @a str.
       *  @param  str  Source string.
       */
      basic_string(const basic_string& __str);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  str  Source string.
       *  @param  pos  Index of first character to copy from.
       *  @param  n  Number of characters to copy (default remainder).
       */
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  str  Source string.
       *  @param  pos  Index of first character to copy from.
       *  @param  n  Number of characters to copy.
       *  @param  a  Allocator to use.
       */
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
#pragma empty_line
      /**
       *  @brief  Construct string initialized by a character array.
       *  @param  s  Source character array.
       *  @param  n  Number of characters to copy.
       *  @param  a  Allocator to use (default is default allocator).
       *
       *  NB: @a s must have at least @a n characters, '\0' has no special
       *  meaning.
       */
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as copy of a C string.
       *  @param  s  Source C string.
       *  @param  a  Allocator to use (default is default allocator).
       */
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as multiple characters.
       *  @param  n  Number of characters.
       *  @param  c  Character to use.
       *  @param  a  Allocator to use (default is default allocator).
       */
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
#pragma empty_line
      /**
       *  @brief  Construct string as copy of a range.
       *  @param  beg  Start of range.
       *  @param  end  End of range.
       *  @param  a  Allocator to use (default is default allocator).
       */
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());
#pragma empty_line
      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }
#pragma empty_line
      /**
       *  @brief  Assign the value of @a str to this string.
       *  @param  str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }
#pragma empty_line
      /**
       *  @brief  Copy contents of @a s into this string.
       *  @param  s  Source null-terminated string.
       */
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
#pragma empty_line
      /**
       *  @brief  Set value to string of length 1.
       *  @param  c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       */
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
#pragma empty_line
      // Iterators:
      /**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.  Unshares the string.
       */
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }
#pragma empty_line
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      begin() const
      { return const_iterator(_M_data()); }
#pragma empty_line
      /**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.  Unshares the string.
       */
      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }
#pragma empty_line
      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }
#pragma empty_line
      /**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.  Unshares the string.
       */
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }
#pragma empty_line
      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }
#pragma empty_line
      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.  Unshares the string.
       */
      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }
#pragma empty_line
      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
#pragma empty_line
    public:
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const
      { return _M_rep()->_M_length; }
#pragma empty_line
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const
      { return _M_rep()->_M_length; }
#pragma empty_line
      /// Returns the size() of the largest possible %string.
      size_type
      max_size() const
      { return _Rep::_S_max_size; }
#pragma empty_line
      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  n  Number of characters the %string should contain.
       *  @param  c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are set to @a c.
       */
      void
      resize(size_type __n, _CharT __c);
#pragma empty_line
      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       */
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
#pragma empty_line
      /**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       */
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
#pragma empty_line
      /**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  res_arg  Number of characters required.
       *  @throw  std::length_error  If @a res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       */
      void
      reserve(size_type __res_arg = 0);
#pragma empty_line
      /**
       *  Erases the string, making it empty.
       */
      void
      clear()
      { _M_mutate(0, this->size(), 0); }
#pragma empty_line
      /**
       *  Returns true if the %string is empty.  Equivalent to *this == "".
       */
      bool
      empty() const
      { return this->size() == 0; }
#pragma empty_line
      // Element access:
      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
#pragma empty_line
      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)  Unshares the string.
       */
      reference
      operator[](size_type __pos)
      {
        // allow pos == size() as v3 extension:
 ;
        // but be strict in pedantic mode:
 ;
 _M_leak();
 return _M_data()[__pos];
      }
#pragma empty_line
      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
#pragma empty_line
      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.  Success results in
       *  unsharing the string.
       */
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
#pragma empty_line
      // Modifiers:
      /**
       *  @brief  Append a string to this string.
       *  @param str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }
#pragma empty_line
      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }
#pragma empty_line
      /**
       *  @brief  Append a character.
       *  @param c  The character to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
#pragma empty_line
      /**
       *  @brief  Append a string to this string.
       *  @param str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const basic_string& __str);
#pragma empty_line
      /**
       *  @brief  Append a substring.
       *  @param str  The string to append.
       *  @param pos  Index of the first character of str to append.
       *  @param n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function appends @a n characters from @a str starting at @a pos
       *  to this string.  If @a n is is larger than the number of available
       *  characters in @a str, the remainder of @a str is appended.
       */
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);
#pragma empty_line
      /**
       *  @brief  Append a C substring.
       *  @param s  The C string to append.
       *  @param n  The number of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s, size_type __n);
#pragma empty_line
      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Append multiple characters.
       *  @param n  The number of characters to append.
       *  @param c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends n copies of c to this string.
       */
      basic_string&
      append(size_type __n, _CharT __c);
#pragma empty_line
      /**
       *  @brief  Append a range of characters.
       *  @param first  Iterator referencing the first character to append.
       *  @param last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [first,last) to this string.
       */
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
#pragma empty_line
      /**
       *  @brief  Append a single character.
       *  @param c  Character to append.
       */
      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }
#pragma empty_line
      /**
       *  @brief  Set value to contents of another string.
       *  @param  str  Source string to use.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(const basic_string& __str);
#pragma empty_line
      /**
       *  @brief  Set value to a substring of a string.
       *  @param str  The string to use.
       *  @param pos  Index of the first character of str.
       *  @param n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a str consisting
       *  of @a n characters at @a pos.  If @a n is is larger than the number
       *  of available characters in @a str, the remainder of @a str is used.
       */
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
#pragma empty_line
      /**
       *  @brief  Set value to a C substring.
       *  @param s  The C string to use.
       *  @param n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a n
       *  characters of @a s.  If @a n is is larger than the number of
       *  available characters in @a s, the remainder of @a s is used.
       */
      basic_string&
      assign(const _CharT* __s, size_type __n);
#pragma empty_line
      /**
       *  @brief  Set value to contents of a C string.
       *  @param s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a s.
       *  The data is copied, so there is no dependence on @a s once the
       *  function returns.
       */
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Set value to multiple characters.
       *  @param n  Length of the resulting string.
       *  @param c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a n copies of
       *  character @a c.
       */
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
#pragma empty_line
      /**
       *  @brief  Set value to a range of characters.
       *  @param first  Iterator referencing the first character to append.
       *  @param last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [first,last).
      */
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
#pragma empty_line
      /**
       *  @brief  Insert multiple characters.
       *  @param p  Iterator referencing location in string to insert at.
       *  @param n  Number of characters to insert
       *  @param c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a n copies of character @a c starting at the position
       *  referenced by iterator @a p.  If adding characters causes the length
       *  to exceed max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
#pragma empty_line
      /**
       *  @brief  Insert a range of characters.
       *  @param p  Iterator referencing location in string to insert at.
       *  @param beg  Start of range.
       *  @param end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [beg,end).  If adding characters causes
       *  the length to exceed max_size(), length_error is thrown.  The value
       *  of the string doesn't change if an error is thrown.
      */
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
#pragma empty_line
      /**
       *  @brief  Insert value of a string.
       *  @param pos1  Iterator referencing location in string to insert at.
       *  @param str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a str starting at @a pos1.  If adding characters
       *  causes the length to exceed max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
#pragma empty_line
      /**
       *  @brief  Insert a substring.
       *  @param pos1  Iterator referencing location in string to insert at.
       *  @param str  The string to insert.
       *  @param pos2  Start of characters in str to insert.
       *  @param n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a n character of @a str beginning with
       *  @a pos2.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a pos1 is beyond the end of
       *  this string or @a pos2 is beyond the end of @a str, out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
#pragma empty_line
      /**
       *  @brief  Insert a C substring.
       *  @param pos  Iterator referencing location in string to insert at.
       *  @param s  The C string to insert.
       *  @param n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a s starting at @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
#pragma empty_line
      /**
       *  @brief  Insert a C string.
       *  @param pos  Iterator referencing location in string to insert at.
       *  @param s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a s starting at @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Insert multiple characters.
       *  @param pos  Index in string to insert at.
       *  @param n  Number of characters to insert
       *  @param c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts @a n copies of character @a c starting at index @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos > length(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
#pragma empty_line
      /**
       *  @brief  Insert one character.
       *  @param p  Iterator referencing position in string to insert at.
       *  @param c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a c at position referenced by @a p.  If adding
       *  character causes the length to exceed max_size(), length_error is
       *  thrown.  If @a p is beyond end of string, out_of_range is thrown.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#pragma empty_line
      /**
       *  @brief  Remove characters.
       *  @param pos  Index of first character to remove (default 0).
       *  @param n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a n characters from this string starting at @a pos.  The
       *  length of the string is reduced by @a n.  If there are < @a n
       *  characters to remove, the remainder of the string is truncated.  If
       *  @a p is beyond end of string, out_of_range is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
#pragma empty_line
      /**
       *  @brief  Remove one character.
       *  @param position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a position from this string. The value
       *  of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __position)
      {
 ;
#pragma empty_line
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#pragma empty_line
      /**
       *  @brief  Remove a range of characters.
       *  @param first  Iterator referencing the first character to remove.
       *  @param last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __first, iterator __last)
      {
 ;
#pragma empty_line
        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#pragma empty_line
      /**
       *  @brief  Replace characters with value from another string.
       *  @param pos  Index of first character to replace.
       *  @param n  Number of characters to be replaced.
       *  @param str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos+n) from this string.
       *  In place, the value of @a str is inserted.  If @a pos is beyond end
       *  of string, out_of_range is thrown.  If the length of the result
       *  exceeds max_size(), length_error is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
#pragma empty_line
      /**
       *  @brief  Replace characters with value from another string.
       *  @param pos1  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param str  String to insert.
       *  @param pos2  Index of first character of str to use.
       *  @param n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >
       *  str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos1,pos1 + n) from this
       *  string.  In place, the value of @a str is inserted.  If @a pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
#pragma empty_line
      /**
       *  @brief  Replace characters with value of a C substring.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param s  C string to insert.
       *  @param n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, the first @a n2 characters of @a s are inserted, or all
       *  of @a s if @a n2 is too large.  If @a pos is beyond end of string,
       *  out_of_range is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
#pragma empty_line
      /**
       *  @brief  Replace characters with value of a C string.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, the first @a n characters of @a s are inserted.  If @a
       *  pos is beyond end of string, out_of_range is thrown.  If the length
       *  of result exceeds max_size(), length_error is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Replace characters with multiple characters.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param n2  Number of characters to insert.
       *  @param c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, @a n2 copies of @a c are inserted.  If @a pos is beyond
       *  end of string, out_of_range is thrown.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
#pragma empty_line
      /**
       *  @brief  Replace range of characters with string.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the value of
       *  @a str is inserted.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
#pragma empty_line
      /**
       *  @brief  Replace range of characters with C substring.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param s  C string value to insert.
       *  @param n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the first @a
       *  n characters of @a s are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;
#pragma empty_line
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
#pragma empty_line
      /**
       *  @brief  Replace range of characters with C string.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the
       *  characters of @a s are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Replace range of characters with multiple characters
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param n  Number of characters to insert.
       *  @param c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, @a n copies
       *  of @a c are inserted.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;
#pragma empty_line
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
#pragma empty_line
      /**
       *  @brief  Replace range of characters with range.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param k1  Iterator referencing start of range to insert.
       *  @param k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, characters
       *  in the range [k1,k2) are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;
#pragma empty_line
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }
#pragma empty_line
      // Specializations for the common case of pointer and iterator:
      // useful to avoid the overhead of temporary buffering in _M_replace.
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;
#pragma empty_line
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;
#pragma empty_line
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;
#pragma empty_line
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;
#pragma empty_line
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#pragma empty_line
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
#pragma empty_line
      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);
#pragma empty_line
      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);
#pragma empty_line
      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);
#pragma empty_line
      // _S_construct_aux is used to implement the 21.3.1 para 15 which
      // requires special behaviour if _InIter is an integral type
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }
#pragma empty_line
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }
#pragma empty_line
      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }
#pragma empty_line
      // For Input Iterators, used in istreambuf_iterators, etc.
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);
#pragma empty_line
      // For forward_iterators up to random_access_iterators, used for
      // string::iterator, _CharT*, etc.
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);
#pragma empty_line
      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
#pragma empty_line
    public:
#pragma empty_line
      /**
       *  @brief  Copy substring into C string.
       *  @param s  C string to copy value into.
       *  @param n  Number of characters to copy.
       *  @param pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If pos > size().
       *
       *  Copies up to @a n characters starting at @a pos into the C string @a
       *  s.  If @a pos is greater than size(), out_of_range is thrown.
      */
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
#pragma empty_line
      /**
       *  @brief  Swap contents with another string.
       *  @param s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a s in constant
       *  time.
      */
      void
      swap(basic_string& __s);
#pragma empty_line
      // String operations:
      /**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      c_str() const
      { return _M_data(); }
#pragma empty_line
      /**
       *  @brief  Return const pointer to contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      data() const
      { return _M_data(); }
#pragma empty_line
      /**
       *  @brief  Return copy of allocator used to construct this string.
      */
      allocator_type
      get_allocator() const
      { return _M_dataplus; }
#pragma empty_line
      /**
       *  @brief  Find position of a C substring.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search from.
       *  @param n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for the first @a n characters
       *  in @a s within this string.  If found, returns the index where it
       *  begins.  If not found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma empty_line
      /**
       *  @brief  Find position of a string.
       *  @param str  String to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for value of @a str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find position of a C string.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for the value of @a s within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find(_CharT __c, size_type __pos = 0) const;
#pragma empty_line
      /**
       *  @brief  Find last position of a string.
       *  @param str  String to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a pos, searches backward for value of @a str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find last position of a C substring.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search back from.
       *  @param n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a pos, searches backward for the first @a n
       *  characters in @a s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma empty_line
      /**
       *  @brief  Find last position of a C string.
       *  @param s  C string to locate.
       *  @param pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a pos, searches backward for the value of @a s within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find last position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
#pragma empty_line
      /**
       *  @brief  Find position of a character of string.
       *  @param str  String containing characters to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the characters of
       *  @a str within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find position of a character of C substring.
       *  @param s  String containing characters to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @param n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the first @a n
       *  characters of @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma empty_line
      /**
       *  @brief  Find position of a character of C string.
       *  @param s  String containing characters to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the characters of
       *  @a s within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for the character @a c within
       *  this string.  If found, returns the index where it was found.  If
       *  not found, returns npos.
       *
       *  Note: equivalent to find(c, pos).
      */
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
#pragma empty_line
      /**
       *  @brief  Find last position of a character of string.
       *  @param str  String containing characters to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the characters of
       *  @a str within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find last position of a character of C substring.
       *  @param s  C string containing characters to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @param n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the first @a n
       *  characters of @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma empty_line
      /**
       *  @brief  Find last position of a character of C string.
       *  @param s  C string containing characters to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the characters of
       *  @a s within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find last position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search back from (default 0).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
       *
       *  Note: equivalent to rfind(c, pos).
      */
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
#pragma empty_line
      /**
       *  @brief  Find position of a character not in string.
       *  @param str  String containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in @a str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find position of a character not in C substring.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @param n  Number of characters from s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in the first @a n characters of @a s within this string.  If found,
       *  returns the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
#pragma empty_line
      /**
       *  @brief  Find position of a character not in C string.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in @a s within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find position of a different character.
       *  @param c  Character to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character other than @a c
       *  within this string.  If found, returns the index where it was found.
       *  If not found, returns npos.
      */
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
#pragma empty_line
      /**
       *  @brief  Find last position of a character not in string.
       *  @param str  String containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in @a str within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
#pragma empty_line
      /**
       *  @brief  Find last position of a character not in C substring.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @param n  Number of characters from s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in the first @a n characters of @a s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      /**
       *  @brief  Find position of a character not in C string.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
#pragma empty_line
      /**
       *  @brief  Find last position of a different character.
       *  @param c  Character to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches backward for a character other than
       *  @a c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
#pragma empty_line
      /**
       *  @brief  Get a substring.
       *  @param pos  Index of first character (default 0).
       *  @param n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If pos > size().
       *
       *  Construct and return a new string using the @a n characters starting
       *  at @a pos.  If the string is too short, use the remainder of the
       *  characters.  If @a pos is beyond the end of the string, out_of_range
       *  is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
#pragma empty_line
      /**
       *  @brief  Compare to a string.
       *  @param str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a str, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a str.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and str.size().  The function
       *  then compares the two strings by calling traits::compare(data(),
       *  str.data(),rlen).  If the result of the comparison is nonzero returns
       *  it, otherwise the shorter one is ordered first.
      */
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);
#pragma empty_line
 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = __size - __osize;
 return __r;
      }
#pragma empty_line
      /**
       *  @brief  Compare substring to a string.
       *  @param pos  Index of first character of substring.
       *  @param n  Number of characters in substring.
       *  @param str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n characters starting
       *  at @a pos.  Returns an integer < 0 if the substring is ordered
       *  before @a str, 0 if their values are equivalent, or > 0 if the
       *  substring is ordered after @a str.  Determines the effective length
       *  rlen of the strings to compare as the smallest of the length of the
       *  substring and @a str.size().  The function then compares the two
       *  strings by calling traits::compare(substring.data(),str.data(),rlen).
       *  If the result of the comparison is nonzero returns it, otherwise the
       *  shorter one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
#pragma empty_line
      /**
       *  @brief  Compare substring to a substring.
       *  @param pos1  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param str  String to compare against.
       *  @param pos2  Index of first character of substring of str.
       *  @param n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos1.  Form the substring of @a str from the @a n2 characters
       *  starting at @a pos2.  Returns an integer < 0 if this substring is
       *  ordered before the substring of @a str, 0 if their values are
       *  equivalent, or > 0 if this substring is ordered after the substring
       *  of @a str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the lengths of the substrings.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it, otherwise the
       *  shorter one is ordered first.
      */
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
#pragma empty_line
      /**
       *  @brief  Compare to a C string.
       *  @param s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(const _CharT* __s) const;
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 5 String::compare specification questionable
      /**
       *  @brief  Compare substring to a C string.
       *  @param pos  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos.  Returns an integer < 0 if the substring is ordered
       *  before @a s, 0 if their values are equivalent, or > 0 if the
       *  substring is ordered after @a s.  Determines the effective length
       *  rlen of the strings to compare as the smallest of the length of the 
       *  substring and the length of a string constructed from @a s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
#pragma empty_line
      /**
       *  @brief  Compare substring against a character array.
       *  @param pos1  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param s  character array to compare against.
       *  @param n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos1.  Form a string from the first @a n2 characters of @a s.
       *  Returns an integer < 0 if this substring is ordered before the string
       *  from @a s, 0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a s.   Determines the effective
       *  length rlen of the strings to compare as the smallest of the length
       *  of the substring and @a n2.  The function then compares the two
       *  strings by calling traits::compare(substring.data(),s,rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, '\0' has no special
       *  meaning.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
#pragma empty_line
    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  // operator+
  /**
   *  @brief  Concatenate two strings.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with value of @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  /**
   *  @brief  Concatenate C string and string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with value of @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);
#pragma empty_line
  /**
   *  @brief  Concatenate character and string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
#pragma empty_line
  /**
   *  @brief  Concatenate string and C string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  /**
   *  @brief  Concatenate string and character.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
#pragma empty_line
  // operator ==
  /**
   *  @brief  Test equivalence of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }
#pragma empty_line
  /**
   *  @brief  Test equivalence of C string and string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
#pragma empty_line
  /**
   *  @brief  Test equivalence of string and C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
#pragma empty_line
  // operator !=
  /**
   *  @brief  Test difference of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }
#pragma empty_line
  /**
   *  @brief  Test difference of C string and string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }
#pragma empty_line
  /**
   *  @brief  Test difference of string and C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
#pragma empty_line
  // operator <
  /**
   *  @brief  Test if string precedes string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }
#pragma empty_line
  /**
   *  @brief  Test if string precedes C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }
#pragma empty_line
  /**
   *  @brief  Test if C string precedes string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
#pragma empty_line
  // operator >
  /**
   *  @brief  Test if string follows string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }
#pragma empty_line
  /**
   *  @brief  Test if string follows C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }
#pragma empty_line
  /**
   *  @brief  Test if C string follows string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
#pragma empty_line
  // operator <=
  /**
   *  @brief  Test if string doesn't follow string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }
#pragma empty_line
  /**
   *  @brief  Test if string doesn't follow C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }
#pragma empty_line
  /**
   *  @brief  Test if C string doesn't follow string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
#pragma empty_line
  // operator >=
  /**
   *  @brief  Test if string doesn't precede string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }
#pragma empty_line
  /**
   *  @brief  Test if string doesn't precede C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }
#pragma empty_line
  /**
   *  @brief  Test if C string doesn't precede string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
#pragma empty_line
  /**
   *  @brief  Swap contents of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *
   *  Exchanges the contents of @a lhs and @a rhs in constant time.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
#pragma empty_line
  /**
   *  @brief  Read stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a is into @a str until whitespace is found, the
   *  end of the stream is encountered, or str.max_size() is reached.  If
   *  is.width() is non-zero, that is the limit on the number of characters
   *  stored into @a str.  Any previous contents of @a str are erased.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
#pragma empty_line
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
#pragma empty_line
  /**
   *  @brief  Write string to a stream.
   *  @param os  Output stream.
   *  @param str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a str into os following the same rules as for
   *  writing a C string.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
    }
#pragma empty_line
  /**
   *  @brief  Read a line from stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @param delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a is into @a str until @a delim is found, the
   *  end of the stream is encountered, or str.max_size() is reached.  If
   *  is.width() is non-zero, that is the limit on the number of characters
   *  stored into @a str.  Any previous contents of @a str are erased.  If @a
   *  delim was encountered, it is extracted but not stored into @a str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
#pragma empty_line
  /**
   *  @brief  Read a line from stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a str until '\n' is found, the end of
   *  the stream is encountered, or str.max_size() is reached.  If is.width()
   *  is non-zero, that is the limit on the number of characters stored into
   *  @a str.  Any previous contents of @a str are erased.  If end of line was
   *  encountered, it is extracted but not stored into @a str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }
#pragma empty_line
  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);
#pragma empty_line
#pragma empty_line
}
#pragma line 55 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 1 3
// <algorithm> -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file include/algorithm
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 64 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algobase.h" 1 3
// Bits and pieces used in algorithms -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_construct.h" 1 3
// nonstandard construct and destroy functions -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_construct.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 67 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
// Raw memory manipulators -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algo.h" 1 3
// Algorithm implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_heap.h" 1 3
// Heap implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2004, 2005, 2006 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_heap.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma line 64 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_heap.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // is_heap, a predicate testing whether or not a range is
  // a heap.  This function is an extension, not part of the C++
  // standard.
  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }
#pragma empty_line
  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }
#pragma empty_line
  // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
#pragma empty_line
  /**
   *  @brief  Push an element onto a heap.
   *  @param  first  Start of heap.
   *  @param  last   End of heap + element.
   *  @ingroup heap
   *
   *  This operation pushes the element at last-1 onto the valid heap over the
   *  range [first,last-1).  After completion, [first,last) is a valid heap.
  */
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      //      __glibcxx_requires_heap(__first, __last - 1);
#pragma empty_line
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
#pragma empty_line
  /**
   *  @brief  Push an element onto a heap using comparison functor.
   *  @param  first  Start of heap.
   *  @param  last   End of heap + element.
   *  @param  comp   Comparison functor.
   *  @ingroup heap
   *
   *  This operation pushes the element at last-1 onto the valid heap over the
   *  range [first,last-1).  After completion, [first,last) is a valid heap.
   *  Compare operations are performed using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
#pragma empty_line
  /**
   *  @brief  Pop an element off a heap.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @ingroup heap
   *
   *  This operation pops the top of the heap.  The elements first and last-1
   *  are swapped and [first,last-1) is made into a heap.
  */
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
#pragma empty_line
  /**
   *  @brief  Pop an element off a heap using comparison functor.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @param  comp   Comparison functor to use.
   *  @ingroup heap
   *
   *  This operation pops the top of the heap.  The elements first and last-1
   *  are swapped and [first,last-1) is made into a heap.  Comparisons are
   *  made using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
#pragma empty_line
  /**
   *  @brief  Construct a heap over a range.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @ingroup heap
   *
   *  This operation makes the elements in [first,last) into a heap.
  */
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__last - __first < 2)
 return;
#pragma empty_line
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
#pragma empty_line
  /**
   *  @brief  Construct a heap over a range using comparison functor.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @param  comp   Comparison functor to use.
   *  @ingroup heap
   *
   *  This operation makes the elements in [first,last) into a heap.
   *  Comparisons are made using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__last - __first < 2)
 return;
#pragma empty_line
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
#pragma empty_line
  /**
   *  @brief  Sort a heap.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @ingroup heap
   *
   *  This operation sorts the valid heap in the range [first,last).
  */
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      //      __glibcxx_requires_heap(__first, __last);
#pragma empty_line
      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
#pragma empty_line
  /**
   *  @brief  Sort a heap using comparison functor.
   *  @param  first  Start of heap.
   *  @param  last   End of heap.
   *  @param  comp   Comparison functor to use.
   *  @ingroup heap
   *
   *  This operation sorts the valid heap in the range [first,last).
   *  Comparisons are made using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }
#pragma empty_line
}
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algo.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_tempbuf.h" 1 3
// Temporary buffer implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006 
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */
#pragma empty_line
/** @file stl_tempbuf.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/memory" 1 3
// <memory> -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/*
 * Copyright (c) 1997-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */
#pragma empty_line
/** @file include/memory
 *  This is a Standard C++ Library header.
 */
#pragma line 66 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_tempbuf.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @if maint
   *  This class is used in two places: stl_algo.h and ext/memory,
   *  where it is wrapped as the temporary_buffer class.  See
   *  temporary_buffer docs for more notes.
   *  @endif
   */
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;
#pragma empty_line
    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;
#pragma empty_line
      void
      _M_initialize_buffer(const _Tp&, __true_type) { }
#pragma empty_line
      void
      _M_initialize_buffer(const _Tp& __val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, __val); }
#pragma empty_line
    public:
      /// As per Table mumble.
      size_type
      size() const
      { return _M_len; }
#pragma empty_line
      /// Returns the size requested by the constructor; may be >size().
      size_type
      requested_size() const
      { return _M_original_len; }
#pragma empty_line
      /// As per Table mumble.
      iterator
      begin()
      { return _M_buffer; }
#pragma empty_line
      /// As per Table mumble.
      iterator
      end()
      { return _M_buffer + _M_len; }
#pragma empty_line
      /**
       * Constructs a temporary buffer of a size somewhere between
       * zero and the size of the given range.
       */
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
#pragma empty_line
      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }
#pragma empty_line
    private:
      // Disable copy constructor and assignment operator.
      _Temporary_buffer(const _Temporary_buffer&);
#pragma empty_line
      void
      operator=(const _Temporary_buffer&);
    };
#pragma empty_line
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      // Workaround for a __type_traits bug in the pre-7.3 compiler.
      typedef typename std::__is_scalar<_Tp>::__type _Trivial;
#pragma empty_line
      if (true)
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   ;
 }
    }
#pragma empty_line
}
#pragma line 67 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algo.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/stl_algo.h" 2 3
#pragma empty_line
// See concept_check.h for the __glibcxx_*_requires macros.
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @brief Find the median of three values.
   *  @param  a  A value.
   *  @param  b  A value.
   *  @param  c  A value.
   *  @return One of @p a, @p b or @p c.
   *
   *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @c l<=m<=n
   *  then the value returned will be @c m.
   *  This is an SGI extension.
   *  @ingroup SGIextensions
  */
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {
      // concept requirements
#pragma empty_line
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
#pragma empty_line
  /**
   *  @brief Find the median of three values using a predicate for comparison.
   *  @param  a     A value.
   *  @param  b     A value.
   *  @param  c     A value.
   *  @param  comp  A binary predicate.
   *  @return One of @p a, @p b or @p c.
   *
   *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @p comp(l,m)
   *  and @p comp(m,n) are both true then the value returned will be @c m.
   *  This is an SGI extension.
   *  @ingroup SGIextensions
  */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {
      // concept requirements
#pragma empty_line
      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
#pragma empty_line
  /**
   *  @brief Apply a function to every element of a sequence.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  f      A unary function object.
   *  @return   @p f.
   *
   *  Applies the function object @p f to each element in the range
   *  @p [first,last).  @p f must not modify the order of the sequence.
   *  If @p f has a return value it is ignored.
  */
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      // concept requirements
#pragma empty_line
      ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an overload used by find() for the Input Iterator case.
   *  @endif
  */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an overload used by find_if() for the Input Iterator case.
   *  @endif
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an overload used by find() for the RAI case.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
#pragma empty_line
      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;
#pragma empty_line
   if (*__first == __val)
     return __first;
   ++__first;
#pragma empty_line
   if (*__first == __val)
     return __first;
   ++__first;
#pragma empty_line
   if (*__first == __val)
     return __first;
   ++__first;
 }
#pragma empty_line
      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an overload used by find_if() for the RAI case.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
#pragma empty_line
      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;
#pragma empty_line
   if (__pred(*__first))
     return __first;
   ++__first;
#pragma empty_line
   if (__pred(*__first))
     return __first;
   ++__first;
#pragma empty_line
   if (__pred(*__first))
     return __first;
   ++__first;
 }
#pragma empty_line
      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an overload of find() for streambuf iterators.
   *  @endif
  */
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  const _CharT&);
#pragma empty_line
  /**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  val    The value to find.
   *  @return   The first iterator @c i in the range @p [first,last)
   *  such that @c *i == @p val, or @p last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
#pragma empty_line
  /**
   *  @brief Find the first element in a sequence for which a predicate is true.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  pred   A predicate.
   *  @return   The first iterator @c i in the range @p [first,last)
   *  such that @p pred(*i) is true, or @p last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
#pragma empty_line
  /**
   *  @brief Find two adjacent values in a sequence that are equal.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [first,last) and such that @c *i == @c *(i+1),
   *  or @p last if no such iterator exists.
  */
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
#pragma empty_line
  /**
   *  @brief Find two adjacent values in a sequence using a predicate.
   *  @param  first         A forward iterator.
   *  @param  last          A forward iterator.
   *  @param  binary_pred   A binary predicate.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [first,last) and such that
   *  @p binary_pred(*i,*(i+1)) is true, or @p last if no such iterator
   *  exists.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
#pragma empty_line
  /**
   *  @brief Count the number of copies of a value in a sequence.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  value  The value to be counted.
   *  @return   The number of iterators @c i in the range @p [first,last)
   *  for which @c *i == @p value
  */
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
#pragma empty_line
  /**
   *  @brief Count the elements of a sequence for which a predicate is true.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  pred   A predicate.
   *  @return   The number of iterators @c i in the range @p [first,last)
   *  for which @p pred(*i) is true.
  */
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
#pragma empty_line
  /**
   *  @brief Search a sequence for a matching sub-sequence.
   *  @param  first1  A forward iterator.
   *  @param  last1   A forward iterator.
   *  @param  first2  A forward iterator.
   *  @param  last2   A forward iterator.
   *  @return   The first iterator @c i in the range
   *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)
   *  for each @c N in the range @p [0,last2-first2), or @p last1 if no
   *  such iterator exists.
   *
   *  Searches the range @p [first1,last1) for a sub-sequence that compares
   *  equal value-by-value with the sequence given by @p [first2,last2) and
   *  returns an iterator to the first element of the sub-sequence, or
   *  @p last1 if the sub-sequence is not found.
   *
   *  Because the sub-sequence must lie completely within the range
   *  @p [first1,last1) it must start at a position less than
   *  @p last1-(last2-first2) where @p last2-first2 is the length of the
   *  sub-sequence.
   *  This means that the returned iterator @c i will be in the range
   *  @p [first1,last1-(last2-first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
      // Test for empty ranges
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
#pragma empty_line
      // Test for a pattern of length 1.
      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);
#pragma empty_line
      // General case.
      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;
#pragma empty_line
      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;
#pragma empty_line
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
#pragma empty_line
   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
#pragma empty_line
  /**
   *  @brief Search a sequence for a matching sub-sequence using a predicate.
   *  @param  first1     A forward iterator.
   *  @param  last1      A forward iterator.
   *  @param  first2     A forward iterator.
   *  @param  last2      A forward iterator.
   *  @param  predicate  A binary predicate.
   *  @return   The first iterator @c i in the range
   *  @p [first1,last1-(last2-first2)) such that
   *  @p predicate(*(i+N),*(first2+N)) is true for each @c N in the range
   *  @p [0,last2-first2), or @p last1 if no such iterator exists.
   *
   *  Searches the range @p [first1,last1) for a sub-sequence that compares
   *  equal value-by-value with the sequence given by @p [first2,last2),
   *  using @p predicate to determine equality, and returns an iterator
   *  to the first element of the sub-sequence, or @p last1 if no such
   *  iterator exists.
   *
   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      // Test for empty ranges
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
#pragma empty_line
      // Test for a pattern of length 1.
      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }
#pragma empty_line
      // General case.
      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;
#pragma empty_line
      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;
#pragma empty_line
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
#pragma empty_line
   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
   *  overloaded for forward iterators.
   *  @endif
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
   *  overloaded for random access iterators.
   *  @endif
  */
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {
#pragma empty_line
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
#pragma empty_line
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
#pragma empty_line
      if (__tailSize < __pattSize)
        return __last;
#pragma empty_line
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
#pragma empty_line
      while (1) // the main loop...
 {
   // __lookAhead here is always pointing to the last element of next 
   // possible match.
   while (!(*__lookAhead == __val)) // the skip loop...
     {
       if (__tailSize < __pattSize)
  return __last; // Failure
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset); // Success
     }
   if (__remainder > __tailSize)
     return __last; // Failure
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
#pragma empty_line
  /**
   *  @brief Search a sequence for a number of consecutive values.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @param  count  The number of consecutive values.
   *  @param  val    The value to find.
   *  @return   The first iterator @c i in the range @p [first,last-count)
   *  such that @c *(i+N) == @p val for each @c N in the range @p [0,count),
   *  or @p last if no such iterator exists.
   *
   *  Searches the range @p [first,last) for @p count consecutive elements
   *  equal to @p val.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
   *	       _BinaryPredicate)
   *  overloaded for forward iterators.
   *  @endif
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !__binary_pred(*__first, __val))
        ++__first;
#pragma empty_line
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
 }
      return __last;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
   *	       _BinaryPredicate)
   *  overloaded for random access iterators.
   *  @endif
  */
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {
#pragma empty_line
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
#pragma empty_line
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
#pragma empty_line
      if (__tailSize < __pattSize)
        return __last;
#pragma empty_line
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
#pragma empty_line
      while (1) // the main loop...
 {
   // __lookAhead here is always pointing to the last element of next 
   // possible match.
   while (!__binary_pred(*__lookAhead, __val)) // the skip loop...
     {
       if (__tailSize < __pattSize)
  return __last; // Failure
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset); // Success
     }
   if (__remainder > __tailSize)
     return __last; // Failure
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
#pragma empty_line
  /**
   *  @brief Search a sequence for a number of consecutive values using a
   *         predicate.
   *  @param  first        A forward iterator.
   *  @param  last         A forward iterator.
   *  @param  count        The number of consecutive values.
   *  @param  val          The value to find.
   *  @param  binary_pred  A binary predicate.
   *  @return   The first iterator @c i in the range @p [first,last-count)
   *  such that @p binary_pred(*(i+N),val) is true for each @c N in the
   *  range @p [0,count), or @p last if no such iterator exists.
   *
   *  Searches the range @p [first,last) for @p count consecutive elements
   *  for which the predicate returns true.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
#pragma empty_line
  /**
   *  @brief Swap the elements of two sequences.
   *  @param  first1  A forward iterator.
   *  @param  last1   A forward iterator.
   *  @param  first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
#pragma empty_line
  /**
   *  @brief Perform an operation on a sequence.
   *  @param  first     An input iterator.
   *  @param  last      An input iterator.
   *  @param  result    An output iterator.
   *  @param  unary_op  A unary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(result+N)=unary_op(*(first+N)) for each @c N in the
   *  range @p [0,last-first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @param  first1     An input iterator.
   *  @param  last1      An input iterator.
   *  @param  first2     An input iterator.
   *  @param  result     An output iterator.
   *  @param  binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p *(result+N)=binary_op(*(first1+N),*(first2+N)) for each
   *  @c N in the range @p [0,last1-first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Replace each occurrence of one value in a sequence with another
   *         value.
   *  @param  first      A forward iterator.
   *  @param  last       A forward iterator.
   *  @param  old_value  The value to be replaced.
   *  @param  new_value  The replacement value.
   *  @return   replace() returns no value.
   *
   *  For each iterator @c i in the range @p [first,last) if @c *i ==
   *  @p old_value then the assignment @c *i = @p new_value is performed.
  */
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
#pragma empty_line
  /**
   *  @brief Replace each value in a sequence for which a predicate returns
   *         true with another value.
   *  @param  first      A forward iterator.
   *  @param  last       A forward iterator.
   *  @param  pred       A predicate.
   *  @param  new_value  The replacement value.
   *  @return   replace_if() returns no value.
   *
   *  For each iterator @c i in the range @p [first,last) if @p pred(*i)
   *  is true then the assignment @c *i = @p new_value is performed.
  */
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, replacing each element of one value with another
   *         value.
   *  @param  first      An input iterator.
   *  @param  last       An input iterator.
   *  @param  result     An output iterator.
   *  @param  old_value  The value to be replaced.
   *  @param  new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the input range @p [first,last) to the
   *  output range @p [result,result+(last-first)) replacing elements
   *  equal to @p old_value with @p new_value.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, replacing each value for which a predicate
   *         returns true with another value.
   *  @param  first      An input iterator.
   *  @param  last       An input iterator.
   *  @param  result     An output iterator.
   *  @param  pred       A predicate.
   *  @param  new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the range @p [first,last) to the range
   *  @p [result,result+(last-first)) replacing elements for which
   *  @p pred returns true with @p new_value.
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @param  gen    A function object taking no arguments.
   *  @return   generate() returns no value.
   *
   *  Performs the assignment @c *i = @p gen() for each @c i in the range
   *  @p [first,last).
  */
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
#pragma empty_line
  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @param  first  A forward iterator.
   *  @param  n      The length of the sequence.
   *  @param  gen    A function object taking no arguments.
   *  @return   The end of the sequence, @p first+n
   *
   *  Performs the assignment @c *i = @p gen() for each @c i in the range
   *  @p [first,first+n).
  */
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, removing elements of a given value.
   *  @param  first   An input iterator.
   *  @param  last    An input iterator.
   *  @param  result  An output iterator.
   *  @param  value   The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [first,last) not equal to @p value
   *  to the range beginning at @p result.
   *  remove_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, removing elements for which a predicate is true.
   *  @param  first   An input iterator.
   *  @param  last    An input iterator.
   *  @param  result  An output iterator.
   *  @param  pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [first,last) for which
   *  @p pred returns true to the range beginning at @p result.
   *
   *  remove_copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Remove elements from a sequence.
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  value  The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements equal to @p value are removed from the range
   *  @p [first,last).
   *
   *  remove() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
#pragma empty_line
  /**
   *  @brief Remove elements from a sequence using a predicate.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @param  pred   A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements for which @p pred returns true are removed from the range
   *  @p [first,last).
   *
   *  remove_if() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
   *                                  _OutputIterator)
   *  overloaded for forward iterators and output iterator as result.
   *  @endif
  */
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- taken care of in dispatching function
      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
   *                                  _OutputIterator)
   *  overloaded for input iterators and output iterator as result.
   *  @endif
  */
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- taken care of in dispatching function
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
   *                                  _OutputIterator)
   *  overloaded for input iterators and forward iterator as result.
   *  @endif
  */
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {
      // concept requirements -- taken care of in dispatching function
      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for forward iterators and output iterator as result.
   *  @endif
  */
  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(*__first, *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and output iterator as result.
   *  @endif
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and forward iterator as result.
   *  @endif
  */
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {
      // concept requirements -- iterators already checked
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first))
   *++__result = *__first;
      return ++__result;
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, removing consecutive duplicate values.
   *  @param  first   An input iterator.
   *  @param  last    An input iterator.
   *  @param  result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [first,last) to the range
   *  beginning at @p result, except that only the first element is copied
   *  from groups of consecutive elements that compare equal.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  @if maint
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
   *  Assignable?
   *  @endif
  */
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, removing consecutive values using a predicate.
   *  @param  first        An input iterator.
   *  @param  last         An input iterator.
   *  @param  result       An output iterator.
   *  @param  binary_pred  A binary predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [first,last) to the range
   *  beginning at @p result, except that only the first element is copied
   *  from groups of consecutive elements for which @p binary_pred returns
   *  true.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  @if maint
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  @endif
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {
      // concept requirements -- predicates checked later
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#pragma empty_line
  /**
   *  @brief Remove consecutive duplicate values from a sequence.
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values that compare equal.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      // Skip the beginning, if already unique.
      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;
#pragma empty_line
      // Do the real copy work.
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
#pragma empty_line
  /**
   *  @brief Remove consecutive values from a sequence using a predicate.
   *  @param  first        A forward iterator.
   *  @param  last         A forward iterator.
   *  @param  binary_pred  A binary predicate.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values for which @p binary_pred returns true.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      // Skip the beginning, if already unique.
      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;
#pragma empty_line
      // Do the real copy work.
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for bidirectional iterators.
   *  @endif
  */
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for random access iterators.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
#pragma empty_line
  /**
   *  @brief Reverse a sequence.
   *  @param  first  A bidirectional iterator.
   *  @param  last   A bidirectional iterator.
   *  @return   reverse() returns no value.
   *
   *  Reverses the order of the elements in the range @p [first,last),
   *  so that the first element becomes the last etc.
   *  For every @c i such that @p 0<=i<=(last-first)/2), @p reverse()
   *  swaps @p *(first+i) and @p *(last-(i+1))
  */
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, reversing its elements.
   *  @param  first   A bidirectional iterator.
   *  @param  last    A bidirectional iterator.
   *  @param  result  An output iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements in the range @p [first,last) to the range
   *  @p [result,result+(last-first)) such that the order of the
   *  elements is reversed.
   *  For every @c i such that @p 0<=i<=(last-first), @p reverse_copy()
   *  performs the assignment @p *(result+(last-first)-i) = *(first+i).
   *  The ranges @p [first,last) and @p [result,result+(last-first))
   *  must not overlap.
  */
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
#pragma empty_line
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the rotate algorithm specialized on RAIs.
   *  It returns the greatest common divisor of two integer values.
   *  @endif
  */
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the rotate algorithm.
   *  @endif
  */
  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;
#pragma empty_line
      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);
#pragma empty_line
      __first2 = __middle;
#pragma empty_line
      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the rotate algorithm.
   *  @endif
  */
  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__first == __middle || __last == __middle)
 return;
#pragma empty_line
      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());
#pragma empty_line
      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }
#pragma empty_line
      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the rotate algorithm.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__first == __middle || __last == __middle)
 return;
#pragma empty_line
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;
#pragma empty_line
      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }
#pragma empty_line
      const _Distance __d = __gcd(__n, __k);
#pragma empty_line
      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;
#pragma empty_line
   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }
#pragma empty_line
    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }
#pragma empty_line
   *__p = __tmp;
   ++__first;
 }
    }
#pragma empty_line
  /**
   *  @brief Rotate the elements of a sequence.
   *  @param  first   A forward iterator.
   *  @param  middle  A forward iterator.
   *  @param  last    A forward iterator.
   *  @return  Nothing.
   *
   *  Rotates the elements of the range @p [first,last) by @p (middle-first)
   *  positions so that the element at @p middle is moved to @p first, the
   *  element at @p middle+1 is moved to @first+1 and so on for each element
   *  in the range @p [first,last).
   *
   *  This effectively swaps the ranges @p [first,middle) and
   *  @p [middle,last).
   *
   *  Performs @p *(first+(n+(last-middle))%(last-first))=*(first+n) for
   *  each @p n in the range @p [0,last-first).
  */
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
#pragma empty_line
  /**
   *  @brief Copy a sequence, rotating its elements.
   *  @param  first   A forward iterator.
   *  @param  middle  A forward iterator.
   *  @param  last    A forward iterator.
   *  @param  result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements of the range @p [first,last) to the range
   *  beginning at @result, rotating the copied elements by @p (middle-first)
   *  positions so that the element at @p middle is moved to @p result, the
   *  element at @p middle+1 is moved to @result+1 and so on for each element
   *  in the range @p [first,last).
   *
   *  Performs @p *(result+(n+(last-middle))%(last-first))=*(first+n) for
   *  each @p n in the range @p [0,last-first).
  */
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
#pragma empty_line
  /**
   *  @brief Randomly shuffle the elements of a sequence.
   *  @param  first   A forward iterator.
   *  @param  last    A forward iterator.
   *  @return  Nothing.
   *
   *  Reorder the elements in the range @p [first,last) using a random
   *  distribution, so that every possible ordering of the sequence is
   *  equally likely.
  */
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
#pragma empty_line
  /**
   *  @brief Shuffle the elements of a sequence using a random number
   *         generator.
   *  @param  first   A forward iterator.
   *  @param  last    A forward iterator.
   *  @param  rand    The RNG functor or function.
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [first,last) using @p rand to
   *  provide a random distribution. Calling @p rand(N) for a positive
   *  integer @p N should return a randomly chosen integer from the
   *  range [0,N).
  */
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
#pragma empty_line
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;
#pragma empty_line
      while (__pred(*__first))
 if (++__first == __last)
   return __first;
#pragma empty_line
      _ForwardIterator __next = __first;
#pragma empty_line
      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }
#pragma empty_line
      return __first;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
#pragma empty_line
  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence.
   *  @param  first   A forward iterator.
   *  @param  last    A forward iterator.
   *  @param  pred    A predicate functor.
   *  @return  An iterator @p middle such that @p pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  @p pred must not modify its operand. @p partition() does not preserve
   *  the relative ordering of elements in each group, use
   *  @p stable_partition() if this is needed.
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
#pragma empty_line
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
#pragma empty_line
  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence, preserving relative ordering.
   *  @param  first   A forward iterator.
   *  @param  last    A forward iterator.
   *  @param  pred    A predicate functor.
   *  @return  An iterator @p middle such that @p pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  Performs the same function as @p partition() with the additional
   *  guarantee that the relative ordering of elements in each group is
   *  preserved, so any two elements @p x and @p y in the range
   *  @p [first,last) such that @p pred(x)==pred(y) will have the same
   *  relative ordering after calling @p stable_partition().
  */
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;
#pragma empty_line
   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function...
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  @doctodo
   *  This controls some aspect of the sort routines.
   *  @endif
  */
  enum { _S_threshold = 16 };
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;
#pragma empty_line
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;
#pragma empty_line
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routines.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routines.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routines.
   *  @endif
  */
  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
#pragma empty_line
  /**
   *  @brief Sort the smallest elements of a sequence.
   *  @param  first   An iterator.
   *  @param  middle  Another iterator.
   *  @param  last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (middle-first) elements in the range
   *  @p [first,last) and moves them to the range @p [first,middle). The
   *  order of the remaining elements in the range @p [middle,last) is
   *  undefined.
   *  After the sort if @p i and @j are iterators in the range
   *  @p [first,middle) such that @i precedes @j and @k is an iterator in
   *  the range @p [middle,last) then @p *j<*i and @p *k<*i are both false.
  */
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
#pragma empty_line
  /**
   *  @brief Sort the smallest elements of a sequence using a predicate
   *         for comparison.
   *  @param  first   An iterator.
   *  @param  middle  Another iterator.
   *  @param  last    Another iterator.
   *  @param  comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (middle-first) elements in the range
   *  @p [first,last) and moves them to the range @p [first,middle). The
   *  order of the remaining elements in the range @p [middle,last) is
   *  undefined.
   *  After the sort if @p i and @j are iterators in the range
   *  @p [first,middle) such that @i precedes @j and @k is an iterator in
   *  the range @p [middle,last) then @p *comp(j,*i) and @p comp(*k,*i)
   *  are both false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
#pragma empty_line
  /**
   *  @brief Copy the smallest elements of a sequence.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  result_first   A random-access iterator.
   *  @param  result_last    Another random-access iterator.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [first,last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (last-first) and
   *  @p (result_last-result_first).
   *  After the sort if @p i and @j are iterators in the range
   *  @p [result_first,result_first+N) such that @i precedes @j then
   *  @p *j<*i is false.
   *  The value returned is @p result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
#pragma empty_line
  /**
   *  @brief Copy the smallest elements of a sequence using a predicate for
   *         comparison.
   *  @param  first   An input iterator.
   *  @param  last    Another input iterator.
   *  @param  result_first   A random-access iterator.
   *  @param  result_last    Another random-access iterator.
   *  @param  comp    A comparison functor.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [first,last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (last-first) and
   *  @p (result_last-result_first).
   *  After the sort if @p i and @j are iterators in the range
   *  @p [result_first,result_first+N) such that @i precedes @j then
   *  @p comp(*j,*i) is false.
   *  The value returned is @p result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the sort routine.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
#pragma empty_line
  /**
   *  @brief Sort the elements of a sequence.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [first,last) in ascending order,
   *  such that @p *(i+1)<*i is false for each iterator @p i in the range
   *  @p [first,last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
#pragma empty_line
  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [first,last) in ascending order,
   *  such that @p comp(*(i+1),*i) is false for every iterator @p i in the
   *  range @p [first,last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
#pragma empty_line
  /**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @return  An iterator pointing to the first element "not less than" @a val,
   *           or end() if every element is less than @a val.
   *  @ingroup binarysearch
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
#pragma empty_line
  /**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @param  comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element "not less than" @a val,
   *           or end() if every element is less than @a val.
   *  @ingroup binarysearch
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
#pragma empty_line
  /**
   *  @brief Finds the last position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @return  An iterator pointing to the first element greater than @a val,
   *           or end() if no elements are greater than @a val.
   *  @ingroup binarysearch
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
#pragma empty_line
  /**
   *  @brief Finds the last position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @param  comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element greater than @a val,
   *           or end() if no elements are greater than @a val.
   *  @ingroup binarysearch
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the stable sorting routines.
   *  @endif
  */
  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the stable sorting routines.
   *  @endif
  */
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
#pragma empty_line
  /**
   *  @brief Merges two sorted ranges.
   *  @param  first1  An iterator.
   *  @param  first2  Another iterator.
   *  @param  last1   Another iterator.
   *  @param  last2   Another iterator.
   *  @param  result  An iterator pointing to the end of the merged range.
   *  @return  An iterator pointing to the first element "not less than" @a val.
   *
   *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range
   *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges
   *  must be sorted, and the output range must not overlap with either of
   *  the input ranges.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#pragma empty_line
  /**
   *  @brief Merges two sorted ranges.
   *  @param  first1  An iterator.
   *  @param  first2  Another iterator.
   *  @param  last1   Another iterator.
   *  @param  last2   Another iterator.
   *  @param  result  An iterator pointing to the end of the merged range.
   *  @param  comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element "not less than" @a val.
   *
   *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range
   *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges
   *  must be sorted, and the output range must not overlap with either of
   *  the input ranges.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#pragma empty_line
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;
#pragma empty_line
      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }
#pragma empty_line
      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }
#pragma empty_line
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;
#pragma empty_line
      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);
#pragma empty_line
      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }
#pragma empty_line
  enum { _S_chunk_size = 7 };
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
#pragma empty_line
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
#pragma empty_line
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);
#pragma empty_line
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
#pragma empty_line
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
#pragma empty_line
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
#pragma empty_line
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }
#pragma empty_line
  /**
   *  @if maint
   *  This is a helper function for the merge routines.
   *  @endif
  */
  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
#pragma empty_line
  /**
   *  @brief Merges two sorted ranges in place.
   *  @param  first   An iterator.
   *  @param  middle  Another iterator.
   *  @param  last    Another iterator.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [first,middle) and
   *  [middle,last), and puts the result in [first,last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (last-first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(first,last).
  */
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__first == __middle || __middle == __last)
 return;
#pragma empty_line
      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);
#pragma empty_line
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
#pragma empty_line
  /**
   *  @brief Merges two sorted ranges in place.
   *  @param  first   An iterator.
   *  @param  middle  Another iterator.
   *  @param  last    Another iterator.
   *  @param  comp    A functor to use for comparisons.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [first,middle) and
   *  [middle,last), and puts the result in [first,last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (last-first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(first,last).
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__first == __middle || __middle == __last)
 return;
#pragma empty_line
      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);
#pragma empty_line
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
#pragma empty_line
  /**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [first,last) in ascending order,
   *  such that @p *(i+1)<*i is false for each iterator @p i in the range
   *  @p [first,last-1).
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [first,last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
#pragma empty_line
  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [first,last) in ascending order,
   *  such that @p comp(*(i+1),*i) is false for each iterator @p i in the
   *  range @p [first,last-1).
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [first,last) such that
   *  @p comp(x,y) is false and @p comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
#pragma empty_line
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);
       // Place the nth largest element in its final position.
       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);
       // Place the nth largest element in its final position.
       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
#pragma empty_line
  /**
   *  @brief Sort a sequence just enough to find a particular position.
   *  @param  first   An iterator.
   *  @param  nth     Another iterator.
   *  @param  last    Another iterator.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [first,last) so that @p *nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted.
   *  whole sequence been sorted. The elements either side of @p *nth are
   *  not completely sorted, but for any iterator @i in the range
   *  @p [first,nth) and any iterator @j in the range @p [nth,last) it
   *  holds that @p *j<*i is false.
  */
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__first == __last || __nth == __last)
 return;
#pragma empty_line
      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
#pragma empty_line
  /**
   *  @brief Sort a sequence just enough to find a particular position
   *         using a predicate for comparison.
   *  @param  first   An iterator.
   *  @param  nth     Another iterator.
   *  @param  last    Another iterator.
   *  @param  comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [first,last) so that @p *nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *nth are
   *  not completely sorted, but for any iterator @i in the range
   *  @p [first,nth) and any iterator @j in the range @p [nth,last) it
   *  holds that @p comp(*j,*i) is false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      if (__first == __last || __nth == __last)
 return;
#pragma empty_line
      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
#pragma empty_line
  /**
   *  @brief Finds the largest subrange in which @a val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binarysearch
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(first, last, val),
   *                   upper_bound(first, last, val))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
#pragma empty_line
  /**
   *  @brief Finds the largest subrange in which @a val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @param  comp    A functor to use for comparisons.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binarysearch
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(first, last, val, comp),
   *                   upper_bound(first, last, val, comp))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
#pragma empty_line
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
#pragma empty_line
  /**
   *  @brief Determines whether an element exists in a range.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].
   *  @ingroup binarysearch
   *
   *  Note that this does not actually return an iterator to @a val.  For
   *  that, use std::find or a container's specialized find member functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
#pragma empty_line
  /**
   *  @brief Determines whether an element exists in a range.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @param  comp    A functor to use for comparisons.
   *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].
   *  @ingroup binarysearch
   *
   *  Note that this does not actually return an iterator to @a val.  For
   *  that, use std::find or a container's specialized find member functions.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
#pragma empty_line
  // Set algorithms: includes, set_union, set_intersection, set_difference,
  // set_symmetric_difference.  All of these algorithms have the precondition
  // that their input ranges are sorted and the postcondition that their output
  // ranges are sorted.
#pragma empty_line
  /**
   *  @brief Determines whether all elements of a sequence exists in a range.
   *  @param  first1  Start of search range.
   *  @param  last1   End of search range.
   *  @param  first2  Start of sequence
   *  @param  last2   End of sequence.
   *  @return  True if each element in [first2,last2) is contained in order
   *  within [first1,last1).  False otherwise.
   *  @ingroup setoperations
   *
   *  This operation expects both [first1,last1) and [first2,last2) to be
   *  sorted.  Searches for the presence of each element in [first2,last2)
   *  within [first1,last1).  The iterators over each range only move forward,
   *  so this is a linear algorithm.  If an element in [first2,last2) is not
   *  found before the search iterator reaches @a last2, false is returned.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;
#pragma empty_line
      return __first2 == __last2;
    }
#pragma empty_line
  /**
   *  @brief Determines whether all elements of a sequence exists in a range
   *  using comparison.
   *  @param  first1  Start of search range.
   *  @param  last1   End of search range.
   *  @param  first2  Start of sequence
   *  @param  last2   End of sequence.
   *  @param  comp    Comparison function to use.
   *  @return  True if each element in [first2,last2) is contained in order
   *  within [first1,last1) according to comp.  False otherwise.
   *  @ingroup setoperations
   *
   *  This operation expects both [first1,last1) and [first2,last2) to be
   *  sorted.  Searches for the presence of each element in [first2,last2)
   *  within [first1,last1), using comp to decide.  The iterators over each
   *  range only move forward, so this is a linear algorithm.  If an element
   *  in [first2,last2) is not found before the search iterator reaches @a
   *  last2, false is returned.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;
#pragma empty_line
      return __first2 == __last2;
    }
#pragma empty_line
  /**
   *  @brief Return the union of two sorted ranges.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that element is copied and the iterator advanced.  If an element is
   *  contained in both ranges, the element from the first range is copied and
   *  both ranges advance.  The output range may not overlap either input
   *  range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#pragma empty_line
  /**
   *  @brief Return the union of two sorted ranges using a comparison functor.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @param  comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @a comp, that element is copied and the iterator advanced.
   *  If an equivalent element according to @a comp is contained in both
   *  ranges, the element from the first range is copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#pragma empty_line
  /**
   *  @brief Return the intersection of two sorted ranges.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that iterator advances.  If an element is contained in both ranges, the
   *  element from the first range is copied and both ranges advance.  The
   *  output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Return the intersection of two sorted ranges using comparison
   *  functor.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @param  comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @a comp, that iterator advances.  If an element is
   *  contained in both ranges according to @a comp, the element from the
   *  first range is copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
#pragma empty_line
  /**
   *  @brief Return the difference of two sorted ranges.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second, that element is copied and the
   *  iterator advances.  If the current element of the second range is less,
   *  the iterator advances, but no element is copied.  If an element is
   *  contained in both ranges, no elements are copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
#pragma empty_line
  /**
   *  @brief  Return the difference of two sorted ranges using comparison
   *  functor.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @param  comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second according to @a comp, that element
   *  is copied and the iterator advances.  If the current element of the
   *  second range is less, no element is copied and the iterator advances.
   *  If an element is contained in both ranges according to @a comp, no
   *  elements are copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
#pragma empty_line
  /**
   *  @brief  Return the symmetric difference of two sorted ranges.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other, that element is copied and the iterator advances.  If an
   *  element is contained in both ranges, no elements are copied and both
   *  ranges advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
#pragma empty_line
  /**
   *  @brief  Return the symmetric difference of two sorted ranges using
   *  comparison functor.
   *  @param  first1  Start of first range.
   *  @param  last1   End of first range.
   *  @param  first2  Start of second range.
   *  @param  last2   End of second range.
   *  @param  comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup setoperations
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other according to @a comp, that element is copied and the
   *  iterator advances.  If an element is contained in both ranges according
   *  to @a comp, no elements are copied and both ranges advance.  The output
   *  range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
#pragma empty_line
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
#pragma empty_line
  // min_element and max_element, with and without an explicitly supplied
  // comparison function.
#pragma empty_line
  /**
   *  @brief  Return the maximum element in a range.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.
  */
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
#pragma empty_line
  /**
   *  @brief  Return the maximum element in a range using comparison functor.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @param  comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the largest value
   *  according to comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }
#pragma empty_line
  /**
   *  @brief  Return the minimum element in a range.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @return  Iterator referencing the first instance of the smallest value.
  */
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
#pragma empty_line
  /**
   *  @brief  Return the minimum element in a range using comparison functor.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @param  comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the smallest value
   *  according to comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
#pragma empty_line
  // next_permutation and prev_permutation, with and without an explicitly
  // supplied comparison function.
#pragma empty_line
  /**
   *  @brief  Permute range into the next "dictionary" ordering.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of "dictionary" sorted
   *  sequences.  Permutes the current sequence into the next one of this set.
   *  Returns true if there are more sequences to generate.  If the sequence
   *  is the largest of the set, the smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
#pragma empty_line
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#pragma empty_line
  /**
   *  @brief  Permute range into the next "dictionary" ordering using
   *  comparison functor.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @param  comp
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range [first,last) as a set of
   *  "dictionary" sorted sequences ordered by @a comp.  Permutes the current
   *  sequence into the next one of this set.  Returns true if there are more
   *  sequences to generate.  If the sequence is the largest of the set, the
   *  smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
#pragma empty_line
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#pragma empty_line
  /**
   *  @brief  Permute range into the previous "dictionary" ordering.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of "dictionary" sorted
   *  sequences.  Permutes the current sequence into the previous one of this
   *  set.  Returns true if there are more sequences to generate.  If the
   *  sequence is the smallest of the set, the largest is generated and false
   *  returned.
  */
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
#pragma empty_line
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#pragma empty_line
  /**
   *  @brief  Permute range into the previous "dictionary" ordering using
   *  comparison functor.
   *  @param  first  Start of range.
   *  @param  last   End of range.
   *  @param  comp
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range [first,last) as a set of
   *  "dictionary" sorted sequences ordered by @a comp.  Permutes the current
   *  sequence into the previous one of this set.  Returns true if there are
   *  more sequences to generate.  If the sequence is the smallest of the set,
   *  the largest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
#pragma empty_line
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#pragma empty_line
  // find_first_of, with and without an explicitly supplied comparison function.
#pragma empty_line
  /**
   *  @brief  Find element from a set in a sequence.
   *  @param  first1  Start of range to search.
   *  @param  last1   End of range to search.
   *  @param  first2  Start of match candidates.
   *  @param  last2   End of match candidates.
   *  @return   The first iterator @c i in the range
   *  @p [first1,last1) such that @c *i == @p *(i2) such that i2 is an
   *  interator in [first2,last2), or @p last1 if no such iterator exists.
   *
   *  Searches the range @p [first1,last1) for an element that is equal to
   *  some element in the range [first2,last2).  If found, returns an iterator
   *  in the range [first1,last1), otherwise returns @p last1.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
#pragma empty_line
  /**
   *  @brief  Find element from a set in a sequence using a predicate.
   *  @param  first1  Start of range to search.
   *  @param  last1   End of range to search.
   *  @param  first2  Start of match candidates.
   *  @param  last2   End of match candidates.
   *  @param  comp    Predicate to use.
   *  @return   The first iterator @c i in the range
   *  @p [first1,last1) such that @c comp(*i, @p *(i2)) is true and i2 is an
   *  interator in [first2,last2), or @p last1 if no such iterator exists.
   *
   *  Searches the range @p [first1,last1) for an element that is equal to
   *  some element in the range [first2,last2).  If found, returns an iterator in
   *  the range [first1,last1), otherwise returns @p last1.
  */
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
#pragma empty_line
#pragma empty_line
  // find_end, with and without an explicitly supplied comparison function.
  // Search [first2, last2) as a subsequence in [first1, last1), and return
  // the *last* possible match.  Note that find_end for bidirectional iterators
  // is much faster than for forward iterators.
#pragma empty_line
  // find_end for forward iterators.
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
#pragma empty_line
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
#pragma empty_line
  // find_end for bidirectional iterators.  Requires partial specialization.
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
#pragma empty_line
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);
#pragma empty_line
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
#pragma empty_line
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
#pragma empty_line
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);
#pragma empty_line
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
#pragma empty_line
  // Dispatching functions for find_end.
#pragma empty_line
  /**
   *  @brief  Find last matching subsequence in a sequence.
   *  @param  first1  Start of range to search.
   *  @param  last1   End of range to search.
   *  @param  first2  Start of sequence to match.
   *  @param  last2   End of sequence to match.
   *  @return   The last iterator @c i in the range
   *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)
   *  for each @c N in the range @p [0,last2-first2), or @p last1 if no
   *  such iterator exists.
   *
   *  Searches the range @p [first1,last1) for a sub-sequence that compares
   *  equal value-by-value with the sequence given by @p [first2,last2) and
   *  returns an iterator to the first element of the sub-sequence, or
   *  @p last1 if the sub-sequence is not found.  The sub-sequence will be the
   *  last such subsequence contained in [first,last1).
   *
   *  Because the sub-sequence must lie completely within the range
   *  @p [first1,last1) it must start at a position less than
   *  @p last1-(last2-first2) where @p last2-first2 is the length of the
   *  sub-sequence.
   *  This means that the returned iterator @c i will be in the range
   *  @p [first1,last1-(last2-first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
#pragma empty_line
  /**
   *  @brief  Find last matching subsequence in a sequence using a predicate.
   *  @param  first1  Start of range to search.
   *  @param  last1   End of range to search.
   *  @param  first2  Start of sequence to match.
   *  @param  last2   End of sequence to match.
   *  @param  comp    The predicate to use.
   *  @return   The last iterator @c i in the range
   *  @p [first1,last1-(last2-first2)) such that @c predicate(*(i+N), @p
   *  (first2+N)) is true for each @c N in the range @p [0,last2-first2), or
   *  @p last1 if no such iterator exists.
   *
   *  Searches the range @p [first1,last1) for a sub-sequence that compares
   *  equal value-by-value with the sequence given by @p [first2,last2) using
   *  comp as a predicate and returns an iterator to the first element of the
   *  sub-sequence, or @p last1 if the sub-sequence is not found.  The
   *  sub-sequence will be the last such subsequence contained in
   *  [first,last1).
   *
   *  Because the sub-sequence must lie completely within the range
   *  @p [first1,last1) it must start at a position less than
   *  @p last1-(last2-first2) where @p last2-first2 is the length of the
   *  sub-sequence.
   *  This means that the returned iterator @c i will be in the range
   *  @p [first1,last1-(last2-first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {
      // concept requirements
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
#pragma empty_line
}
#pragma line 69 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/algorithm" 2 3
#pragma line 58 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.tcc" 1 3
// Components for manipulating sequences of characters -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file basic_string.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 21  Strings library
//
#pragma empty_line
// Written by Jason Merrill based upon the specification by Takanori Adachi
// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_string.tcc" 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }
#pragma empty_line
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;
#pragma empty_line
  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
  // at static init time (before static ctors are run).
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];
#pragma empty_line
  // NB: This is the special case for Input Iterators, used in
  // istreambuf_iterators, etc.
  // Input Iterators have a cost structure very different from
  // pointers, calling for a different coding style.
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {
#pragma empty_line
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
#pragma empty_line
 // Avoid reallocation for common case.
 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {
      // Allocate more space.
      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {
#pragma empty_line
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
#pragma empty_line
 // NB: Not required, but considered best practice.
 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));
#pragma empty_line
 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));
 // Check for out_of_range and length_error exceptions.
 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 if (true)
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
#pragma empty_line
      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();
#pragma empty_line
      // Check for out_of_range and length_error exceptions.
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);
#pragma empty_line
      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }
#pragma empty_line
  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }
#pragma empty_line
  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }
#pragma empty_line
  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {
   // XXX MT
   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {
   // Work in-place.
   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
           // Work in-place.
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }
#pragma empty_line
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {
    // Work in-place: non-overlapping case.
    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {
    // Todo: overlapping case.
    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {
#pragma empty_line
      if (_M_rep() == &_S_empty_rep())
 return;
#pragma empty_line
      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;
#pragma empty_line
      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {
   // Must reallocate.
   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
#pragma empty_line
   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);
#pragma empty_line
   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {
   // Work in-place.
   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   // Make sure we don't shrink below the current size
   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }
      // The code below can usually be optimized away.
      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 83.  String::npos vs. string::max_size()
      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
#pragma empty_line
      // The standard places no restriction on allocating more memory
      // than is strictly needed within this layer at the moment or as
      // requested by an explicit application call to reserve().
#pragma empty_line
      // Many malloc implementations perform quite poorly when an
      // application attempts to allocate memory in a stepwise fashion
      // growing each allocation size by only 1 char.  Additionally,
      // it makes little sense to allocate less linear memory than the
      // natural blocking size of the malloc implementation.
      // Unfortunately, we would need a somewhat low-level calculation
      // with tuned parameters to get this perfect for any particular
      // malloc implementation.  Fortunately, generalizations about
      // common features seen among implementations seems to suffice.
#pragma empty_line
      // __pagesize need not match the actual VM page size for good
      // results in practice, thus we pick a common value on the low
      // side.  __malloc_header_size is an estimate of the amount of
      // overhead per memory allocation (in practice seen N * sizeof
      // (void*) where N is 0, 2 or 4).  According to folklore,
      // picking this value on the high side is better than
      // low-balling it (especially when this algorithm is used with
      // malloc implementations that allocate memory blocks rounded up
      // to a size which is a power of 2).
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);
#pragma empty_line
      // The below implements an exponential growth policy, necessary to
      // meet amortized linear time requirements of the library: see
      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
      // It's active for allocations requiring an amount of memory above
      // system pagesize. This is consistent with the requirements of the
      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;
#pragma empty_line
      // NB: Need an array of char_type[__capacity], plus a terminating
      // null char_type() element, plus enough for the _Rep data structure.
      // Whew. Seemingly so needy, yet so elemental.
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
#pragma empty_line
      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);
   // Never allocate a string bigger than _S_max_size.
   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
#pragma empty_line
      // NB: Might throw, but no worries about a leak, mate: _Rep()
      // does not throw.
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      // ABI compatibility - 3.4.x set in _S_create both
      // _M_refcount and _M_length.  All callers of _S_create
      // in basic_string.tcc then set just _M_length.
      // In 4.0.x and later both _M_refcount and _M_length
      // are initialized in the callers, unfortunately we can
      // have 3.4.x compiled code with _S_create callers inlined
      // calling 4.0.x+ _S_create.
      __p->_M_set_sharable();
      return __p;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
      // Requested capacity of the clone.
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
#pragma empty_line
      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);
      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);
      // 21.3.5.7 par 3: do not append null.  (good.)
      return __n;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();
#pragma empty_line
      if (__n == 0)
 return __pos <= __size ? __pos : npos;
#pragma empty_line
      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = __n - __osize;
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = __size - __osize;
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __osize;
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB: This syntax is a GNU extension.
#pragma empty_line
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
#pragma empty_line
#pragma empty_line
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 59 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 2 3
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/atomicity.h" 1 3
// Support for atomic operations -*- C++ -*-
#pragma empty_line
// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file atomicity.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 22.1.1 Class locale
  /**
   *  @brief  Container class for localization functionality.
   *
   *  The locale class is first a class wrapper for C library locales.  It is
   *  also an extensible container for user-defined localization.  A locale is
   *  a collection of facets that implement various localization features such
   *  as money, time, and number printing.
   *
   *  Constructing C++ locales does not change the C library locale.
   *
   *  This library supports efficient construction and copying of locales
   *  through a reference counting implementation of the locale class.
  */
  class locale
  {
  public:
    // Types:
    /// Definition of locale::category.
    typedef int category;
#pragma empty_line
    // Forward decls and friends:
    class facet;
    class id;
    class _Impl;
#pragma empty_line
    friend class facet;
    friend class _Impl;
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Cache>
      friend struct __use_cache;
#pragma empty_line
    //@{
    /**
     *  @brief  Category values.
     *
     *  The standard category values are none, ctype, numeric, collate, time,
     *  monetary, and messages.  They form a bitmask that supports union and
     *  intersection.  The category all is the union of these values.
     *
     *  @if maint
     *  NB: Order must match _S_facet_categories definition in locale.cc
     *  @endif
    */
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
    //@}
#pragma empty_line
    // Construct/copy/destroy:
#pragma empty_line
    /**
     *  @brief  Default constructor.
     *
     *  Constructs a copy of the global locale.  If no locale has been
     *  explicitly set, this is the "C" locale.
    */
    locale() throw();
#pragma empty_line
    /**
     *  @brief  Copy constructor.
     *
     *  Constructs a copy of @a other.
     *
     *  @param  other  The locale to copy.
    */
    locale(const locale& __other) throw();
#pragma empty_line
    /**
     *  @brief  Named locale constructor.
     *
     *  Constructs a copy of the named C library locale.
     *
     *  @param  s  Name of the locale to construct.
     *  @throw  std::runtime_error if s is null or an undefined locale.
    */
    explicit
    locale(const char* __s);
#pragma empty_line
    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale named by @a s.  If base is
     *  named, this locale instance will also be named.
     *
     *  @param  base  The locale to copy.
     *  @param  s  Name of the locale to use facets from.
     *  @param  cat  Set of categories defining the facets to use from s.
     *  @throw  std::runtime_error if s is null or an undefined locale.
    */
    locale(const locale& __base, const char* __s, category __cat);
#pragma empty_line
    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale @a add.  If @a base and @a
     *  add are named, this locale instance will also be named.
     *
     *  @param  base  The locale to copy.
     *  @param  add  The locale to use facets from.
     *  @param  cat  Set of categories defining the facets to use from add.
    */
    locale(const locale& __base, const locale& __add, category __cat);
#pragma empty_line
    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs a copy of the locale @a other.  The facet @f is added to
     *  @other, replacing an existing facet of type Facet if there is one.  If
     *  @f is null, this locale is a copy of @a other.
     *
     *  @param  other  The locale to copy.
     *  @param  f  The facet to add in.
    */
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);
#pragma empty_line
    /// Locale destructor.
    ~locale() throw();
#pragma empty_line
    /**
     *  @brief  Assignment operator.
     *
     *  Set this locale to be a copy of @a other.
     *
     *  @param  other  The locale to copy.
     *  @return  A reference to this locale.
    */
    const locale&
    operator=(const locale& __other) throw();
#pragma empty_line
    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs and returns a new copy of this locale.  Adds or replaces an
     *  existing facet of type Facet from the locale @a other into the new
     *  locale.
     *
     *  @param  Facet  The facet type to copy from other
     *  @param  other  The locale to copy from.
     *  @return  Newly constructed locale.
     *  @throw  std::runtime_error if other has no facet of type Facet.
    */
    template<typename _Facet>
      locale
      combine(const locale& __other) const;
#pragma empty_line
    // Locale operations:
    /**
     *  @brief  Return locale name.
     *  @return  Locale name or "*" if unnamed.
    */
    string
    name() const;
#pragma empty_line
    /**
     *  @brief  Locale equality.
     *
     *  @param  other  The locale to compare against.
     *  @return  True if other and this refer to the same locale instance, are
     *		 copies, or have the same name.  False otherwise.
    */
    bool
    operator==(const locale& __other) const throw ();
#pragma empty_line
    /**
     *  @brief  Locale inequality.
     *
     *  @param  other  The locale to compare against.
     *  @return  ! (*this == other)
    */
    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
#pragma empty_line
    /**
     *  @brief  Compare two strings according to collate.
     *
     *  Template operator to compare two strings using the compare function of
     *  the collate facet in this locale.  One use is to provide the locale to
     *  the sort function.  For example, a vector v of strings could be sorted
     *  according to locale loc by doing:
     *  @code
     *  std::sort(v.begin(), v.end(), loc);
     *  @endcode
     *
     *  @param  s1  First string to compare.
     *  @param  s2  Second string to compare.
     *  @return  True if collate<Char> facet compares s1 < s2, else false.
    */
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
#pragma empty_line
    // Global locale objects:
    /**
     *  @brief  Set global locale
     *
     *  This function sets the global locale to the argument and returns a
     *  copy of the previous global locale.  If the argument has a name, it
     *  will also call std::setlocale(LC_ALL, loc.name()).
     *
     *  @param  locale  The new locale to make global.
     *  @return  Copy of the old global locale.
    */
    static locale
    global(const locale&);
#pragma empty_line
    /**
     *  @brief  Return reference to the "C" locale.
    */
    static const locale&
    classic();
#pragma empty_line
  private:
    // The (shared) implementation
    _Impl* _M_impl;
#pragma empty_line
    // The "C" reference locale
    static _Impl* _S_classic;
#pragma empty_line
    // Current global locale
    static _Impl* _S_global;
#pragma empty_line
    // Names of underlying locale categories.
    // NB: locale::global() has to know how to modify all the
    // underlying categories, not just the ones required by the C++
    // standard.
    static const char* const* const _S_categories;
#pragma empty_line
    // Number of standard categories. For C++, these categories are
    // collate, ctype, monetary, numeric, time, and messages. These
    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,
    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE
    // 1003.1-2001) specifies LC_MESSAGES.
    // In addition to the standard categories, the underlying
    // operating system is allowed to define extra LC_*
    // macros. For GNU systems, the following are also valid:
    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,
    // and LC_IDENTIFICATION.
    enum { _S_categories_size = 6 + 0 };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    explicit
    locale(_Impl*) throw();
#pragma empty_line
    static void
    _S_initialize();
#pragma empty_line
    static void
    _S_initialize_once();
#pragma empty_line
    static category
    _S_normalize_category(category);
#pragma empty_line
    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
#pragma empty_line
#pragma empty_line
  // 22.1.1.1.2  Class locale::facet
  /**
   *  @brief  Localization functionality base class.
   *
   *  The facet class is the base class for a localization feature, such as
   *  money, time, and number printing.  It provides common support for facets
   *  and reference management.
   *
   *  Facets may not be copied or assigned.
  */
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;
#pragma empty_line
    mutable _Atomic_word _M_refcount;
#pragma empty_line
    // Contains data from the underlying "C" library for the classic locale.
    static __c_locale _S_c_locale;
#pragma empty_line
    // String literal for the name of the classic locale.
    static const char _S_c_name[2];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static void
    _S_initialize_once();
#pragma empty_line
  protected:
    /**
     *  @brief  Facet constructor.
     *
     *  This is the constructor provided by the standard.  If refs is 0, the
     *  facet is destroyed when the last referencing locale is destroyed.
     *  Otherwise the facet will never be destroyed.
     *
     *  @param refs  The initial value for reference count.
    */
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }
#pragma empty_line
    /// Facet destructor.
    virtual
    ~facet();
#pragma empty_line
    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);
#pragma empty_line
    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);
#pragma empty_line
    static void
    _S_destroy_c_locale(__c_locale& __cloc);
#pragma empty_line
    // Returns data from the underlying "C" library data for the
    // classic locale.
    static __c_locale
    _S_get_c_locale();
#pragma empty_line
    static const char*
    _S_get_c_name();
#pragma empty_line
  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
    inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }
#pragma empty_line
    facet(const facet&); // Not defined.
#pragma empty_line
    facet&
    operator=(const facet&); // Not defined.
  };
#pragma empty_line
#pragma empty_line
  // 22.1.1.1.3 Class locale::id
  /**
   *  @brief  Facet ID class.
   *
   *  The ID class provides facets with an index used to identify them.
   *  Every facet class must define a public static member locale::id, or be
   *  derived from a facet that provides this member, otherwise the facet
   *  cannot be used in a locale.  The locale::id ensures that each class
   *  type gets a unique identifier.
  */
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();
#pragma empty_line
    // NB: There is no accessor for _M_index because it may be used
    // before the constructor is run; the effect of calling a member
    // function (even an inline) would be undefined.
    mutable size_t _M_index;
#pragma empty_line
    // Last id number assigned.
    static _Atomic_word _S_refcount;
#pragma empty_line
    void
    operator=(const id&); // Not defined.
#pragma empty_line
    id(const id&); // Not defined.
#pragma empty_line
  public:
    // NB: This class is always a static data member, and thus can be
    // counted on to be zero-initialized.
    /// Constructor.
    id() { }
#pragma empty_line
    size_t
    _M_id() const;
  };
#pragma empty_line
#pragma empty_line
  // Implementation object for locale.
  class locale::_Impl
  {
  public:
    // Friends.
    friend class locale;
    friend class locale::facet;
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Cache>
      friend struct __use_cache;
#pragma empty_line
  private:
    // Data Members.
    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];
#pragma empty_line
    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
    inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }
#pragma empty_line
    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();
#pragma empty_line
   ~_Impl() throw();
#pragma empty_line
    _Impl(const _Impl&); // Not defined.
#pragma empty_line
    void
    operator=(const _Impl&); // Not defined.
#pragma empty_line
    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
 // We must actually compare all the _M_names: can be all equal!
 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }
#pragma empty_line
    void
    _M_replace_categories(const _Impl*, category);
#pragma empty_line
    void
    _M_replace_category(const _Impl*, const locale::id* const*);
#pragma empty_line
    void
    _M_replace_facet(const _Impl*, const locale::id*);
#pragma empty_line
    void
    _M_install_facet(const locale::id*, const facet*);
#pragma empty_line
    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }
#pragma empty_line
    void
    _M_install_cache(const facet*, size_t);
  };
#pragma empty_line
  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
#pragma empty_line
      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
   ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0; // Unnamed.
    }
#pragma empty_line
}
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // The following definitions of bitmask types are enums, not ints,
  // as permitted (but not required) in the standard, in order to provide
  // better type safety in iostream calls.  A side effect is that
  // expressions involving them are no longer compile-time constants.
  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }
#pragma empty_line
  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }
#pragma empty_line
#pragma empty_line
  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }
#pragma empty_line
  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }
#pragma empty_line
#pragma empty_line
  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }
#pragma empty_line
  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }
#pragma empty_line
  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
#pragma empty_line
  // 27.4.2  Class ios_base
  /**
   *  @brief  The base of the I/O class hierarchy.
   *
   *  This class defines everything that can be defined about I/O that does
   *  not depend on the type of characters being input or output.  Most
   *  people will only see @c ios_base when they need to specify the full
   *  name of the various I/O flags (e.g., the openmodes).
  */
  class ios_base
  {
  public:
#pragma empty_line
    // 27.4.2.1.1  Class ios_base::failure
    /// These are thrown to indicate problems.  Doc me.
    class failure : public exception
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 48.  Use of non-existent exception constructor
      explicit
      failure(const string& __str) throw();
#pragma empty_line
      // This declaration is not useless:
      // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
      virtual
      ~failure() throw();
#pragma empty_line
      virtual const char*
      what() const throw();
#pragma empty_line
    private:
      string _M_msg;
    };
#pragma empty_line
    // 27.4.2.1.2  Type ios_base::fmtflags
    /**
     *  @brief This is a bitmask type.
     *
     *  @c "_Ios_Fmtflags" is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type fmtflags are:
     *  - boolalpha
     *  - dec
     *  - fixed
     *  - hex
     *  - internal
     *  - left
     *  - oct
     *  - right
     *  - scientific
     *  - showbase
     *  - showpoint
     *  - showpos
     *  - skipws
     *  - unitbuf
     *  - uppercase
     *  - adjustfield
     *  - basefield
     *  - floatfield
    */
    typedef _Ios_Fmtflags fmtflags;
#pragma empty_line
    /// Insert/extract @c bool in alphabetic rather than numeric format.
    static const fmtflags boolalpha = _S_boolalpha;
#pragma empty_line
    /// Converts integer input or generates integer output in decimal base.
    static const fmtflags dec = _S_dec;
#pragma empty_line
    /// Generate floating-point output in fixed-point notation.
    static const fmtflags fixed = _S_fixed;
#pragma empty_line
    /// Converts integer input or generates integer output in hexadecimal base.
    static const fmtflags hex = _S_hex;
#pragma empty_line
    /// Adds fill characters at a designated internal point in certain
    /// generated output, or identical to @c right if no such point is
    /// designated.
    static const fmtflags internal = _S_internal;
#pragma empty_line
    /// Adds fill characters on the right (final positions) of certain
    /// generated output.  (I.e., the thing you print is flush left.)
    static const fmtflags left = _S_left;
#pragma empty_line
    /// Converts integer input or generates integer output in octal base.
    static const fmtflags oct = _S_oct;
#pragma empty_line
    /// Adds fill characters on the left (initial positions) of certain
    /// generated output.  (I.e., the thing you print is flush right.)
    static const fmtflags right = _S_right;
#pragma empty_line
    /// Generates floating-point output in scientific notation.
    static const fmtflags scientific = _S_scientific;
#pragma empty_line
    /// Generates a prefix indicating the numeric base of generated integer
    /// output.
    static const fmtflags showbase = _S_showbase;
#pragma empty_line
    /// Generates a decimal-point character unconditionally in generated
    /// floating-point output.
    static const fmtflags showpoint = _S_showpoint;
#pragma empty_line
    /// Generates a + sign in non-negative generated numeric output.
    static const fmtflags showpos = _S_showpos;
#pragma empty_line
    /// Skips leading white space before certain input operations.
    static const fmtflags skipws = _S_skipws;
#pragma empty_line
    /// Flushes output after each output operation.
    static const fmtflags unitbuf = _S_unitbuf;
#pragma empty_line
    /// Replaces certain lowercase letters with their uppercase equivalents
    /// in generated output.
    static const fmtflags uppercase = _S_uppercase;
#pragma empty_line
    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.
    static const fmtflags adjustfield = _S_adjustfield;
#pragma empty_line
    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.
    static const fmtflags basefield = _S_basefield;
#pragma empty_line
    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.
    static const fmtflags floatfield = _S_floatfield;
#pragma empty_line
    // 27.4.2.1.3  Type ios_base::iostate
    /**
     *  @brief This is a bitmask type.
     *
     *  @c "_Ios_Iostate" is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type iostate are:
     *  - badbit
     *  - eofbit
     *  - failbit
     *  - goodbit
    */
    typedef _Ios_Iostate iostate;
#pragma empty_line
    /// Indicates a loss of integrity in an input or output sequence (such
    /// as an irrecoverable read error from a file).
    static const iostate badbit = _S_badbit;
#pragma empty_line
    /// Indicates that an input operation reached the end of an input sequence.
    static const iostate eofbit = _S_eofbit;
#pragma empty_line
    /// Indicates that an input operation failed to read the expected
    /// characters, or that an output operation failed to generate the
    /// desired characters.
    static const iostate failbit = _S_failbit;
#pragma empty_line
    /// Indicates all is well.
    static const iostate goodbit = _S_goodbit;
#pragma empty_line
    // 27.4.2.1.4  Type ios_base::openmode
    /**
     *  @brief This is a bitmask type.
     *
     *  @c "_Ios_Openmode" is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type openmode are:
     *  - app
     *  - ate
     *  - binary
     *  - in
     *  - out
     *  - trunc
    */
    typedef _Ios_Openmode openmode;
#pragma empty_line
    /// Seek to end before each write.
    static const openmode app = _S_app;
#pragma empty_line
    /// Open and seek to end immediately after opening.
    static const openmode ate = _S_ate;
#pragma empty_line
    /// Perform input and output in binary mode (as opposed to text mode).
    /// This is probably not what you think it is; see
    /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#3 and
    /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#7 for more.
    static const openmode binary = _S_bin;
#pragma empty_line
    /// Open for input.  Default for @c ifstream and fstream.
    static const openmode in = _S_in;
#pragma empty_line
    /// Open for output.  Default for @c ofstream and fstream.
    static const openmode out = _S_out;
#pragma empty_line
    /// Open for input.  Default for @c ofstream.
    static const openmode trunc = _S_trunc;
#pragma empty_line
    // 27.4.2.1.5  Type ios_base::seekdir
    /**
     *  @brief This is an enumerated type.
     *
     *  @c "_Ios_Seekdir" is implementation-defined.  Defined values
     *  of type seekdir are:
     *  - beg
     *  - cur, equivalent to @c SEEK_CUR in the C standard library.
     *  - end, equivalent to @c SEEK_END in the C standard library.
    */
    typedef _Ios_Seekdir seekdir;
#pragma empty_line
    /// Request a seek relative to the beginning of the stream.
    static const seekdir beg = _S_beg;
#pragma empty_line
    /// Request a seek relative to the current position within the sequence.
    static const seekdir cur = _S_cur;
#pragma empty_line
    /// Request a seek relative to the current end of the sequence.
    static const seekdir end = _S_end;
#pragma empty_line
    // Annex D.6
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;
#pragma empty_line
    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
#pragma empty_line
    // Callbacks;
    /**
     *  @brief  The set of events that may be passed to an event callback.
     *
     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used
     *  during imbue().  copyfmt_event is used during copyfmt().
    */
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
#pragma empty_line
    /**
     *  @brief  The type of an event callback function.
     *  @param  event  One of the members of the event enum.
     *  @param  ios_base  Reference to the ios_base object.
     *  @param  int  The integer provided when the callback was registered.
     *
     *  Event callbacks are user defined functions that get called during
     *  several ios_base and basic_ios functions, specifically imbue(),
     *  copyfmt(), and ~ios().
    */
    typedef void (*event_callback) (event, ios_base&, int);
#pragma empty_line
    /**
     *  @brief  Add the callback __fn with parameter __index.
     *  @param  __fn  The function to add.
     *  @param  __index  The integer to pass to the function when invoked.
     *
     *  Registers a function as an event callback with an integer parameter to
     *  be passed to the function when invoked.  Multiple copies of the
     *  function are allowed.  If there are multiple callbacks, they are
     *  invoked in the order they were registered.
    */
    void
    register_callback(event_callback __fn, int __index);
#pragma empty_line
  protected:
    //@{
    /**
     *  @if maint
     *  ios_base data members (doc me)
     *  @endif
    */
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;
    //@}
#pragma empty_line
    // 27.4.2.6  Members for callbacks
    // 27.4.2.6  ios_base callbacks
    struct _Callback_list
    {
      // Data Members
      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount; // 0 means one reference.
#pragma empty_line
      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }
#pragma empty_line
      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
      // 0 => OK to delete.
      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };
#pragma empty_line
     _Callback_list* _M_callbacks;
#pragma empty_line
    void
    _M_call_callbacks(event __ev) throw();
#pragma empty_line
    void
    _M_dispose_callbacks(void);
#pragma empty_line
    // 27.4.2.5  Members for iword/pword storage
    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };
#pragma empty_line
    // Only for failed iword/pword calls.
    _Words _M_word_zero;
#pragma empty_line
    // Guaranteed storage.
    // The first 5 iword and pword slots are reserved for internal use.
    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];
#pragma empty_line
    // Allocated storage.
    int _M_word_size;
    _Words* _M_word;
#pragma empty_line
    _Words&
    _M_grow_words(int __index, bool __iword);
#pragma empty_line
    // Members for locale and locale caching.
    locale _M_ios_locale;
#pragma empty_line
    void
    _M_init();
#pragma empty_line
  public:
#pragma empty_line
    // 27.4.2.1.6  Class ios_base::Init
    // Used to initialize standard streams. In theory, g++ could use
    // -finit-priority to order this stuff correctly without going
    // through these machinations.
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();
#pragma empty_line
    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };
#pragma empty_line
    // [27.4.2.2] fmtflags state functions
    /**
     *  @brief  Access to format flags.
     *  @return  The format control flags for both input and output.
    */
    inline fmtflags
    flags() const { return _M_flags; }
#pragma empty_line
    /**
     *  @brief  Setting new format flags all at once.
     *  @param  fmtfl  The new flags to set.
     *  @return  The previous format control flags.
     *
     *  This function overwrites all the format flags with @a fmtfl.
    */
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
#pragma empty_line
    /**
     *  @brief  Setting new format flags.
     *  @param  fmtfl  Additional flags to set.
     *  @return  The previous format control flags.
     *
     *  This function sets additional flags in format control.  Flags that
     *  were previously set remain set.
    */
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
#pragma empty_line
    /**
     *  @brief  Setting new format flags.
     *  @param  fmtfl  Additional flags to set.
     *  @param  mask  The flags mask for @a fmtfl.
     *  @return  The previous format control flags.
     *
     *  This function clears @a mask in the format flags, then sets
     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.
    */
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }
#pragma empty_line
    /**
     *  @brief  Clearing format flags.
     *  @param  mask  The flags to unset.
     *
     *  This function clears @a mask in the format flags.
    */
    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
#pragma empty_line
    /**
     *  @brief  Flags access.
     *  @return  The precision to generate on certain output operations.
     *
     *  @if maint
     *  Be careful if you try to give a definition of "precision" here; see
     *  DR 189.
     *  @endif
    */
    inline streamsize
    precision() const { return _M_precision; }
#pragma empty_line
    /**
     *  @brief  Changing flags.
     *  @param  prec  The new precision value.
     *  @return  The previous value of precision().
    */
    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }
#pragma empty_line
    /**
     *  @brief  Flags access.
     *  @return  The minimum field width to generate on output operations.
     *
     *  "Minimum field width" refers to the number of characters.
    */
    inline streamsize
    width() const { return _M_width; }
#pragma empty_line
    /**
     *  @brief  Changing flags.
     *  @param  wide  The new width value.
     *  @return  The previous value of width().
    */
    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
#pragma empty_line
    // [27.4.2.4] ios_base static members
    /**
     *  @brief  Interaction with the standard C I/O objects.
     *  @param  sync  Whether to synchronize or not.
     *  @return  True if the standard streams were previously synchronized.
     *
     *  The synchronization referred to is @e only that between the standard
     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,
     *  cout).  User-declared streams are unaffected.  See
     *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#8 for more.
    */
    static bool
    sync_with_stdio(bool __sync = true);
#pragma empty_line
    // [27.4.2.3] ios_base locale functions
    /**
     *  @brief  Setting a new locale.
     *  @param  loc  The new locale.
     *  @return  The previous locale.
     *
     *  Sets the new locale for this stream, and then invokes each callback
     *  with imbue_event.
    */
    locale
    imbue(const locale& __loc);
#pragma empty_line
    /**
     *  @brief  Locale access
     *  @return  A copy of the current locale.
     *
     *  If @c imbue(loc) has previously been called, then this function
     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),
     *  the global C++ locale.
    */
    inline locale
    getloc() const { return _M_ios_locale; }
#pragma empty_line
    /**
     *  @brief  Locale access
     *  @return  A reference to the current locale.
     *
     *  Like getloc above, but returns a reference instead of
     *  generating a copy.
    */
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
#pragma empty_line
    // [27.4.2.5] ios_base storage functions
    /**
     *  @brief  Access to unique indices.
     *  @return  An integer different from all previous calls.
     *
     *  This function returns a unique integer every time it is called.  It
     *  can be used for any purpose, but is primarily intended to be a unique
     *  index for the iword and pword functions.  The expectation is that an
     *  application calls xalloc in order to obtain an index in the iword and
     *  pword arrays that can be used without fear of conflict.
     *
     *  The implementation maintains a static variable that is incremented and
     *  returned on each invocation.  xalloc is guaranteed to return an index
     *  that is safe to use in the iword and pword arrays.
    */
    static int
    xalloc() throw();
#pragma empty_line
    /**
     *  @brief  Access to integer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to an integer associated with the index.
     *
     *  The iword function provides access to an array of integers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All integers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
#pragma empty_line
    /**
     *  @brief  Access to void pointer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to a void* associated with the index.
     *
     *  The pword function provides access to an array of pointers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All pointers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
#pragma empty_line
    // Destructor
    /**
     *  Invokes each callback with erase_event.  Destroys local storage.
     *
     *  Note that the ios_base object for the standard streams never gets
     *  destroyed.  As a result, any callbacks registered with the standard
     *  streams will not get invoked with erase_event (unless copyfmt is
     *  used).
    */
    virtual ~ios_base();
#pragma empty_line
  protected:
    ios_base();
#pragma empty_line
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 50.  Copy constructor and assignment operator of ios_base
  private:
    ios_base(const ios_base&);
#pragma empty_line
    ios_base&
    operator=(const ios_base&);
  };
#pragma empty_line
  // [27.4.5.1] fmtflags manipulators
  /// Calls base.setf(ios_base::boolalpha).
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::boolalpha).
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::showbase).
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::showbase).
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::showpoint).
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::showpoint).
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::showpos).
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::showpos).
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::skipws).
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::skipws).
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::uppercase).
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::uppercase).
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::unitbuf).
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }
#pragma empty_line
  /// Calls base.unsetf(ios_base::unitbuf).
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }
#pragma empty_line
  // [27.4.5.2] adjustfield anipulators
  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::left, ios_base::adjustfield).
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::right, ios_base::adjustfield).
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }
#pragma empty_line
  // [27.4.5.3] basefield anipulators
  /// Calls base.setf(ios_base::dec, ios_base::basefield).
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::hex, ios_base::basefield).
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::oct, ios_base::basefield).
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }
#pragma empty_line
  // [27.4.5.4] floatfield anipulators
  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }
#pragma empty_line
  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
#pragma empty_line
}
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 1 3
// Stream buffer classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.5  Stream buffers
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ios_base.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4  Iostreams base classes
//
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 1 3
// -*- C++ -*-
#pragma empty_line
// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later
// version.
#pragma empty_line
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free
// software library without restriction.  Specifically, if other files
// instantiate templates or use macros or inline functions from this
// file, or you compile this file and link it with other files to
// produce an executable, this file does not by itself cause the
// resulting executable to be covered by the GNU General Public
// License.  This exception does not however invalidate any other
// reasons why the executable file might be covered by the GNU General
// Public License.
#pragma empty_line
/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @if maint
   *  Does stuff.
   *  @endif
  */
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
#pragma empty_line
  /**
   *  @brief  The actual work of input and output (interface).
   *
   *  This is a base class.  Derived stream buffers each control a
   *  pair of character sequences:  one for input, and one for output.
   *
   *  Section [27.5.1] of the standard describes the requirements and
   *  behavior of stream buffer classes.  That section (three paragraphs)
   *  is reproduced here, for simplicity and accuracy.
   *
   *  -# Stream buffers can impose various constraints on the sequences
   *     they control.  Some constraints are:
   *     - The controlled input sequence can be not readable.
   *     - The controlled output sequence can be not writable.
   *     - The controlled sequences can be associated with the contents of
   *       other representations for character sequences, such as external
   *       files.
   *     - The controlled sequences can support operations @e directly to or
   *       from associated sequences.
   *     - The controlled sequences can impose limitations on how the
   *       program can read characters from a sequence, write characters to
   *       a sequence, put characters back into an input sequence, or alter
   *       the stream position.
   *     .
   *  -# Each sequence is characterized by three pointers which, if non-null,
   *     all point into the same @c charT array object.  The array object
   *     represents, at any moment, a (sub)sequence of characters from the
   *     sequence.  Operations performed on a sequence alter the values
   *     stored in these pointers, perform reads and writes directly to or
   *     from associated sequences, and alter "the stream position" and
   *     conversion state as needed to maintain this subsequence relationship.
   *     The three pointers are:
   *     - the <em>beginning pointer</em>, or lowest element address in the
   *       array (called @e xbeg here);
   *     - the <em>next pointer</em>, or next element address that is a
   *       current candidate for reading or writing (called @e xnext here);
   *     - the <em>end pointer</em>, or first element address beyond the
   *       end of the array (called @e xend here).
   *     .
   *  -# The following semantic constraints shall always apply for any set
   *     of three pointers for a sequence, using the pointer names given
   *     immediately above:
   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall
   *       also be non-null pointers into the same @c charT array, as
   *       described above; otherwise, @e xbeg and @e xend shall also be null.
   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an
   *       output sequence, then a <em>write position</em> is available.
   *       In this case, @e *xnext shall be assignable as the next element
   *       to write (to put, or to store a character value, into the sequence).
   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an
   *       input sequence, then a <em>putback position</em> is available.
   *       In this case, @e xnext[-1] shall have a defined value and is the
   *       next (preceding) element to store a character that is put back
   *       into the input sequence.
   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an
   *       input sequence, then a <em>read position</em> is available.
   *       In this case, @e *xnext shall have a defined value and is the
   *       next element to read (to get, or to obtain a character value,
   *       from the sequence).
  */
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependant on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      //@}
#pragma empty_line
      //@{
      /**
       *  @if maint
       *  This is a non-standard type.
       *  @endif
      */
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      //@}
#pragma empty_line
      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;
#pragma empty_line
      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);
#pragma empty_line
      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_aux(istreambuf_iterator<_CharT2>,
     istreambuf_iterator<_CharT2>, _CharT2*);
#pragma empty_line
      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
#pragma empty_line
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
#pragma empty_line
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);
#pragma empty_line
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);
#pragma empty_line
    protected:
      //@{
      /**
       *  @if maint
       *  This is based on _IO_FILE, just reordered to be more consistent,
       *  and is intended to be the most minimal abstraction for an
       *  internal buffer.
       *  -  get == input == read
       *  -  put == output == write
       *  @endif
      */
      char_type* _M_in_beg; // Start of get area. 
      char_type* _M_in_cur; // Current read area. 
      char_type* _M_in_end; // End of get area. 
      char_type* _M_out_beg; // Start of put area. 
      char_type* _M_out_cur; // Current put area. 
      char_type* _M_out_end; // End of put area.
#pragma empty_line
      /**
       *  @if maint
       *  Current locale setting.
       *  @endif
      */
      locale _M_buf_locale;
#pragma empty_line
  public:
      /// Destructor deallocates no buffer space.
      virtual
      ~basic_streambuf()
      { }
#pragma empty_line
      // [27.5.2.2.1] locales
      /**
       *  @brief  Entry point for imbue().
       *  @param  loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls the derived imbue(loc).
      */
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
#pragma empty_line
      /**
       *  @brief  Locale access.
       *  @return  The current locale in effect.
       *
       *  If pubimbue(loc) has been called, then the most recent @c loc
       *  is returned.  Otherwise the global locale in effect at the time
       *  of construction is returned.
      */
      locale
      getloc() const
      { return _M_buf_locale; }
#pragma empty_line
      // [27.5.2.2.2] buffer management and positioning
      //@{
      /**
       *  @brief  Entry points for derived buffer functions.
       *
       *  The public versions of @c pubfoo dispatch to the protected
       *  derived @c foo member functions, passing the arguments (if any)
       *  and returning the result unchanged.
      */
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
#pragma empty_line
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
#pragma empty_line
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }
#pragma empty_line
      int
      pubsync() { return this->sync(); }
      //@}
#pragma empty_line
      // [27.5.2.2.3] get area
      /**
       *  @brief  Looking ahead into the stream.
       *  @return  The number of characters available.
       *
       *  If a read position is available, returns the number of characters
       *  available for reading before the buffer must be refilled.
       *  Otherwise returns the derived @c showmanyc().
      */
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
#pragma empty_line
      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  Calls @c sbumpc(), and if that function returns
       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().
      */
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
#pragma empty_line
      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character
       *  and increments the read pointer, otherwise calls and returns
       *  @c uflow().
      */
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
#pragma empty_line
      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character,
       *  otherwise calls and returns @c underflow().  Does not move the 
       *  read position after fetching the character.
      */
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
#pragma empty_line
      /**
       *  @brief  Entry point for xsgetn.
       *  @param  s  A buffer area.
       *  @param  n  A count.
       *
       *  Returns xsgetn(s,n).  The effect is to fill @a s[0] through
       *  @a s[n-1] with characters from the input sequence, if possible.
      */
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
#pragma empty_line
      // [27.5.2.2.4] putback
      /**
       *  @brief  Pushing characters back into the input stream.
       *  @param  c  The character to push back.
       *  @return  The previous character, if possible.
       *
       *  Similar to sungetc(), but @a c is pushed onto the stream instead
       *  of "the previous character".  If successful, the next character
       *  fetched from the input stream will be @a c.
      */
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
#pragma empty_line
      /**
       *  @brief  Moving backwards in the input stream.
       *  @return  The previous character, if possible.
       *
       *  If a putback position is available, this function decrements the
       *  input pointer and returns that character.  Otherwise, calls and
       *  returns pbackfail().  The effect is to "unget" the last character
       *  "gotten".
      */
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
#pragma empty_line
      // [27.5.2.2.5] put area
      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  c  A character to output.
       *  @return  @a c, if possible.
       *
       *  One of two public output functions.
       *
       *  If a write position is available for the output sequence (i.e.,
       *  the buffer is not full), stores @a c in that position, increments
       *  the position, and returns @c traits::to_int_type(c).  If a write
       *  position is not available, returns @c overflow(c).
      */
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
#pragma empty_line
      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  s  A buffer read area.
       *  @param  n  A count.
       *
       *  One of two public output functions.
       *
       *
       *  Returns xsputn(s,n).  The effect is to write @a s[0] through
       *  @a s[n-1] to the output sequence, if possible.
      */
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }
#pragma empty_line
    protected:
      /**
       *  @brief  Base constructor.
       *
       *  Only called from derived constructors, and sets up all the
       *  buffer data to zero, including the pointers described in the
       *  basic_streambuf class description.  Note that, as a result,
       *  - the class starts with no read nor write positions available,
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
#pragma empty_line
      // [27.5.2.3.1] get area access
      //@{
      /**
       *  @brief  Access to the get area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - eback() returns the beginning pointer for the input sequence
       *  - gptr() returns the next pointer for the input sequence
       *  - egptr() returns the end pointer for the input sequence
      */
      char_type*
      eback() const { return _M_in_beg; }
#pragma empty_line
      char_type*
      gptr() const { return _M_in_cur; }
#pragma empty_line
      char_type*
      egptr() const { return _M_in_end; }
      //@}
#pragma empty_line
      /**
       *  @brief  Moving the read position.
       *  @param  n  The delta by which to move.
       *
       *  This just advances the read position without returning any data.
      */
      void
      gbump(int __n) { _M_in_cur += __n; }
#pragma empty_line
      /**
       *  @brief  Setting the three read area pointers.
       *  @param  gbeg  A pointer.
       *  @param  gnext  A pointer.
       *  @param  gend  A pointer.
       *  @post  @a gbeg == @c eback(), @a gnext == @c gptr(), and
       *         @a gend == @c egptr()
      */
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
#pragma empty_line
      // [27.5.2.3.2] put area access
      //@{
      /**
       *  @brief  Access to the put area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - pbase() returns the beginning pointer for the output sequence
       *  - pptr() returns the next pointer for the output sequence
       *  - epptr() returns the end pointer for the output sequence
      */
      char_type*
      pbase() const { return _M_out_beg; }
#pragma empty_line
      char_type*
      pptr() const { return _M_out_cur; }
#pragma empty_line
      char_type*
      epptr() const { return _M_out_end; }
      //@}
#pragma empty_line
      /**
       *  @brief  Moving the write position.
       *  @param  n  The delta by which to move.
       *
       *  This just advances the write position without returning any data.
      */
      void
      pbump(int __n) { _M_out_cur += __n; }
#pragma empty_line
      /**
       *  @brief  Setting the three write area pointers.
       *  @param  pbeg  A pointer.
       *  @param  pend  A pointer.
       *  @post  @a pbeg == @c pbase(), @a pbeg == @c pptr(), and
       *         @a pend == @c epptr()
      */
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
#pragma empty_line
      // [27.5.2.4] virtual functions
      // [27.5.2.4.1] locales
      /**
       *  @brief  Changes translations.
       *  @param  loc  A new locale.
       *
       *  Translations done during I/O which depend on the current locale
       *  are changed by this call.  The standard adds, "Between invocations
       *  of this function a class derived from streambuf can safely cache
       *  results of calls to locale functions and to members of facets
       *  so obtained."
       *
       *  @note  Base class version does nothing.
      */
      virtual void
      imbue(const locale&)
      { }
#pragma empty_line
      // [27.5.2.4.2] buffer management and positioning
      /**
       *  @brief  Maniuplates the buffer.
       *
       *  Each derived class provides its own appropriate behavior.  See
       *  the next-to-last paragraph of 
       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2 for
       *  more on this function.
       *
       *  @note  Base class version does nothing, returns @c this.
      */
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
#pragma empty_line
      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#pragma empty_line
      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#pragma empty_line
      /**
       *  @brief  Synchronizes the buffer arrays with the controlled sequences.
       *  @return  -1 on failure.
       *
       *  Each derived class provides its own appropriate behavior,
       *  including the definition of "failure".
       *  @note  Base class version does nothing, returns zero.
      */
      virtual int
      sync() { return 0; }
#pragma empty_line
      // [27.5.2.4.3] get area
      /**
       *  @brief  Investigating the data available.
       *  @return  An estimate of the number of characters available in the
       *           input sequence, or -1.
       *
       *  "If it returns a positive value, then successive calls to
       *  @c underflow() will not return @c traits::eof() until at least that
       *  number of characters have been supplied.  If @c showmanyc()
       *  returns -1, then calls to @c underflow() or @c uflow() will fail."
       *  [27.5.2.4.3]/1
       *
       *  @note  Base class version does nothing, returns zero.
       *  @note  The standard adds that "the intention is not only that the
       *         calls [to underflow or uflow] will not return @c eof() but
       *         that they will return "immediately".
       *  @note  The standard adds that "the morphemes of @c showmanyc are
       *         "es-how-many-see", not "show-manic".
      */
      virtual streamsize
      showmanyc() { return 0; }
#pragma empty_line
      /**
       *  @brief  Multiple character extraction.
       *  @param  s  A buffer area.
       *  @param  n  Maximum number of characters to assign.
       *  @return  The number of characters assigned.
       *
       *  Fills @a s[0] through @a s[n-1] with characters from the input
       *  sequence, as if by @c sbumpc().  Stops when either @a n characters
       *  have been copied, or when @c traits::eof() would be copied.
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
#pragma empty_line
      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function is called when the input buffer is
       *  exhausted (or does not exist, as buffering need not actually be
       *  done).  If a buffer exists, it is "refilled".  In either case, the
       *  next available character is returned, or @c traits::eof() to
       *  indicate a null pending sequence.
       *
       *  For a formal definiton of the pending sequence, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.
       *
       *  A functioning input streambuf can be created by overriding only
       *  this function (no buffer area will be used).  For an example, see
       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#6
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      underflow()
      { return traits_type::eof(); }
#pragma empty_line
      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function does the same thing as @c underflow(),
       *  and in fact is required to call that function.  It also returns
       *  the new character, like @c underflow() does.  However, this
       *  function also moves the read position forward by one.
      */
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
#pragma empty_line
      // [27.5.2.4.4] putback
      /**
       *  @brief  Tries to back up the input sequence.
       *  @param  c  The character to be inserted back into the sequence.
       *  @return  eof() on failure, "some other value" on success
       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()
       *         are the same as for @c underflow().
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      pbackfail(int_type /* __c */ = traits_type::eof())
      { return traits_type::eof(); }
#pragma empty_line
      // Put area:
      /**
       *  @brief  Multiple character insertion.
       *  @param  s  A buffer area.
       *  @param  n  Maximum number of characters to write.
       *  @return  The number of characters written.
       *
       *  Writes @a s[0] through @a s[n-1] to the output sequence, as if
       *  by @c sputc().  Stops when either @a n characters have been
       *  copied, or when @c sputc() would return @c traits::eof().
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
#pragma empty_line
      /**
       *  @brief  Consumes data from the buffer; writes to the
       *          controlled sequence.
       *  @param  c  An additional character to consume.
       *  @return  eof() to indicate failure, something else (usually
       *           @a c, or not_eof())
       *
       *  Informally, this function is called when the output buffer is full
       *  (or does not exist, as buffering need not actually be done).  If a
       *  buffer exists, it is "consumed", with "some effect" on the
       *  controlled sequence.  (Typically, the buffer is written out to the
       *  sequence verbatim.)  In either case, the character @a c is also
       *  written out, if @a c is not @c eof().
       *
       *  For a formal definiton of this function, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.
       *
       *  A functioning output streambuf can be created by overriding only
       *  this function (no buffer area will be used).
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      overflow(int_type /* __c */ = traits_type::eof())
      { return traits_type::eof(); }
#pragma line 791 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 3
    private:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // Side effect of DR 50. 
      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }
#pragma empty_line
      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
#pragma empty_line
  // Explicit specialization declarations, defined in src/streambuf.cc.
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);
#pragma empty_line
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf.tcc" 1 3
// Stream buffer classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.5  Stream buffers
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf.tcc" 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }
#pragma empty_line
   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }
#pragma empty_line
   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }
#pragma empty_line
  // Conceivably, this could be used to implement buffer-to-buffer
  // copies, if this was ever desired in an un-ambiguous way by the
  // standard.
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB:  This syntax is a GNU extension.
#pragma empty_line
  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);
#pragma empty_line
#pragma empty_line
  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 821 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 2 3
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file basic_ios.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf_iterator.h" 1 3
// Streambuf iterators
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf_iterator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf_iterator.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 1 3
// Stream buffer classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.5  Stream buffers
//
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf_iterator.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-
#pragma empty_line
// Copyright (C) 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf_iterator.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 24.5.3 Template class istreambuf_iterator
  /// Provides input iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
      //@}
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_aux(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
     _CharT2*);
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
#pragma empty_line
    private:
      // 24.5.3 istreambuf_iterator
      // p 1
      // If the end of stream is reached (streambuf_type::sgetc()
      // returns traits_type::eof()), the iterator becomes equal to
      // the "end of stream" iterator value.
      // NB: This implementation assumes the "end of stream" value
      // is EOF, or -1.
      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;
#pragma empty_line
    public:
      ///  Construct end of input stream iterator.
      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
#pragma empty_line
      ///  Construct start of input stream iterator.
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }
#pragma empty_line
      ///  Construct start of streambuf iterator.
      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }
#pragma empty_line
      ///  Return the current character pointed to by iterator.  This returns
      ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of
      ///  operator*() on an end of stream is undefined.
      char_type
      operator*() const
      {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 return traits_type::to_char_type(_M_get());
      }
#pragma empty_line
      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator&
      operator++()
      {
 ;
#pragma empty_line
#pragma empty_line
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }
#pragma empty_line
      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator
      operator++(int)
      {
 ;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }
#pragma empty_line
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 110 istreambuf_iterator::equal not const
      // NB: there is also number 111 (NAD, Future) pending on this function.
      /// Return true both iterators are end or both are not end.
      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }
#pragma empty_line
    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }
#pragma empty_line
      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }
#pragma empty_line
  /// Provides output iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
      //@}
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
#pragma empty_line
    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;
#pragma empty_line
    public:
      ///  Construct output iterator from ostream.
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }
#pragma empty_line
      ///  Construct output iterator from streambuf.
      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }
#pragma empty_line
      ///  Write character to streambuf.  Calls streambuf.sputc().
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }
#pragma empty_line
      /// Return *this.
      ostreambuf_iterator&
      operator*()
      { return *this; }
#pragma empty_line
      /// Return *this.
      ostreambuf_iterator&
      operator++(int)
      { return *this; }
#pragma empty_line
      /// Return *this.
      ostreambuf_iterator&
      operator++()
      { return *this; }
#pragma empty_line
      /// Return true if previous operator=() failed.
      bool
      failed() const throw()
      { return _M_failed; }
#pragma empty_line
      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
#pragma empty_line
  // Overloads for streambuf iterators.
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT* __first, _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT* __first, const _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT> __first,
        istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
#pragma empty_line
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
#pragma empty_line
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }
#pragma empty_line
   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }
#pragma empty_line
}
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_classes.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ctime" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/ctime
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c time.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: 20.5  Date and time
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwctype" 1 3
// -*- C++ -*- forwarding header.
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/cwctype
 *  This is a Standard C++ Library file.  You should @c #include this file
 *  in your programs, rather than any of the "*.h" implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */
#pragma empty_line
//
// ISO C++ 14882: <cwctype>
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwctype" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file c++config.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwctype" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/wctype.h" 1 3
/* 
 * wctype.h
 *
 * Functions for testing wide character types and converting characters.
 *
 * This file is part of the Mingw32 package.
 *
 * Contributors:
 *  Created by Mumit Khan <khan@xraylith.wisc.edu>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#pragma line 54 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwctype" 2 3
#pragma empty_line
#pragma empty_line
// Get rid of those macros defined in <wctype.h> in lieu of real functions.
#pragma line 80 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/cwctype" 3
namespace std {
#pragma empty_line
  using ::wint_t; // cwchar
#pragma empty_line
  using ::wctype_t;
  using ::wctrans_t;
#pragma empty_line
  using ::iswalnum;
  using ::iswalpha;
#pragma empty_line
  using ::iswblank;
#pragma empty_line
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
#pragma empty_line
}
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/ctype_base.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
// Information, as gleaned from /mingw32/include/ctype.h.
#pragma empty_line
namespace std {
#pragma empty_line
  /// @brief  Base class for ctype.
  struct ctype_base
  {
    // Non-standard typedefs.
    typedef const int* __to_type;
#pragma empty_line
    // NB: Offsets into ctype<char>::_M_table force a particular size
    // on the mask type. Because of this, we don't use an enum.
    typedef unsigned short mask;
    static const mask upper = 0x0001;
    static const mask lower = 0x0002;
    static const mask alpha = 0x0103;
    static const mask digit = 0x0004;
    static const mask xdigit = 0x0080;
    static const mask space = 0x0008;
    static const mask print = (0x0040 | 0x0010| 0x0103 | 0x0004);
    static const mask graph = (0x0010 | 0x0103 | 0x0004);
    static const mask cntrl = 0x0020;
    static const mask punct = 0x0010;
    static const mask alnum = (0x0103 | 0x0004);
  };
#pragma empty_line
}
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file iosfwd
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.2  Forward declarations
//
#pragma line 49 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ios_base.h" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ios_base.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4  Iostreams base classes
//
#pragma line 50 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/streambuf" 1 3
// Stream buffer classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.5  Stream buffers
//
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
#pragma line 52 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // NB: Don't instantiate required wchar_t facets if no wchar_t support.
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  // Convert string to numeric value of type _Tv and store results.
  // NB: This is specialized for all required types, there is no
  // generic definition.
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);
#pragma empty_line
  // Explicit specializations for required types.
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);
#pragma empty_line
  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);
#pragma empty_line
  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);
#pragma empty_line
  // NB: __pad is a struct, rather than a function, so it can be
  // partially-specialized.
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };
#pragma empty_line
  // Used by both numeric and monetary facets.
  // Inserts "group separator" characters into an array of characters.
  // It's recursive, one iteration per group.  It moves the characters
  // in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this
  // only with __glen != 0.
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);
#pragma empty_line
  // This template permits specializing facet output code for
  // ostreambuf_iterator.  For ostreambuf_iterator, sputn is
  // significantly more efficient than incrementing iterators.
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }
#pragma empty_line
  // This is the unspecialized form of the template.
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
#pragma empty_line
#pragma empty_line
  // 22.2.1.1  Template class ctype
  // Include host and configuration specific ctype enums for ctype_base.
#pragma empty_line
  // Common base for ctype<_CharT>.
  /**
   *  @brief  Common base for ctype facet
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abtract stubs for the protected virtual
   *  functions.
  */
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter
      typedef _CharT char_type;
#pragma empty_line
      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *  It does so by returning the value of ctype<char_type>::do_is().
       *
       *  @param c  The char_type to compare the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
#pragma empty_line
      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the char array.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
#pragma empty_line
      /**
       *  @brief  Find char_type matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.  It does so by returning
       *  ctype<char_type>::do_scan_is().
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to matching char_type if found, else @a hi.
      */
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Find char_type not matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is false.  It does so by returning
       *  ctype<char_type>::do_scan_not().
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to non-matching char if found, else @a hi.
      */
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.  It does
       *  so by returning ctype<char_type>::do_toupper().
       *
       *  @param c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#pragma empty_line
      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_toupper(lo, hi).
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the argument to lowercase if possible.  If
       *  not possible (for example, '2'), returns the argument.  It does so
       *  by returning ctype<char_type>::do_tolower(c).
       *
       *  @param c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#pragma empty_line
      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_tolower(lo, hi).
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Widen char to char_type
       *
       *  This function converts the char argument to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted char_type.
      */
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
#pragma empty_line
      /**
       *  @brief  Widen array to char_type
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
#pragma empty_line
      /**
       *  @brief  Narrow char_type to char
       *
       *  This function converts the char_type to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  It does so by returning
       *  ctype<char_type>::do_narrow(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char_type to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
#pragma empty_line
      /**
       *  @brief  Narrow array to char array
       *
       *  This function converts each char_type in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char_type in the input that cannot be
       *  converted, @a dfault is used instead.  It does so by returning
       *  ctype<char_type>::do_narrow(lo, hi, dfault, to).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }
#pragma empty_line
    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }
#pragma empty_line
      virtual
      ~__ctype_abstract_base() { }
#pragma empty_line
      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param c  The char_type to find the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
#pragma empty_line
      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
#pragma empty_line
      /**
       *  @brief  Find char_type matching mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching char_type if found, else @a hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
#pragma empty_line
      /**
       *  @brief  Find char_type not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  char_type c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char_type if found, else @a hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
#pragma empty_line
      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char_type argument to uppercase
       *  if possible.  If not possible (for example, '2'), returns the
       *  argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const = 0;
#pragma empty_line
      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char_type in the range [lo,hi)
       *  to uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
#pragma empty_line
      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const = 0;
#pragma empty_line
      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char_type in the range [lo,hi)
       *  to lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
#pragma empty_line
      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted char_type
      */
      virtual char_type
      do_widen(char) const = 0;
#pragma empty_line
      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
#pragma empty_line
      /**
       *  @brief  Narrow char_type to char
       *
       *  This virtual function converts the argument to char using the
       *  simplest reasonable transformation.  If the conversion fails, dfault
       *  is returned instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char_type to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
#pragma empty_line
      /**
       *  @brief  Narrow char_type array to char
       *
       *  This virtual function converts each char_type in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any element in the input that
       *  cannot be converted, @a dfault is used instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
#pragma empty_line
  // NB: Generic, mostly useless implementation.
  /**
   *  @brief  Template ctype facet
   *
   *  This template class defines classification and conversion functions for
   *  character sets.  It wraps <cctype> functionality.  Ctype gets used by
   *  streams for many I/O operations.
   *
   *  This template provides the protected virtual functions the developer
   *  will have to replace in a derived class or specialization to make a
   *  working facet.  The public functions that access them are defined in
   *  __ctype_abstract_base, to allow for implementation flexibility.  See
   *  ctype<wchar_t> for an example.  The functions are documented in
   *  __ctype_abstract_base.
   *
   *  Note: implementations are provided for all the protected virtual
   *  functions, but will likely not be useful.
  */
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
      // Types:
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;
#pragma empty_line
      /// The facet id for ctype<char_type>
      static locale::id id;
#pragma empty_line
      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }
#pragma empty_line
   protected:
      virtual
      ~ctype();
#pragma empty_line
      virtual bool
      do_is(mask __m, char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#pragma empty_line
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_toupper(char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_tolower(char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_widen(char __c) const;
#pragma empty_line
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#pragma empty_line
      virtual char
      do_narrow(char_type, char __dfault) const;
#pragma empty_line
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };
#pragma empty_line
  template<typename _CharT>
    locale::id ctype<_CharT>::id;
#pragma empty_line
  // 22.2.1.3  ctype<char> specialization.
  /**
   *  @brief  The ctype<char> specialization.
   *
   *  This class defines classification and conversion functions for
   *  the char type.  It gets used by char streams for many I/O
   *  operations.  The char specialization provides a number of
   *  optimizations as well.
  */
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter char.
      typedef char char_type;
#pragma empty_line
    protected:
      // Data Members:
      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok; // 0 uninitialized, 1 init,
      // 2 memcpy can't be used
#pragma empty_line
    public:
      /// The facet id for ctype<char>
      static locale::id id;
      /// The size of the mask table.  It is SCHAR_MAX + 1.
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param table If non-zero, table is used as the per-char mask.
       *               Else classic_table() is used.
       *  @param del   If true, passes ownership of table to this facet.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
#pragma empty_line
      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param cloc  Handle to C locale data.
       *  @param table If non-zero, table is used as the per-char mask.
       *  @param del   If true, passes ownership of table to this facet.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
#pragma empty_line
      /**
       *  @brief  Test char classification.
       *
       *  This function compares the mask table[c] to @a m.
       *
       *  @param c  The char to compare the mask of.
       *  @param m  The mask to compare against.
       *  @return  True if m & table[c] is true, false otherwise.
      */
      inline bool
      is(mask __m, char __c) const;
#pragma empty_line
      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char in the range [lo, hi) and
       *  successively writes it to vec.  vec must have as many elements as
       *  the char array.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
#pragma empty_line
      /**
       *  @brief  Find char matching a mask
       *
       *  This function searches for and returns the first char in [lo,hi) for
       *  which is(m,char) is true.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching char if found, else @a hi.
      */
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
#pragma empty_line
      /**
       *  @brief  Find char not matching a mask
       *
       *  This function searches for and returns a pointer to the first char
       *  in [lo,hi) for which is(m,char) is false.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char if found, else @a hi.
      */
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
#pragma empty_line
      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the char argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  toupper() acts as if it returns ctype<char>::do_toupper(c).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param c  The char to convert.
       *  @return  The uppercase char if convertible, else @a c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#pragma empty_line
      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char in the range [lo,hi) to uppercase
       *  if possible.  Other chars remain untouched.
       *
       *  toupper() acts as if it returns ctype<char>:: do_toupper(lo, hi).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the char argument to lowercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  tolower() acts as if it returns ctype<char>::do_tolower(c).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param c  The char to convert.
       *  @return  The lowercase char if convertible, else @a c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#pragma empty_line
      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char in the range [lo,hi) to lowercase
       *  if possible.  Other chars remain untouched.
       *
       *  tolower() acts as if it returns ctype<char>:: do_tolower(lo, hi).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Widen char
       *
       *  This function converts the char to char_type using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
#pragma empty_line
      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
#pragma empty_line
      /**
       *  @brief  Narrow char
       *
       *  This function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c
       *  will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(c).
       *  do_narrow() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted character.
      */
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
#pragma empty_line
      /**
       *  @brief  Narrow char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char in the input that cannot be
       *  converted, @a dfault is used instead.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
       *  dfault, to).  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }
#pragma empty_line
    protected:
      /// Returns a pointer to the mask table provided to the constructor, or
      /// the default from classic_table() if none was provided.
      const mask*
      table() const throw()
      { return _M_table; }
#pragma empty_line
      /// Returns a pointer to the C locale mask table.
      static const mask*
      classic_table() throw();
#pragma empty_line
      /**
       *  @brief  Destructor.
       *
       *  This function deletes table() if @a del was true in the
       *  constructor.
      */
      virtual
      ~ctype();
#pragma empty_line
      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The char to convert.
       *  @return  The uppercase char if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const;
#pragma empty_line
      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  uppercase if possible.  Other chars remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the char argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The char to convert.
       *  @return  The lowercase char if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const;
#pragma empty_line
      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  lowercase if possible.  Other chars remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted character.
      */
      virtual char_type
      do_widen(char __c) const
      { return __c; }
#pragma empty_line
      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the range [lo,hi) to char using
       *  the simplest reasonable transformation.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#pragma empty_line
      /**
       *  @brief  Narrow char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c will be
       *  returned unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
#pragma empty_line
      /**
       *  @brief  Narrow char array to char array
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any char in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#pragma empty_line
    private:
#pragma empty_line
      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);
#pragma empty_line
 _M_widen_ok = 1;
 // Set _M_widen_ok to 2 if memcpy can't be used.
 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }
#pragma empty_line
      // Fill in the narrowing cache and flag whether all values are
      // valid or not.  _M_narrow_ok is set to 2 if memcpy can't
      // be used.
      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);
#pragma empty_line
 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {
     // Deal with the special case of zero: renarrow with a
     // different default and compare.
     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };
#pragma empty_line
  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
#pragma empty_line
#pragma empty_line
  // 22.2.1.3  ctype<wchar_t> specialization
  /**
   *  @brief  The ctype<wchar_t> specialization.
   *
   *  This class defines classification and conversion functions for the
   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
   *  The wchar_t specialization provides a number of optimizations as well.
   *
   *  ctype<wchar_t> inherits its public methods from
   *  __ctype_abstract_base<wchar_t>.
  */
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
      // Types:
      /// Typedef for the template parameter wchar_t.
      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;
#pragma empty_line
    protected:
      __c_locale _M_c_locale_ctype;
#pragma empty_line
      // Pre-computed narrowed and widened chars.
      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];
#pragma empty_line
      // Pre-computed elements for do_is.
      mask _M_bit[16];
      __wmask_type _M_wmask[16];
#pragma empty_line
    public:
      // Data Members:
      /// The facet id for ctype<wchar_t>
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(size_t __refs = 0);
#pragma empty_line
      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param cloc  Handle to C locale data.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);
#pragma empty_line
    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;
#pragma empty_line
      /// Destructor
      virtual
      ~ctype();
#pragma empty_line
      /**
       *  @brief  Test wchar_t classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param c  The wchar_t to find the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const;
#pragma empty_line
      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each wchar_t in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#pragma empty_line
      /**
       *  @brief  Find wchar_t matching mask
       *
       *  This function searches for and returns the first wchar_t c in
       *  [lo,hi) for which is(m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching wchar_t if found, else @a hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Find wchar_t not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  wchar_t c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching wchar_t if found, else @a hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the wchar_t argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The wchar_t to convert.
       *  @return  The uppercase wchar_t if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const;
#pragma empty_line
      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The wchar_t to convert.
       *  @return  The lowercase wchar_t if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const;
#pragma empty_line
      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      /**
       *  @brief  Widen char to wchar_t
       *
       *  This virtual function converts the char to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be cast to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted wchar_t.
      */
      virtual char_type
      do_widen(char) const;
#pragma empty_line
      /**
       *  @brief  Widen char array to wchar_t array
       *
       *  This function converts each char in the input to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be copied, casting each element to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#pragma empty_line
      /**
       *  @brief  Narrow wchar_t to char
       *
       *  This virtual function converts the argument to char using
       *  the simplest reasonable transformation.  If the conversion
       *  fails, dfault is returned instead.  For an underived
       *  ctype<wchar_t> facet, @a c will be cast to char and
       *  returned.
       *
       *  do_narrow() is a hook for a derived facet to change the
       *  behavior of narrowing.  do_narrow() must always return the
       *  same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The wchar_t to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type, char __dfault) const;
#pragma empty_line
      /**
       *  @brief  Narrow wchar_t array to char array
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any wchar_t in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<wchar_t> facet, the argument will be copied, casting each
       *  element to char.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
#pragma empty_line
      // For use at construction time only.
      void
      _M_initialize_ctype();
    };
#pragma empty_line
  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);
#pragma empty_line
#pragma empty_line
  /// @brief  class ctype_byname [22.2.1.2].
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;
#pragma empty_line
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~ctype_byname() { };
    };
#pragma empty_line
  /// 22.2.1.4  Class ctype_byname specializations.
  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);
#pragma empty_line
  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);
#pragma empty_line
}
#pragma empty_line
// Include host and configuration specific ctype inlines.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/ctype_inline.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 2000 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ctype_inline.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
// functions go in ctype.cc
#pragma empty_line
namespace std {
#pragma empty_line
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }
#pragma empty_line
#pragma empty_line
  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }
#pragma empty_line
  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }
#pragma empty_line
  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }
#pragma empty_line
}
#pragma line 1534 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma empty_line
// 22.2.1.5  Template class codecvt
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/codecvt.h" 1 3
// Locale support (codecvt) -*- C++ -*-
#pragma empty_line
// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005
//  Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file bits/codecvt.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.2.1.5 Template class codecvt
//
#pragma empty_line
// Written by Benjamin Kosnik <bkoz@redhat.com>
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/codecvt.h" 3
#pragma empty_line
namespace std {
#pragma empty_line
  /// @brief  Empty base class for codecvt facet [22.2.1.5].
  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
#pragma empty_line
  /**
   *  @brief  Common base for codecvt functions.
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:
      // Types:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
#pragma empty_line
      // 22.2.1.5.1 codecvt members
      /**
       *  @brief  Convert from internal to external character set.
       *
       *  Converts input string of intern_type to output string of
       *  extern_type.  This is analogous to wcsrtombs.  It does this by
       *  calling codecvt::do_out.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The characters in [from,from_end) are converted and written to
       *  [to,to_end).  from_next and to_next are set to point to the
       *  character following the last successfully converted character,
       *  respectively.  If the result needed no conversion, from_next and
       *  to_next are not affected.
       *
       *  The @a state argument should be intialized if the input is at the
       *  beginning and carried from a previous call if continuing
       *  conversion.  There are no guarantees about how @a state is used.
       *
       *  The result returned is a member of codecvt_base::result.  If
       *  all the input is converted, returns codecvt_base::ok.  If no
       *  conversion is necessary, returns codecvt_base::noconv.  If
       *  the input ends early or there is insufficient space in the
       *  output, returns codecvt_base::partial.  Otherwise the
       *  conversion failed and codecvt_base::error is returned.
       *
       *  @param  state  Persistent conversion state data.
       *  @param  from  Start of input.
       *  @param  from_end  End of input.
       *  @param  from_next  Returns start of unconverted data.
       *  @param  to  Start of output buffer.
       *  @param  to_end  End of output buffer.
       *  @param  to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      */
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
#pragma empty_line
      /**
       *  @brief  Reset conversion state.
       *
       *  Writes characters to output that would restore @a state to initial
       *  conditions.  The idea is that if a partial conversion occurs, then
       *  the converting the characters written by this function would leave
       *  the state in initial conditions, rather than partial conversion
       *  state.  It does this by calling codecvt::do_unshift().
       *
       *  For example, if 4 external characters always converted to 1 internal
       *  character, and input to in() had 6 external characters with state
       *  saved, this function would write two characters to the output and
       *  set the state to initialized conditions.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The result returned is a member of codecvt_base::result.  If the
       *  state could be reset and data written, returns codecvt_base::ok.  If
       *  no conversion is necessary, returns codecvt_base::noconv.  If the
       *  output has insufficient space, returns codecvt_base::partial.
       *  Otherwise the reset failed and codecvt_base::error is returned.
       *
       *  @param  state  Persistent conversion state data.
       *  @param  to  Start of output buffer.
       *  @param  to_end  End of output buffer.
       *  @param  to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      */
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
#pragma empty_line
      /**
       *  @brief  Convert from external to internal character set.
       *
       *  Converts input string of extern_type to output string of
       *  intern_type.  This is analogous to mbsrtowcs.  It does this by
       *  calling codecvt::do_in.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The characters in [from,from_end) are converted and written to
       *  [to,to_end).  from_next and to_next are set to point to the
       *  character following the last successfully converted character,
       *  respectively.  If the result needed no conversion, from_next and
       *  to_next are not affected.
       *
       *  The @a state argument should be intialized if the input is at the
       *  beginning and carried from a previous call if continuing
       *  conversion.  There are no guarantees about how @a state is used.
       *
       *  The result returned is a member of codecvt_base::result.  If
       *  all the input is converted, returns codecvt_base::ok.  If no
       *  conversion is necessary, returns codecvt_base::noconv.  If
       *  the input ends early or there is insufficient space in the
       *  output, returns codecvt_base::partial.  Otherwise the
       *  conversion failed and codecvt_base::error is returned.
       *
       *  @param  state  Persistent conversion state data.
       *  @param  from  Start of input.
       *  @param  from_end  End of input.
       *  @param  from_next  Returns start of unconverted data.
       *  @param  to  Start of output buffer.
       *  @param  to_end  End of output buffer.
       *  @param  to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      */
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }
#pragma empty_line
      int
      encoding() const throw()
      { return this->do_encoding(); }
#pragma empty_line
      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }
#pragma empty_line
      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }
#pragma empty_line
      int
      max_length() const throw()
      { return this->do_max_length(); }
#pragma empty_line
    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }
#pragma empty_line
      virtual
      ~__codecvt_abstract_base() { }
#pragma empty_line
      /**
       *  @brief  Convert from internal to external character set.
       *
       *  Converts input string of intern_type to output string of
       *  extern_type.  This function is a hook for derived classes to change
       *  the value returned.  @see out for more information.
      */
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;
#pragma empty_line
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;
#pragma empty_line
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;
#pragma empty_line
      virtual int
      do_encoding() const throw() = 0;
#pragma empty_line
      virtual bool
      do_always_noconv() const throw() = 0;
#pragma empty_line
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;
#pragma empty_line
      virtual int
      do_max_length() const throw() = 0;
    };
#pragma empty_line
  /// @brief class codecvt [22.2.1.5].
  /// NB: Generic, mostly useless implementation.
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:
      // Types:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
#pragma empty_line
    protected:
      __c_locale _M_c_locale_codecvt;
#pragma empty_line
    public:
      static locale::id id;
#pragma empty_line
      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }
#pragma empty_line
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~codecvt() { }
#pragma empty_line
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
#pragma empty_line
      virtual int
      do_encoding() const throw();
#pragma empty_line
      virtual bool
      do_always_noconv() const throw();
#pragma empty_line
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
#pragma empty_line
      virtual int
      do_max_length() const throw();
    };
#pragma empty_line
  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;
#pragma empty_line
  /// @brief class codecvt<char, char, mbstate_t> specialization.
  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:
      // Types:
      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
#pragma empty_line
    protected:
      __c_locale _M_c_locale_codecvt;
#pragma empty_line
    public:
      static locale::id id;
#pragma empty_line
      explicit
      codecvt(size_t __refs = 0);
#pragma empty_line
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~codecvt();
#pragma empty_line
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
#pragma empty_line
      virtual int
      do_encoding() const throw();
#pragma empty_line
      virtual bool
      do_always_noconv() const throw();
#pragma empty_line
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
#pragma empty_line
      virtual int
      do_max_length() const throw();
  };
#pragma empty_line
#pragma empty_line
  /// @brief  class codecvt<wchar_t, char, mbstate_t> specialization.
  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:
      // Types:
      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
#pragma empty_line
    protected:
      __c_locale _M_c_locale_codecvt;
#pragma empty_line
    public:
      static locale::id id;
#pragma empty_line
      explicit
      codecvt(size_t __refs = 0);
#pragma empty_line
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~codecvt();
#pragma empty_line
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;
#pragma empty_line
      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;
#pragma empty_line
      virtual
      int do_encoding() const throw();
#pragma empty_line
      virtual
      bool do_always_noconv() const throw();
#pragma empty_line
      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;
#pragma empty_line
      virtual int
      do_max_length() const throw();
    };
#pragma empty_line
#pragma empty_line
  /// @brief class codecvt_byname [22.2.1.6].
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~codecvt_byname() { }
    };
#pragma empty_line
}
#pragma line 1537 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 22.2.2  The numeric category.
  class __num_base
  {
  public:
    // NB: Code depends on the order of _S_atoms_out elements.
    // Below are the indices into _S_atoms_out.
    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14, // For scientific notation, 'e'
        _S_oE = _S_oudigits + 14, // For scientific notation, 'E'
 _S_oend = _S_oudigits_end
      };
#pragma empty_line
    // A list of valid numeric literals for output.  This array
    // contains chars that will be passed through the current locale's
    // ctype<_CharT>.widen() and then used to render numbers.
    // For the standard "C" locale, this is
    // "-+xX0123456789abcdef0123456789ABCDEF".
    static const char* _S_atoms_out;
#pragma empty_line
    // String literal of acceptable (narrow) input, for num_get.
    // "-+xX0123456789abcdefABCDEF"
    static const char* _S_atoms_in;
#pragma empty_line
    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };
#pragma empty_line
    // num_put
    // Construct and return valid scanf format for floating point types.
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };
#pragma empty_line
  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
#pragma empty_line
      // A list of valid numeric literals for output: in the standard
      // "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT _M_atoms_out[__num_base::_S_oend];
#pragma empty_line
      // A list of valid numeric literals for input: in the standard
      // "C" locale, this is "-+xX0123456789abcdefABCDEF"
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT _M_atoms_in[__num_base::_S_iend];
#pragma empty_line
      bool _M_allocated;
#pragma empty_line
      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }
#pragma empty_line
      ~__numpunct_cache();
#pragma empty_line
      void
      _M_cache(const locale& __loc);
#pragma empty_line
    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);
#pragma empty_line
      explicit
      __numpunct_cache(const __numpunct_cache&);
    };
#pragma empty_line
  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
#pragma empty_line
  /**
   *  @brief  Numpunct facet.
   *
   *  This facet stores several pieces of information related to printing and
   *  scanning numbers, such as the decimal point character.  It takes a
   *  template parameter specifying the char type.  The numpunct facet is
   *  used by streams for many I/O operations involving numbers.
   *
   *  The numpunct template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from a numpunct facet.
  */
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
      typedef __numpunct_cache<_CharT> __cache_type;
#pragma empty_line
    protected:
      __cache_type* _M_data;
#pragma empty_line
    public:
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Numpunct constructor.
       *
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
#pragma empty_line
      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up the
       *  predefined locale facets.
       *
       *  @param  cache  __numpunct_cache object.
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
#pragma empty_line
      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  cloc  The "C" locale.
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
#pragma empty_line
      /**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  numpunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      */
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#pragma empty_line
      /**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  numpunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      */
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#pragma empty_line
      /**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of a number.  Groupings indicate where thousands
       *  separators should be inserted in the integer part of a number.
       *
       *  Each char in the return string is interpret as an integer
       *  rather than a character.  These numbers represent the number
       *  of digits in a group.  The first char in the string
       *  represents the number of digits in the least significant
       *  group.  If a char is negative, it indicates an unlimited
       *  number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is
       *  applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was "32", this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  numpunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      */
      string
      grouping() const
      { return this->do_grouping(); }
#pragma empty_line
      /**
       *  @brief  Return string representation of bool true.
       *
       *  This function returns a string_type containing the text
       *  representation for true bool variables.  It does so by calling
       *  numpunct<char_type>::do_truename().
       *
       *  @return  string_type representing printed form of true.
      */
      string_type
      truename() const
      { return this->do_truename(); }
#pragma empty_line
      /**
       *  @brief  Return string representation of bool false.
       *
       *  This function returns a string_type containing the text
       *  representation for false bool variables.  It does so by calling
       *  numpunct<char_type>::do_falsename().
       *
       *  @return  string_type representing printed form of false.
      */
      string_type
      falsename() const
      { return this->do_falsename(); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~numpunct();
#pragma empty_line
      /**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      */
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#pragma empty_line
      /**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      */
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#pragma empty_line
      /**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      */
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#pragma empty_line
      /**
       *  @brief  Return string representation of bool true.
       *
       *  Returns a string_type containing the text representation for true
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of true.
      */
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
#pragma empty_line
      /**
       *  @brief  Return string representation of bool false.
       *
       *  Returns a string_type containing the text representation for false
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of false.
      */
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }
#pragma empty_line
      // For use at construction time only.
      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };
#pragma empty_line
  template<typename _CharT>
    locale::id numpunct<_CharT>::id;
#pragma empty_line
  template<>
    numpunct<char>::~numpunct();
#pragma empty_line
  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
#pragma empty_line
#pragma empty_line
  template<>
    numpunct<wchar_t>::~numpunct();
#pragma empty_line
  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
#pragma empty_line
#pragma empty_line
  /// @brief  class numpunct_byname [22.2.3.2].
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~numpunct_byname() { }
    };
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Facet for parsing number strings.
   *
   *  This facet encapsulates the code to parse and return a number
   *  from a string.  It is used by the istream numeric extraction
   *  operators.
   *
   *  The num_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_get facet.
  */
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _InIter iter_type;
      //@}
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
#pragma empty_line
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the bool @a v.  It does so by calling
       *  num_get::do_get().
       *
       *  If ios_base::boolalpha is set, attempts to read
       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
       *  @a v to true or false if successful.  Sets err to
       *  ios_base::failbit if reading the string fails.  Sets err to
       *  ios_base::eofbit if the stream is emptied.
       *
       *  If ios_base::boolalpha is not set, proceeds as with reading a long,
       *  except if the value is 1, sets @a v to true, if the value is 0, sets
       *  @a v to false, and otherwise set err to ios_base::failbit.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  Parsing is affected by the flag settings in @a io.
       *
       *  The basic parse is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, parses like the
       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
       *  specifier.  Else if basefield equal to 0, parses like the %i
       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
       *  types.  The matching type length modifier is also used.
       *
       *  Digit grouping is intrepreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      //@}
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %g specifier.  The
       *  matching type length modifier is also used.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Digit grouping is intrepreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      //@}
#pragma empty_line
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the pointer variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %p specifier.
       *
       *  Digit grouping is intrepreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  Note that the digit grouping effect for pointers is a bit ambiguous
       *  in the standard and shouldn't be relied on.  See DR 344.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual ~num_get() { }
#pragma empty_line
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;
#pragma empty_line
      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;
#pragma empty_line
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }
#pragma empty_line
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the variable @a v.  This function is a
       *  hook for derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      //@}
    };
#pragma empty_line
  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Facet for converting numbers to strings.
   *
   *  This facet encapsulates the code to convert a number to a string.  It is
   *  used by the ostream numeric insertion operators.
   *
   *  The num_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_put facet.
  */
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      //@}
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
#pragma empty_line
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the boolean @a v and inserts it into a stream.  It does so
       *  by calling num_put::do_put().
       *
       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the integral value @a v and inserts it into a
       *  stream.  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, formats like the
       *  printf %o specifier.  Else if equal to ios_base::hex, formats like
       *  %x or %X with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
       *  for unsigned values.  Note that if both oct and hex are set, neither
       *  will take effect.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showbase is set, '0' precedes octal values (except 0)
       *  and '0[xX]' precedes hex values.
       *
       *  Thousands separators are inserted according to numpunct::grouping()
       *  and numpunct::thousands_sep().  The decimal point character used is
       *  numpunct::decimal_point().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      //@}
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the floating point value @a v and inserts it into a stream.
       *  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
       *  printf %f specifier.  Else if equal to ios_base::scientific, formats
       *  like %e or %E with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %g or %G depending on uppercase.  Note that
       *  if both fixed and scientific are set, the effect will also be like
       *  %g or %G.
       *
       *  The output precision is given by io.precision().  This precision is
       *  capped at numeric_limits::digits10 + 2 (different for double and
       *  long double).  The default precision is 6.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showpoint is set, a decimal point will always be
       *  output.
       *
       *  Thousands separators are inserted according to numpunct::grouping()
       *  and numpunct::thousands_sep().  The decimal point character used is
       *  numpunct::decimal_point().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      //@}
#pragma empty_line
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the pointer value @a v and inserts it into a stream.  It
       *  does so by calling num_put::do_put().
       *
       *  This function formats @a v as an unsigned long with ios_base::hex
       *  and ios_base::showbase set.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;
#pragma empty_line
      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;
#pragma empty_line
      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;
#pragma empty_line
      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;
#pragma empty_line
      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;
#pragma empty_line
      /// Destructor.
      virtual
      ~num_put() { };
#pragma empty_line
      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  These functions do the work of formatting numeric values and
       *  inserting them into a stream. This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      //@}
    };
#pragma empty_line
  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Facet for localized string comparison.
   *
   *  This facet encapsulates the code to compare strings in a localized
   *  manner.
   *
   *  The collate template uses protected virtual functions to provide
   *  the actual results.  The public accessors forward the call to
   *  the virtual functions.  These virtual functions are hooks for
   *  developers to implement the behavior they require from the
   *  collate facet.
  */
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
#pragma empty_line
    protected:
      // Underlying "C" library locale information saved from
      // initialization, needed by collate_byname as well.
      __c_locale _M_c_locale_collate;
#pragma empty_line
    public:
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
#pragma empty_line
      /**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param cloc  The "C" locale.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
#pragma empty_line
      /**
       *  @brief  Compare two strings.
       *
       *  This function compares two strings and returns the result by calling
       *  collate::do_compare().
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
#pragma empty_line
      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a wrapper for strxfrm functionality.  It takes the
       *  input string and returns a modified string that can be directly
       *  compared to other transformed strings.  In the "C" locale, this
       *  function just returns a copy of the input string.  In some other
       *  locales, it may replace two chars with one, change a char for
       *  another, etc.  It does so by returning collate::do_transform().
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Transformed string_type.
      */
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
#pragma empty_line
      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  It
       *  does so by returning collate::do_hash().
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Hash value.
      */
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }
#pragma empty_line
      // Used to abstract out _CharT bits in virtual member functions, below.
      int
      _M_compare(const _CharT*, const _CharT*) const;
#pragma empty_line
      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;
#pragma empty_line
  protected:
      /// Destructor.
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
#pragma empty_line
      /**
       *  @brief  Compare two strings.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see compare().
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
#pragma empty_line
      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
#pragma empty_line
      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  This
       *  function is a hook for derived classes to change the value returned.
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Hash value.
      */
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };
#pragma empty_line
  template<typename _CharT>
    locale::id collate<_CharT>::id;
#pragma empty_line
  // Specializations.
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;
#pragma empty_line
  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
#pragma empty_line
#pragma empty_line
  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;
#pragma empty_line
  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;
#pragma empty_line
#pragma empty_line
  /// @brief  class collate_byname [22.2.4.2].
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
#pragma empty_line
      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~collate_byname() { }
    };
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Time format ordering data.
   *
   *  This class provides an enum representing different orderings of day,
   *  month, and year.
  */
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };
#pragma empty_line
  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {
      // List of all known timezones, with GMT first.
      static const _CharT* _S_timezones[14];
#pragma empty_line
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;
#pragma empty_line
      // Day names, starting with "C"'s Sunday.
      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;
#pragma empty_line
      // Abbreviated day names, starting with "C"'s Sun.
      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;
#pragma empty_line
      // Month names, starting with "C"'s January.
      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;
#pragma empty_line
      // Abbreviated month names, starting with "C"'s Jan.
      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;
#pragma empty_line
      bool _M_allocated;
#pragma empty_line
      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }
#pragma empty_line
      ~__timepunct_cache();
#pragma empty_line
      void
      _M_cache(const locale& __loc);
#pragma empty_line
    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);
#pragma empty_line
      explicit
      __timepunct_cache(const __timepunct_cache&);
    };
#pragma empty_line
  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {
   // Unused.
 }
    }
#pragma empty_line
  // Specializations.
  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
#pragma empty_line
#pragma empty_line
  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];
#pragma empty_line
#pragma empty_line
  // Generic.
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];
#pragma empty_line
  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:
      // Types:
      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;
#pragma empty_line
    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;
#pragma empty_line
    public:
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      explicit
      __timepunct(size_t __refs = 0);
#pragma empty_line
      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
#pragma empty_line
      /**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param cloc  The "C" locale.
       *  @param s  The name of a locale.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);
#pragma empty_line
      // FIXME: for error checking purposes _M_put should return the return
      // value of strftime/wcsftime.
      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;
#pragma empty_line
      void
      _M_date_formats(const _CharT** __date) const
      {
 // Always have default first.
 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }
#pragma empty_line
      void
      _M_time_formats(const _CharT** __time) const
      {
 // Always have default first.
 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }
#pragma empty_line
      void
      _M_date_time_formats(const _CharT** __dt) const
      {
 // Always have default first.
 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }
#pragma empty_line
      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }
#pragma empty_line
      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }
#pragma empty_line
      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }
#pragma empty_line
      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }
#pragma empty_line
      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }
#pragma empty_line
      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }
#pragma empty_line
    protected:
      virtual
      ~__timepunct();
#pragma empty_line
      // For use at construction time only.
      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };
#pragma empty_line
  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;
#pragma empty_line
  // Specializations.
  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);
#pragma empty_line
  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
#pragma empty_line
#pragma empty_line
  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);
#pragma empty_line
  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
  // Include host and configuration specific timepunct functions.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/time_members.h" 1 3
// std::time_get, std::time_put implementation, generic version -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file time_members.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.2.5.1.2 - time_get functions
// ISO C++ 14882: 22.2.5.3.2 - time_put functions
//
#pragma empty_line
// Written by Benjamin Kosnik <bkoz@redhat.com>
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }
#pragma empty_line
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }
#pragma empty_line
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      const size_t __len = std::strlen(__s) + 1;
      char* __tmp = new char[__len];
      std::memcpy(__tmp, __s, __len);
      _M_name_timepunct = __tmp;
#pragma empty_line
      if (true)
 { _M_initialize_timepunct(__cloc); }
      if (false)
 {
   delete [] _M_name_timepunct;
   ;
 }
    }
#pragma empty_line
  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
#pragma empty_line
}
#pragma line 3041 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @brief  Facet for parsing dates and times.
   *
   *  This facet encapsulates the code to parse and return a date or
   *  time from a string.  It is used by the istream numeric
   *  extraction operators.
   *
   *  The time_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the time_get facet.
  */
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _InIter iter_type;
      //@}
      typedef basic_string<_CharT> __string_type;
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
#pragma empty_line
      /**
       *  @brief  Return preferred order of month, day, and year.
       *
       *  This function returns an enum from timebase::dateorder giving the
       *  preferred ordering if the format "x" given to time_put::put() only
       *  uses month, day, and year.  If the format "x" for the associated
       *  locale uses other fields, this function returns
       *  timebase::dateorder::noorder.
       *
       *  NOTE: The library always returns noorder at the moment.
       *
       *  @return  A member of timebase::dateorder.
      */
      dateorder
      date_order() const
      { return this->do_date_order(); }
#pragma empty_line
      /**
       *  @brief  Parse input time string.
       *
       *  This function parses a time according to the format "x" and puts the
       *  results into a user-supplied struct tm.  The result is returned by
       *  calling time_get::do_get_time().
       *
       *  If there is a valid time string according to format "x", @a tm will
       *  be filled in accordingly and the returned iterator will point to the
       *  first character beyond the time string.  If an error occurs before
       *  the end, err |= ios_base::failbit.  If parsing reads all the
       *  characters, err |= ios_base::eofbit.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond time string.
      */
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
#pragma empty_line
      /**
       *  @brief  Parse input date string.
       *
       *  This function parses a date according to the format "X" and puts the
       *  results into a user-supplied struct tm.  The result is returned by
       *  calling time_get::do_get_date().
       *
       *  If there is a valid date string according to format "X", @a tm will
       *  be filled in accordingly and the returned iterator will point to the
       *  first character beyond the date string.  If an error occurs before
       *  the end, err |= ios_base::failbit.  If parsing reads all the
       *  characters, err |= ios_base::eofbit.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond date string.
      */
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
#pragma empty_line
      /**
       *  @brief  Parse input weekday string.
       *
       *  This function parses a weekday name and puts the results into a
       *  user-supplied struct tm.  The result is returned by calling
       *  time_get::do_get_weekday().
       *
       *  Parsing starts by parsing an abbreviated weekday name.  If a valid
       *  abbreviation is followed by a character that would lead to the full
       *  weekday name, parsing continues until the full name is found or an
       *  error occurs.  Otherwise parsing finishes at the end of the
       *  abbreviated name.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |= ios_base::eofbit.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond weekday name.
      */
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
#pragma empty_line
      /**
       *  @brief  Parse input month string.
       *
       *  This function parses a month name and puts the results into a
       *  user-supplied struct tm.  The result is returned by calling
       *  time_get::do_get_monthname().
       *
       *  Parsing starts by parsing an abbreviated month name.  If a valid
       *  abbreviation is followed by a character that would lead to the full
       *  month name, parsing continues until the full name is found or an
       *  error occurs.  Otherwise parsing finishes at the end of the
       *  abbreviated name.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |=
       *  ios_base::eofbit.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond month name.
      */
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
#pragma empty_line
      /**
       *  @brief  Parse input year string.
       *
       *  This function reads up to 4 characters to parse a year string and
       *  puts the results into a user-supplied struct tm.  The result is
       *  returned by calling time_get::do_get_year().
       *
       *  4 consecutive digits are interpreted as a full year.  If there are
       *  exactly 2 consecutive digits, the library interprets this as the
       *  number of years since 1900.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |= ios_base::eofbit.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond year.
      */
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~time_get() { }
#pragma empty_line
      /**
       *  @brief  Return preferred order of month, day, and year.
       *
       *  This function returns an enum from timebase::dateorder giving the
       *  preferred ordering if the format "x" given to time_put::put() only
       *  uses month, day, and year.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @return  A member of timebase::dateorder.
      */
      virtual dateorder
      do_date_order() const;
#pragma empty_line
      /**
       *  @brief  Parse input time string.
       *
       *  This function parses a time according to the format "x" and puts the
       *  results into a user-supplied struct tm.  This function is a hook for
       *  derived classes to change the value returned.  @see get_time() for
       *  details.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond time string.
      */
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#pragma empty_line
      /**
       *  @brief  Parse input date string.
       *
       *  This function parses a date according to the format "X" and puts the
       *  results into a user-supplied struct tm.  This function is a hook for
       *  derived classes to change the value returned.  @see get_date() for
       *  details.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond date string.
      */
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#pragma empty_line
      /**
       *  @brief  Parse input weekday string.
       *
       *  This function parses a weekday name and puts the results into a
       *  user-supplied struct tm.  This function is a hook for derived
       *  classes to change the value returned.  @see get_weekday() for
       *  details.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond weekday name.
      */
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
#pragma empty_line
      /**
       *  @brief  Parse input month string.
       *
       *  This function parses a month name and puts the results into a
       *  user-supplied struct tm.  This function is a hook for derived
       *  classes to change the value returned.  @see get_monthname() for
       *  details.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond month name.
      */
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
#pragma empty_line
      /**
       *  @brief  Parse input year string.
       *
       *  This function reads up to 4 characters to parse a year string and
       *  puts the results into a user-supplied struct tm.  This function is a
       *  hook for derived classes to change the value returned.  @see
       *  get_year() for details.
       *
       *  @param  beg  Start of string to parse.
       *  @param  end  End of string to parse.
       *  @param  io  Source of the locale.
       *  @param  err  Error flags to set.
       *  @param  tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond year.
      */
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#pragma empty_line
      // Extract numeric component of length __len.
      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;
#pragma empty_line
      // Extract day or month name, or any unique array of string
      // literals in a const _CharT* array.
      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;
#pragma empty_line
      // Extract on a component-by-component basis, via __format argument.
      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };
#pragma empty_line
  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;
#pragma empty_line
  /// @brief  class time_get_byname [22.2.5.2].
  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:
      // Types:
      typedef _CharT char_type;
      typedef _InIter iter_type;
#pragma empty_line
      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }
#pragma empty_line
    protected:
      virtual
      ~time_get_byname() { }
    };
#pragma empty_line
  /**
   *  @brief  Facet for outputting dates and times.
   *
   *  This facet encapsulates the code to format and output dates and times
   *  according to formats used by strftime().
   *
   *  The time_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the time_put facet.
  */
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      //@}
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
#pragma empty_line
      /**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format string.  The format string is interpreted as by
       *  strftime().
       *
       *  @param  s  The stream to write to.
       *  @param  io  Source of locale.
       *  @param  fill  char_type to use for padding.
       *  @param  tm  Struct tm with date and time info to format.
       *  @param  beg  Start of format string.
       *  @param  end  End of format string.
       *  @return  Iterator after writing.
       */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
#pragma empty_line
      /**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format char and optional modifier.  The format and modifier
       *  are interpreted as by strftime().  It does so by returning
       *  time_put::do_put().
       *
       *  @param  s  The stream to write to.
       *  @param  io  Source of locale.
       *  @param  fill  char_type to use for padding.
       *  @param  tm  Struct tm with date and time info to format.
       *  @param  format  Format char.
       *  @param  mod  Optional modifier char.
       *  @return  Iterator after writing.
       */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~time_put()
      { }
#pragma empty_line
      /**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format char and optional modifier.  This function is a hook
       *  for derived classes to change the value returned.  @see put() for
       *  more details.
       *
       *  @param  s  The stream to write to.
       *  @param  io  Source of locale.
       *  @param  fill  char_type to use for padding.
       *  @param  tm  Struct tm with date and time info to format.
       *  @param  format  Format char.
       *  @param  mod  Optional modifier char.
       *  @return  Iterator after writing.
       */
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;
#pragma empty_line
  /// @brief  class time_put_byname [22.2.5.4].
  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:
      // Types:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
#pragma empty_line
      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };
#pragma empty_line
    protected:
      virtual
      ~time_put_byname() { }
    };
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Money format ordering data.
   *
   *  This class contains an ordered array of 4 fields to represent the
   *  pattern for formatting a money amount.  Each field may contain one entry
   *  from the part enum.  symbol, sign, and value must be present and the
   *  remaining field must contain either none or space.  @see
   *  moneypunct::pos_format() and moneypunct::neg_format() for details of how
   *  these fields are interpreted.
  */
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
#pragma empty_line
    static const pattern _S_default_pattern;
#pragma empty_line
    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };
#pragma empty_line
    // String literal of acceptable (narrow) input/output, for
    // money_get/money_put. "-0123456789"
    static const char* _S_atoms;
#pragma empty_line
    // Construct and return valid pattern consisting of some combination of:
    // space none symbol sign value
    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };
#pragma empty_line
  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;
#pragma empty_line
      // A list of valid numeric literals for input and output: in the standard
      // "C" locale, this is "-0123456789". This array contains the chars after
      // having been passed through the current locale's ctype<_CharT>.widen().
      _CharT _M_atoms[money_base::_S_end];
#pragma empty_line
      bool _M_allocated;
#pragma empty_line
      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }
#pragma empty_line
      ~__moneypunct_cache();
#pragma empty_line
      void
      _M_cache(const locale& __loc);
#pragma empty_line
    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);
#pragma empty_line
      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };
#pragma empty_line
  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }
#pragma empty_line
  /**
   *  @brief  Facet for formatting data for money amounts.
   *
   *  This facet encapsulates the punctuation, grouping and other formatting
   *  features of money amount string representations.
  */
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
#pragma empty_line
    private:
      __cache_type* _M_data;
#pragma empty_line
    public:
      /// This value is provided by the standard, but no reason for its
      /// existence.
      static const bool intl = _Intl;
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is an internal constructor.
       *
       *  @param cache  Cache for optimization.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
#pragma empty_line
      /**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param cloc  The "C" locale.
       *  @param s  The name of a locale.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
#pragma empty_line
      /**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  moneypunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      */
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#pragma empty_line
      /**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  moneypunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      */
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#pragma empty_line
      /**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of an amount.  Groupings indicate where thousands
       *  separators should be inserted.
       *
       *  Each char in the return string is interpret as an integer rather
       *  than a character.  These numbers represent the number of digits in a
       *  group.  The first char in the string represents the number of digits
       *  in the least significant group.  If a char is negative, it indicates
       *  an unlimited number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is applied to
       *  the number 123456789, this corresponds to 12,34,56,789.  Note that
       *  if the string was "32", this would put more than 50 digits into the
       *  least significant group if the character set is ASCII.
       *
       *  The string is returned by calling
       *  moneypunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      */
      string
      grouping() const
      { return this->do_grouping(); }
#pragma empty_line
      /**
       *  @brief  Return currency symbol string.
       *
       *  This function returns a string_type to use as a currency symbol.  It
       *  does so by returning returning
       *  moneypunct<char_type>::do_curr_symbol().
       *
       *  @return  @a string_type representing a currency symbol.
      */
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
#pragma empty_line
      /**
       *  @brief  Return positive sign string.
       *
       *  This function returns a string_type to use as a sign for positive
       *  amounts.  It does so by returning returning
       *  moneypunct<char_type>::do_positive_sign().
       *
       *  If the return value contains more than one character, the first
       *  character appears in the position indicated by pos_format() and the
       *  remainder appear at the end of the formatted string.
       *
       *  @return  @a string_type representing a positive sign.
      */
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
#pragma empty_line
      /**
       *  @brief  Return negative sign string.
       *
       *  This function returns a string_type to use as a sign for negative
       *  amounts.  It does so by returning returning
       *  moneypunct<char_type>::do_negative_sign().
       *
       *  If the return value contains more than one character, the first
       *  character appears in the position indicated by neg_format() and the
       *  remainder appear at the end of the formatted string.
       *
       *  @return  @a string_type representing a negative sign.
      */
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
#pragma empty_line
      /**
       *  @brief  Return number of digits in fraction.
       *
       *  This function returns the exact number of digits that make up the
       *  fractional part of a money amount.  It does so by returning
       *  returning moneypunct<char_type>::do_frac_digits().
       *
       *  The fractional part of a money amount is optional.  But if it is
       *  present, there must be frac_digits() digits.
       *
       *  @return  Number of digits in amount fraction.
      */
      int
      frac_digits() const
      { return this->do_frac_digits(); }
#pragma empty_line
      //@{
      /**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  positive or negative valued money amount.  It does so by returning
       *  returning moneypunct<char_type>::do_pos_format() or
       *  moneypunct<char_type>::do_neg_format().
       *
       *  The pattern has 4 fields describing the ordering of symbol, sign,
       *  value, and none or space.  There must be one of each in the pattern.
       *  The none and space enums may not appear in the first field and space
       *  may not appear in the final field.
       *
       *  The parts of a money string must appear in the order indicated by
       *  the fields of the pattern.  The symbol field indicates that the
       *  value of curr_symbol() may be present.  The sign field indicates
       *  that the value of positive_sign() or negative_sign() must be
       *  present.  The value field indicates that the absolute value of the
       *  money amount is present.  none indicates 0 or more whitespace
       *  characters, except at the end, where it permits no whitespace.
       *  space indicates that 1 or more whitespace characters must be
       *  present.
       *
       *  For example, for the US locale and pos_format() pattern
       *  {symbol,sign,value,none}, curr_symbol() == '$' positive_sign() ==
       *  '+', and value 10.01, and options set to force the symbol, the
       *  corresponding string is "$+10.01".
       *
       *  @return  Pattern for money values.
      */
      pattern
      pos_format() const
      { return this->do_pos_format(); }
#pragma empty_line
      pattern
      neg_format() const
      { return this->do_neg_format(); }
      //@}
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~moneypunct();
#pragma empty_line
      /**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      */
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#pragma empty_line
      /**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      */
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#pragma empty_line
      /**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      */
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#pragma empty_line
      /**
       *  @brief  Return currency symbol string.
       *
       *  This function returns a string_type to use as a currency symbol.
       *  This function is a hook for derived classes to change the value
       *  returned.  @see curr_symbol() for details.
       *
       *  @return  @a string_type representing a currency symbol.
      */
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
#pragma empty_line
      /**
       *  @brief  Return positive sign string.
       *
       *  This function returns a string_type to use as a sign for positive
       *  amounts.  This function is a hook for derived classes to change the
       *  value returned.  @see positive_sign() for details.
       *
       *  @return  @a string_type representing a positive sign.
      */
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
#pragma empty_line
      /**
       *  @brief  Return negative sign string.
       *
       *  This function returns a string_type to use as a sign for negative
       *  amounts.  This function is a hook for derived classes to change the
       *  value returned.  @see negative_sign() for details.
       *
       *  @return  @a string_type representing a negative sign.
      */
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
#pragma empty_line
      /**
       *  @brief  Return number of digits in fraction.
       *
       *  This function returns the exact number of digits that make up the
       *  fractional part of a money amount.  This function is a hook for
       *  derived classes to change the value returned.  @see frac_digits()
       *  for details.
       *
       *  @return  Number of digits in amount fraction.
      */
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
#pragma empty_line
      /**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  positive valued money amount.  This function is a hook for derived
       *  classes to change the value returned.  @see pos_format() for
       *  details.
       *
       *  @return  Pattern for money values.
      */
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
#pragma empty_line
      /**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  negative valued money amount.  This function is a hook for derived
       *  classes to change the value returned.  @see neg_format() for
       *  details.
       *
       *  @return  Pattern for money values.
      */
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }
#pragma empty_line
      // For use at construction time only.
       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };
#pragma empty_line
  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;
#pragma empty_line
  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;
#pragma empty_line
  template<>
    moneypunct<char, true>::~moneypunct();
#pragma empty_line
  template<>
    moneypunct<char, false>::~moneypunct();
#pragma empty_line
  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);
#pragma empty_line
  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
#pragma empty_line
#pragma empty_line
  template<>
    moneypunct<wchar_t, true>::~moneypunct();
#pragma empty_line
  template<>
    moneypunct<wchar_t, false>::~moneypunct();
#pragma empty_line
  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);
#pragma empty_line
  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);
#pragma empty_line
#pragma empty_line
  /// @brief  class moneypunct_byname [22.2.6.4].
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
      static const bool intl = _Intl;
#pragma empty_line
      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~moneypunct_byname() { }
    };
#pragma empty_line
  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Facet for parsing monetary amounts.
   *
   *  This facet encapsulates the code to parse and return a monetary
   *  amount from a string.
   *
   *  The money_get template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the money_get facet.
  */
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;
      //@}
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
#pragma empty_line
      /**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads characters from @a s, interprets them as a
       *  monetary value according to moneypunct and ctype facets retrieved
       *  from io.getloc(), and returns the result in @a units as an integral
       *  value moneypunct::frac_digits() * the actual amount.  For example,
       *  the string $10.01 in a US locale would store 1001 in @a units.
       *
       *  Any characters not part of a valid money amount are not consumed.
       *
       *  If a money value cannot be parsed from the input stream, sets
       *  err=(err|io.failbit).  If the stream is consumed before finishing
       *  parsing,  sets err=(err|io.failbit|io.eofbit).  @a units is
       *  unchanged if parsing fails.
       *
       *  This function works by returning the result of do_get().
       *
       *  @param  s  Start of characters to parse.
       *  @param  end  End of characters to parse.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  err  Error field to set if parsing fails.
       *  @param  units  Place to store result of parsing.
       *  @return  Iterator referencing first character beyond valid money
       *	   amount.
       */
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
#pragma empty_line
      /**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads characters from @a s, interprets them as a
       *  monetary value according to moneypunct and ctype facets retrieved
       *  from io.getloc(), and returns the result in @a digits.  For example,
       *  the string $10.01 in a US locale would store "1001" in @a digits.
       *
       *  Any characters not part of a valid money amount are not consumed.
       *
       *  If a money value cannot be parsed from the input stream, sets
       *  err=(err|io.failbit).  If the stream is consumed before finishing
       *  parsing,  sets err=(err|io.failbit|io.eofbit).
       *
       *  This function works by returning the result of do_get().
       *
       *  @param  s  Start of characters to parse.
       *  @param  end  End of characters to parse.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  err  Error field to set if parsing fails.
       *  @param  digits  Place to store result of parsing.
       *  @return  Iterator referencing first character beyond valid money
       *	   amount.
       */
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~money_get() { }
#pragma empty_line
      /**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads and parses characters representing a monetary
       *  value.  This function is a hook for derived classes to change the
       *  value returned.  @see get() for details.
       */
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
#pragma empty_line
#pragma empty_line
      /**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads and parses characters representing a monetary
       *  value.  This function is a hook for derived classes to change the
       *  value returned.  @see get() for details.
       */
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };
#pragma empty_line
  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
#pragma empty_line
  /**
   *  @brief  Facet for outputting monetary amounts.
   *
   *  This facet encapsulates the code to format and output a monetary
   *  amount.
   *
   *  The money_put template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the money_put facet.
  */
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;
      //@}
#pragma empty_line
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
#pragma empty_line
      /**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a units as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a s.  For example, the value 1001 in a
       *  US locale would write "$10.01" to @a s.
       *
       *  This function works by returning the result of do_put().
       *
       *  @param  s  The stream to write to.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  fill  char_type to use for padding.
       *  @param  units  Place to store result of parsing.
       *  @return  Iterator after writing.
       */
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
#pragma empty_line
      /**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a digits as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a s.  For example, the string "1001" in
       *  a US locale would write "$10.01" to @a s.
       *
       *  This function works by returning the result of do_put().
       *
       *  @param  s  The stream to write to.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  fill  char_type to use for padding.
       *  @param  units  Place to store result of parsing.
       *  @return  Iterator after writing.
       */
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~money_put() { }
#pragma empty_line
      /**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a units as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a s.  For example, the value 1001 in a
       *  US locale would write "$10.01" to @a s.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see put().
       *
       *  @param  s  The stream to write to.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  fill  char_type to use for padding.
       *  @param  units  Place to store result of parsing.
       *  @return  Iterator after writing.
       */
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
#pragma empty_line
#pragma empty_line
      /**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a digits as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a s.  For example, the string "1001" in
       *  a US locale would write "$10.01" to @a s.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see put().
       *
       *  @param  s  The stream to write to.
       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  io  Source of facets and io state.
       *  @param  fill  char_type to use for padding.
       *  @param  units  Place to store result of parsing.
       *  @return  Iterator after writing.
       */
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
#pragma empty_line
      // XXX GLIBCXX_ABI Deprecated
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Messages facet base class providing catalog typedef.
   */
  struct messages_base
  {
    typedef int catalog;
  };
#pragma empty_line
  /**
   *  @brief  Facet for handling message catalogs
   *
   *  This facet encapsulates the code to retrieve messages from
   *  message catalogs.  The only thing defined by the standard for this facet
   *  is the interface.  All underlying functionality is
   *  implementation-defined.
   *
   *  This library currently implements 3 versions of the message facet.  The
   *  first version (gnu) is a wrapper around gettext, provided by libintl.
   *  The second version (ieee) is a wrapper around catgets.  The final
   *  version (default) does no actual translation.  These implementations are
   *  only provided for char and wchar_t instantiations.
   *
   *  The messages template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the messages facet.
  */
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
#pragma empty_line
    protected:
      // Underlying "C" library locale information saved from
      // initialization, needed by messages_byname as well.
      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;
#pragma empty_line
    public:
      /// Numpunct facet id.
      static locale::id id;
#pragma empty_line
      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      messages(size_t __refs = 0);
#pragma empty_line
      // Non-standard.
      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  cloc  The "C" locale.
       *  @param  s  The name of a locale.
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
#pragma empty_line
      /*
       *  @brief  Open a message catalog.
       *
       *  This function opens and returns a handle to a message catalog by
       *  returning do_open(s, loc).
       *
       *  @param  s  The catalog to open.
       *  @param  loc  Locale to use for character set conversions.
       *  @return  Handle to the catalog or value < 0 if open fails.
      */
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
#pragma empty_line
      // Non-standard and unorthodox, yet effective.
      /*
       *  @brief  Open a message catalog.
       *
       *  This non-standard function opens and returns a handle to a message
       *  catalog by returning do_open(s, loc).  The third argument provides a
       *  message catalog root directory for gnu gettext and is ignored
       *  otherwise.
       *
       *  @param  s  The catalog to open.
       *  @param  loc  Locale to use for character set conversions.
       *  @param  dir  Message catalog root directory.
       *  @return  Handle to the catalog or value < 0 if open fails.
      */
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
#pragma empty_line
      /*
       *  @brief  Look up a string in a message catalog.
       *
       *  This function retrieves and returns a message from a catalog by
       *  returning do_get(c, set, msgid, s).
       *
       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).
       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).
       *
       *  @param  c  The catalog to access.
       *  @param  set  Implementation-defined.
       *  @param  msgid  Implementation-defined.
       *  @param  s  Default return value if retrieval fails.
       *  @return  Retrieved message or @a s if get fails.
      */
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
#pragma empty_line
      /*
       *  @brief  Close a message catalog.
       *
       *  Closes catalog @a c by calling do_close(c).
       *
       *  @param  c  The catalog to close.
      */
      void
      close(catalog __c) const
      { return this->do_close(__c); }
#pragma empty_line
    protected:
      /// Destructor.
      virtual
      ~messages();
#pragma empty_line
      /*
       *  @brief  Open a message catalog.
       *
       *  This function opens and returns a handle to a message catalog in an
       *  implementation-defined manner.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  s  The catalog to open.
       *  @param  loc  Locale to use for character set conversions.
       *  @return  Handle to the opened catalog, value < 0 if open failed.
      */
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
#pragma empty_line
      /*
       *  @brief  Look up a string in a message catalog.
       *
       *  This function retrieves and returns a message from a catalog in an
       *  implementation-defined manner.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).
       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).
       *
       *  @param  c  The catalog to access.
       *  @param  set  Implementation-defined.
       *  @param  msgid  Implementation-defined.
       *  @param  s  Default return value if retrieval fails.
       *  @return  Retrieved message or @a s if get fails.
      */
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;
#pragma empty_line
      /*
       *  @brief  Close a message catalog.
       *
       *  @param  c  The catalog to close.
      */
      virtual void
      do_close(catalog) const;
#pragma empty_line
      // Returns a locale and codeset-converted string, given a char* message.
      char*
      _M_convert_to_char(const string_type& __msg) const
      {
 // XXX
 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }
#pragma empty_line
      // Returns a locale and codeset-converted string, given a char* message.
      string_type
      _M_convert_from_char(char*) const
      {
#pragma line 4561 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 3
 return string_type();
      }
     };
#pragma empty_line
  template<typename _CharT>
    locale::id messages<_CharT>::id;
#pragma empty_line
  // Specializations for required instantiations.
  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;
#pragma empty_line
#pragma empty_line
  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;
#pragma empty_line
#pragma empty_line
   /// @brief class messages_byname [22.2.7.2].
   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
      explicit
      messages_byname(const char* __s, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~messages_byname()
      { }
    };
#pragma empty_line
}
#pragma empty_line
  // Include host and configuration specific messages functions.
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/i686-pc-mingw32/bits/messages_members.h" 1 3
// std::messages implementation details, generic version -*- C++ -*-
#pragma empty_line
// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file messages_members.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.2.7.1.2  messages virtual functions
//
#pragma empty_line
// Written by Benjamin Kosnik <bkoz@redhat.com>
#pragma empty_line
namespace std {
#pragma empty_line
  // Non-virtual member functions.
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }
#pragma empty_line
  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }
#pragma empty_line
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }
#pragma empty_line
  // Virtual member functions.
  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }
#pragma empty_line
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }
#pragma empty_line
  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }
#pragma empty_line
  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }
#pragma empty_line
   // messages_byname
   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }
#pragma empty_line
}
#pragma line 4600 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // Subclause convenience interfaces, inlines.
  // NB: These are inline because, when used in a loop, some compilers
  // can hoist the body out of the loop; then it's just as fast as the
  // C is*() function.
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::space, __c).
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::print, __c).
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::cntrl, __c).
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::upper, __c).
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::lower, __c).
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::alpha, __c).
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::digit, __c).
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::punct, __c).
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::xdigit, __c).
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::alnum, __c).
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }
#pragma empty_line
  /// Convenience interface to ctype.is(ctype_base::graph, __c).
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }
#pragma empty_line
  /// Convenience interface to ctype.toupper(__c).
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }
#pragma empty_line
  /// Convenience interface to ctype.tolower(__c).
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
#pragma empty_line
}
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // 27.4.5  Template class basic_ios
  /**
   *  @brief  Virtual base class for all stream classes.
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
  */
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependant on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      //@}
#pragma empty_line
      //@{
      /**
       *  @if maint
       *  These are non-standard types.
       *  @endif
      */
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;
      //@}
#pragma empty_line
      // Data members:
    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;
#pragma empty_line
      // Cached use_facet<ctype>, which is based on the current locale info.
      const __ctype_type* _M_ctype;
      // For ostream.
      const __num_put_type* _M_num_put;
      // For istream.
      const __num_get_type* _M_num_get;
#pragma empty_line
    public:
      //@{
      /**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  "if (!a_stream) ..." and "while (a_stream) ..."
      */
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
#pragma empty_line
      bool
      operator!() const
      { return this->fail(); }
      //@}
#pragma empty_line
      /**
       *  @brief  Returns the error state of the stream buffer.
       *  @return  A bit pattern (well, isn't everything?)
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      */
      iostate
      rdstate() const
      { return _M_streambuf_state; }
#pragma empty_line
      /**
       *  @brief  [Re]sets the error state.
       *  @param  state  The new state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will not need to pass an argument.
      */
      void
      clear(iostate __state = goodbit);
#pragma empty_line
      /**
       *  @brief  Sets additional flags in the error state.
       *  @param  state  The additional state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.
      */
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
#pragma empty_line
      // Flip the internal state on for the proper state bits, then re
      // throws the propagated exception if bit also set in
      // exceptions().
      void
      _M_setstate(iostate __state)
      {
 // 27.6.1.2.1 Common requirements.
 // Turn this on without causing an ios::failure to be thrown.
 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   ;
      }
#pragma empty_line
      /**
       *  @brief  Fast error checking.
       *  @return  True if no error flags are set.
       *
       *  A wrapper around rdstate.
      */
      bool
      good() const
      { return this->rdstate() == 0; }
#pragma empty_line
      /**
       *  @brief  Fast error checking.
       *  @return  True if the eofbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
#pragma empty_line
      /**
       *  @brief  Fast error checking.
       *  @return  True if either the badbit or the failbit is set.
       *
       *  Checking the badbit in fail() is historical practice.
       *  Note that other iostate flags may also be set.
      */
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }
#pragma empty_line
      /**
       *  @brief  Fast error checking.
       *  @return  True if the badbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
#pragma empty_line
      /**
       *  @brief  Throwing exceptions on errors.
       *  @return  The current exceptions mask.
       *
       *  This changes nothing in the stream.  See the one-argument version
       *  of exceptions(iostate) for the meaning of the return value.
      */
      iostate
      exceptions() const
      { return _M_exception; }
#pragma empty_line
      /**
       *  @brief  Throwing exceptions on errors.
       *  @param  except  The new exceptions mask.
       *
       *  By default, error flags are set silently.  You can set an
       *  exceptions mask for each stream; if a bit in the mask becomes set
       *  in the error flags, then an exception of type
       *  std::ios_base::failure is thrown.
       *
       *  If the error flage is already set when the exceptions mask is
       *  added, the exception is immediately thrown.  Try running the
       *  following under GCC 3.1 or later:
       *  @code
       *  #include <iostream>
       *  #include <fstream>
       *  #include <exception>
       *
       *  int main()
       *  {
       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
       *
       *      std::ifstream f ("/etc/motd");
       *
       *      std::cerr << "Setting badbit\n";
       *      f.setstate (std::ios_base::badbit);
       *
       *      std::cerr << "Setting exception mask\n";
       *      f.exceptions (std::ios_base::badbit);
       *  }
       *  @endcode
      */
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }
#pragma empty_line
      // Constructor/destructor:
      /**
       *  @brief  Constructor performs initialization.
       *
       *  The parameter is passed by derived streams.
      */
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }
#pragma empty_line
      /**
       *  @brief  Empty.
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }
#pragma empty_line
      // Members:
      /**
       *  @brief  Fetches the current @e tied stream.
       *  @return  A pointer to the tied stream, or NULL if the stream is
       *           not tied.
       *
       *  A stream may be @e tied (or synchronized) to a second output
       *  stream.  When this stream performs any I/O, the tied stream is
       *  first flushed.  For example, @c std::cin is tied to @c std::cout.
      */
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
#pragma empty_line
      /**
       *  @brief  Ties this stream to an output stream.
       *  @param  tiestr  The output stream.
       *  @return  The previously tied output stream, or NULL if the stream
       *           was not tied.
       *
       *  This sets up a new tie; see tie() for more.
      */
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }
#pragma empty_line
      /**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current stream buffer.
       *
       *  This does not change the state of the stream.
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
#pragma empty_line
      /**
       *  @brief  Changing the underlying buffer.
       *  @param  sb  The new stream buffer.
       *  @return  The previous stream buffer.
       *
       *  Associates a new buffer with the current stream, and clears the
       *  error state.
       *
       *  Due to historical accidents which the LWG refuses to correct, the
       *  I/O library suffers from a design error:  this function is hidden
       *  in derived classes by overrides of the zero-argument @c rdbuf(),
       *  which is non-virtual for hysterical raisins.  As a result, you
       *  must use explicit qualifications to access this function via any
       *  derived class.  For example:
       *
       *  @code
       *  std::fstream     foo;         // or some other derived type
       *  std::streambuf*  p = .....;
       *
       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
       *  @endcode
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
#pragma empty_line
      /**
       *  @brief  Copies fields of __rhs into this.
       *  @param  __rhs  The source values for the copies.
       *  @return  Reference to this object.
       *
       *  All fields of __rhs are copied into this object except that rdbuf()
       *  and rdstate() remain unchanged.  All values in the pword and iword
       *  arrays are copied.  Before copying, each callback is invoked with
       *  erase_event.  After copying, each (new) callback is invoked with
       *  copyfmt_event.  The final step is to copy exceptions().
      */
      basic_ios&
      copyfmt(const basic_ios& __rhs);
#pragma empty_line
      /**
       *  @brief  Retreives the "empty" character.
       *  @return  The current fill character.
       *
       *  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
#pragma empty_line
      /**
       *  @brief  Sets a new "empty" character.
       *  @param  ch  The new character.
       *  @return  The previous fill character.
       *
       *  The fill character is used to fill out space when P+ characters
       *  have been requested (e.g., via setw), Q characters are actually
       *  used, and Q<P.  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
#pragma empty_line
      // Locales:
      /**
       *  @brief  Moves to a new locale.
       *  @param  loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
       *  with this stream, calls that buffer's @c pubimbue(loc).
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html
      */
      locale
      imbue(const locale& __loc);
#pragma empty_line
      /**
       *  @brief  Squeezes characters.
       *  @param  c  The character to narrow.
       *  @param  dfault  The character to narrow.
       *  @return  The narrowed character.
       *
       *  Maps a character of @c char_type to a character of @c char,
       *  if possible.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html
      */
      char
      narrow(char_type __c, char __dfault) const;
#pragma empty_line
      /**
       *  @brief  Widens characters.
       *  @param  c  The character to widen.
       *  @return  The widened character.
       *
       *  Maps a character of @c char to a character of @c char_type.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html
      */
      char_type
      widen(char __c) const;
#pragma empty_line
    protected:
      // 27.4.5.1  basic_ios constructors
      /**
       *  @brief  Empty.
       *
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }
#pragma empty_line
      /**
       *  @brief  All setup is performed here.
       *
       *  This is called from the public constructor.  It is not virtual and
       *  cannot be redefined.
      */
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);
#pragma empty_line
      void
      _M_cache_locale(const locale& __loc);
    };
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.tcc" 1 3
// basic_ios member functions -*- C++ -*-
#pragma empty_line
// Copyright (C) 1999, 2001, 2002, 2003, 2004, 2005
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file basic_ios.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.tcc" 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 292. effects of a.copyfmt (a)
      if (this != &__rhs)
 {
   // Per 27.1.1, do not call imbue, yet must trash all caches
   // associated with imbue()
#pragma empty_line
   // Alloc any new word array first, so if it fails we have "rollback".
   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];
#pragma empty_line
   // Bump refs before doing callbacks, for safety.
   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();
#pragma empty_line
   // NB: Don't want any added during above.
   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;
#pragma empty_line
   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);
#pragma empty_line
   _M_call_callbacks(copyfmt_event);
#pragma empty_line
   // The next is required to be the last assignment.
   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }
#pragma empty_line
  // Locales:
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
      // NB: This may be called more than once on the same object.
      ios_base::_M_init();
#pragma empty_line
      // Cache locale data and specific facets used by iostreams.
      _M_cache_locale(_M_ios_locale);
#pragma empty_line
      // NB: The 27.4.4.1 Postconditions Table specifies requirements
      // after basic_ios::init() has been called. As part of this,
      // fill() must return widen(' ') any time after init() has been
      // called, which needs an imbued ctype facet of char_type to
      // return without throwing an exception. Unfortunately,
      // ctype<char_type> is not necessarily a required facet, so
      // streams with char_type != [char, wchar_t] will not have it by
      // default. Because of this, the correct value for _M_fill is
      // constructed on the first call of fill(). That way,
      // unformatted input and output with non-required basic_ios
      // instantiations is possible even without imbuing the expected
      // ctype<char_type> facet.
      _M_fill = _CharT();
      _M_fill_init = false;
#pragma empty_line
      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;
#pragma empty_line
      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;
#pragma empty_line
      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB:  This syntax is a GNU extension.
#pragma empty_line
  extern template class basic_ios<char>;
#pragma empty_line
#pragma empty_line
  extern template class basic_ios<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 466 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/basic_ios.h" 2 3
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 2 3
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream_insert.h" 1 3
// Helpers for ostream inserters -*- C++ -*-
#pragma empty_line
// Copyright (C) 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ostream_insert.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // [27.6.2.1] Template class basic_ostream
  /**
   *  @brief  Controlling output.
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  */
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios (27.4.4)):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
      // [27.6.2.2] constructor/destructor
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }
#pragma empty_line
      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_ostream() { }
#pragma empty_line
      // [27.6.2.3] prefix/suffix
      class sentry;
      friend class sentry;
#pragma empty_line
      // [27.6.2.5] formatted output
      // [27.6.2.5.3]  basic_ostream::operator<<
      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manuipulators such as @c std::endl and @c std::hex use these
       *  functions in constructs like "std::cout << std::endl".  For more
       *  information, see the iomanip header.
      */
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 return __pf(*this);
      }
#pragma empty_line
      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 __pf(*this);
 return *this;
      }
#pragma empty_line
      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 __pf(*this);
 return *this;
      }
      //@}
#pragma empty_line
      // [27.6.2.5.2] arithmetic inserters
      /**
       *  @name Arithmetic Inserters
       *
       *  All the @c operator<< functions (aka <em>formatted output
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_ostream::sentry.
       *  This can have several effects, concluding with the setting of a
       *  status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Basic arithmetic inserters
       *  @param  A variable of builtin type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(short __n);
#pragma empty_line
      __ostream_type&
      operator<<(unsigned short __n)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<unsigned long>(__n));
      }
#pragma empty_line
      __ostream_type&
      operator<<(int __n);
#pragma empty_line
      __ostream_type&
      operator<<(unsigned int __n)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<unsigned long>(__n));
      }
#pragma empty_line
#pragma empty_line
      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
#pragma empty_line
#pragma empty_line
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
#pragma empty_line
      __ostream_type&
      operator<<(float __f)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<double>(__f));
      }
#pragma empty_line
      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
#pragma empty_line
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
#pragma empty_line
      /**
       *  @brief  Extracting from another streambuf.
       *  @param  sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @a sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from @a sb and inserted into @c *this
       *  until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output sequence fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs while getting a character from @a sb, which
       *    sets failbit in the error state
       *
       *  If the function inserts no characters, failbit is set.
      */
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      //@}
#pragma empty_line
      // [27.6.2.6] unformatted output functions
      /**
       *  @name Unformatted Output Functions
       *
       *  All the unformatted output functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_ostream::sentry.  This has several effects, concluding
       *  with the setting of a status flag; see the sentry documentation
       *  for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state.  If badbit is on in
       *  the stream's exceptions mask, the exception will be rethrown
       *  without completing its actions.
      */
      //@{
      /**
       *  @brief  Simple insertion.
       *  @param  c  The character to insert.
       *  @return  *this
       *
       *  Tries to insert @a c.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      put(char_type __c);
#pragma empty_line
      // Core write functionality, without sentry.
      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
#pragma empty_line
      /**
       *  @brief  Character string insertion.
       *  @param  s  The array to insert.
       *  @param  n  Maximum number of characters to insert.
       *  @return  *this
       *
       *  Characters are copied from @a s and inserted into the stream until
       *  one of the following happens:
       *
       *  - @a n characters are inserted
       *  - inserting into the output sequence fails (in this case, badbit
       *    will be set in the stream's error state)
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      //@}
#pragma empty_line
      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  *this
       *
       *  If @c rdbuf() is a null pointer, changes nothing.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit.
      */
      __ostream_type&
      flush();
#pragma empty_line
      // [27.6.2.4] seek members
      /**
       *  @brief  Getting the current write position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
      */
      pos_type
      tellp();
#pragma empty_line
      /**
       *  @brief  Changing the current write position.
       *  @param  pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
      */
      __ostream_type&
      seekp(pos_type);
#pragma empty_line
      /**
       *  @brief  Changing the current write position.
       *  @param  off  A file offset object.
       *  @param  dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
      */
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
#pragma empty_line
    protected:
      explicit
      basic_ostream() { }
#pragma empty_line
      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
#pragma empty_line
  /**
   *  @brief  Performs setup work for output streams.
   *
   *  Objects of this class are created before all of the standard
   *  inserters are run.  It is responsible for "exception-safe prefix and
   *  suffix operations."  Additional actions may be added by the
   *  implementation, and we list them in
   *  http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/howto.html#5
   *  under [27.6] notes.
  */
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
      // Data Members:
      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;
#pragma empty_line
    public:
      /**
       *  @brief  The constructor performs preparatory work.
       *  @param  os  The output stream to guard.
       *
       *  If the stream state is good (@a os.good() is true), then if the
       *  stream is tied to another output stream, @c is.tie()->flush()
       *  is called to synchronize the output sequences.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true ("okay").
      */
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
#pragma empty_line
      /**
       *  @brief  Possibly flushes the stream.
       *
       *  If @c ios_base::unitbuf is set in @c os.flags(), and
       *  @c std::uncaught_exception() is true, the sentry destructor calls
       *  @c flush() on the output stream.
      */
      ~sentry()
      {
 // XXX MT
 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {
     // Can't call flush directly or else will get into recursive lock.
     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma empty_line
      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */
      operator bool() const
      { return _M_ok; }
    };
#pragma empty_line
  // [27.6.2.5.4] character insertion templates
  //@{
  /**
   *  @brief  Character inserters
   *  @param  out  An output stream.
   *  @param  c  A character.
   *  @return  out
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts a single character and any required
   *  padding (as determined by [22.2.2.2.2]).  @c out.width(0) is then
   *  called.
   *
   *  If @a c is of type @c char and the character type of the stream is not
   *  @c char, the character is widened before insertion.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }
#pragma empty_line
  // Specialization
  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }
#pragma empty_line
  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  //@}
#pragma empty_line
  //@{
  /**
   *  @brief  String inserters
   *  @param  out  An output stream.
   *  @param  s  A character string.
   *  @return  out
   *  @pre  @a s must be a non-NULL pointer
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts @c traits::length(s) characters starting
   *  at @a s, widened if necessary, followed by any required padding (as
   *  determined by [22.2.2.2.2]).  @c out.width(0) is then called.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
#pragma empty_line
  // Partial specializationss
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
#pragma empty_line
  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  //@}
#pragma empty_line
  // [27.6.2.7] standard basic_ostream manipulators
  /**
   *  @brief  Write a newline and flush the stream.
   *
   *  This manipulator is often mistakenly used when a simple newline is
   *  desired, leading to poor buffering performance.  See
   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2 for more
   *  on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
#pragma empty_line
  /**
   *  @brief  Write a null character into the output sequence.
   *
   *  "Null character" is @c CharT() by definition.  For CharT of @c char,
   *  this correctly writes the ASCII @c NUL character string terminator.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }
#pragma empty_line
  /**
   *  @brief  Flushes the output stream.
   *
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream.tcc" 1 3
// ostream classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ostream.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.6.2  Output streams
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream.tcc" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2002, 2003 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
/** @file locale
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file localefwd.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_classes.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_classes.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.h" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file locale_facets.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 1 3
// The template and inlines for the numeric_limits classes. -*- C++ -*- 
#pragma empty_line
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2005 
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file limits
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>
#pragma empty_line
//
// ISO 14882:1998
// 18.2.1
//
#pragma line 42 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/typeinfo" 1 3
// RTTI support for -*- C++ -*-
// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file typeinfo
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/exception" 1 3
// Exception Handling support header for -*- C++ -*-
#pragma empty_line
// Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
// 2004, 2005, 2006, 2007
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file exception
 *  This is a Standard C++ Library header.
 */
#pragma line 40 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/typeinfo" 2 3
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
extern "C++" {
#pragma empty_line
namespace __cxxabiv1
{
  class __class_type_info;
} // namespace __cxxabiv1
#pragma line 60 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/typeinfo" 3
namespace std
{
  /**
   *  @brief  Part of RTTI.
   *
   *  The @c type_info class describes type information generated by
   *  an implementation.
  */
  class type_info
  {
  public:
    /** Destructor. Being the first non-inline virtual function, this
     *  controls in which translation unit the vtable is emitted. The
     *  compiler makes use of that information to know where to emit
     *  the runtime-mandated type_info structures in the new-abi.  */
    virtual ~type_info();
#pragma empty_line
  private:
    /// Assigning type_info is not supported.  Made private.
    type_info& operator=(const type_info&);
    type_info(const type_info&);
#pragma empty_line
  protected:
    const char *__name;
#pragma empty_line
  protected:
    explicit type_info(const char *__n): __name(__n) { }
#pragma empty_line
  public:
    // the public interface
    /** Returns an @e implementation-defined byte string; this is not
     *  portable between compilers!  */
    const char* name() const
    { return __name; }
#pragma empty_line
#pragma empty_line
    bool before(const type_info& __arg) const;
    // In old abi, or when weak symbols are not supported, there can
    // be multiple instances of a type_info object for one
    // type. Uniqueness must use the _name value, not object address.
    bool operator==(const type_info& __arg) const;
#pragma line 111 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
#pragma empty_line
    // the internal interface
  public:
    // return true if this is a pointer type of some kind
    virtual bool __is_pointer_p() const;
    // return true if this is a function type
    virtual bool __is_function_p() const;
#pragma empty_line
    // Try and catch a thrown type. Store an adjusted pointer to the
    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
    // type, then THR_OBJ is the pointer itself. OUTER indicates the
    // number of outer pointers, and whether they were const
    // qualified.
    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;
#pragma empty_line
    // internally used during catch matching
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };
#pragma empty_line
  /**
   *  @brief  Thrown during incorrect typecasting.
   *
   *  If you attempt an invalid @c dynamic_cast expression, an instance of
   *  this class (or something derived from this class) is thrown.  */
  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }
    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_cast() throw();
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };
#pragma empty_line
  /** If you use a NULL pointer in a @c typeid expression, this is thrown.  */
  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }
    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_typeid() throw();
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };
} // namespace std
#pragma empty_line
#pragma GCC visibility pop
#pragma empty_line
} // extern "C++"
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/streambuf_iterator.h" 1 3
// Streambuf iterators
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file streambuf_iterator.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma line 44 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ext/type_traits.h" 1 3
// -*- C++ -*-
#pragma empty_line
// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later
// version.
#pragma empty_line
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free
// software library without restriction.  Specifically, if other files
// instantiate templates or use macros or inline functions from this
// file, or you compile this file and link it with other files to
// produce an executable, this file does not by itself cause the
// resulting executable to be covered by the GNU General Public
// License.  This exception does not however invalidate any other
// reasons why the executable file might be covered by the GNU General
// Public License.
#pragma empty_line
/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
   ;
 }
      return locale(__tmp);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
#pragma empty_line
  /**
   *  @brief  Test for the presence of a facet.
   *
   *  has_facet tests the locale argument for the presence of the facet type
   *  provided as the template parameter.  Facets derived from the facet
   *  parameter will also return true.
   *
   *  @param  Facet  The facet type to test the presence of.
   *  @param  locale  The locale to test.
   *  @return  true if locale contains a facet of type Facet, else false.
  */
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
#pragma empty_line
  /**
   *  @brief  Return a facet.
   *
   *  use_facet looks for and returns a reference to a facet of type Facet
   *  where Facet is the template parameter.  If has_facet(locale) is true,
   *  there is a suitable facet to return.  It throws std::bad_cast if the
   *  locale doesn't contain a facet of type Facet.
   *
   *  @param  Facet  The facet type to access.
   *  @param  locale  The locale to use.
   *  @return  Reference to facet of type Facet.
   *  @throw  std::bad_cast if locale doesn't contain a facet of type Facet.
  */
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }
#pragma empty_line
  // Routine to access a cache for the facet.  If the cache didn't
  // exist before, it gets constructed on the fly.
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };
#pragma empty_line
  // Specializations.
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
  ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };
#pragma empty_line
  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     if (true)
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
  ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };
#pragma empty_line
  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
#pragma empty_line
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
#pragma empty_line
      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);
#pragma empty_line
      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;
#pragma empty_line
      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;
#pragma empty_line
      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();
#pragma empty_line
      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
#pragma empty_line
  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
#pragma empty_line
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);
#pragma empty_line
      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__mp.grouping()[0]) > 0);
#pragma empty_line
      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();
#pragma empty_line
      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;
#pragma empty_line
      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;
#pragma empty_line
      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;
#pragma empty_line
      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();
#pragma empty_line
      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
#pragma empty_line
#pragma empty_line
  // Used by both numeric and monetary facets.
  // Check to make sure that the __grouping_tmp string constructed in
  // money_get or num_get matches the canonical grouping for a given
  // locale.
  // __grouping_tmp is parsed L to R
  // 1,222,444 == __grouping_tmp of "\1\3\3"
  // __grouping is parsed R to L
  // 1,222,444 == __grouping of "\3" == "\3\3\3"
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();
#pragma empty_line
      // True if __beg becomes equal to __end.
      bool __testeof = __beg == __end;
#pragma empty_line
      // First check for sign.
      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }
#pragma empty_line
      // Next, look for leading zeros.
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }
#pragma empty_line
      // Only need acceptable digits for floating point numbers.
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
#pragma empty_line
      if (!__lc->_M_allocated)
 // "C" locale
 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {
  // Scientific notation.
  __xtrc += 'e';
  __found_sci = true;
#pragma empty_line
  // Remove optional plus or minus sign, if they exist.
  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;
#pragma empty_line
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {
     // According to 22.2.2.1.2, p8-9, first look for thousands_sep
     // and decimal_point.
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {
      // NB: Thousands separator at the beginning of a string
      // is a no-no, as is two consecutive thousands separators.
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   // NB: __convert_to_v will not assign __v and will
   // set the failbit.
   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {
      // If no grouping chars are seen, no grouping check
      // is applied. Therefore __found_grouping is adjusted
      // only if decimal_point comes after some thousands_sep.
      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {
      // Scientific notation.
      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;
#pragma empty_line
      // Remove optional plus or minus sign, if they exist.
      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }
#pragma empty_line
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
#pragma empty_line
      // Digit grouping is checked. If grouping and found_grouping don't
      // match, then get very very upset, and set failbit.
      if (__found_grouping.size())
        {
          // Add the ending grouping if a decimal or 'e'/'E' wasn't found.
   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);
#pragma empty_line
          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }
#pragma empty_line
      // Finish up.
      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();
#pragma empty_line
 // NB: Iff __basefield == 0, __base can change based on contents.
 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
#pragma empty_line
 // True if __beg becomes equal to __end.
 bool __testeof = __beg == __end;
#pragma empty_line
 // First check for sign.
 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }
#pragma empty_line
 // Next, look for leading zeros and check required digits
 // for base formats.
 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;
#pragma empty_line
     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }
#pragma empty_line
 // At this point, base is determined. If not hex, only allow
 // base digits as valid input.
 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);
#pragma empty_line
 // Extract.
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative ?
   -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
#pragma empty_line
 if (!__lc->_M_allocated)
   // "C" locale
   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;
#pragma empty_line
       if (__result > __smax)
  __testfail = true;
       else
  {
    __result *= __base;
    __testfail |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {
       // According to 22.2.2.1.2, p8-9, first look for thousands_sep
       // and decimal_point.
       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {
    // NB: Thousands separator at the beginning of a string
    // is a no-no, as is two consecutive thousands separators.
    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;
#pragma empty_line
    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testfail = true;
    else
      {
        __result *= __base;
        __testfail |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
#pragma empty_line
 // Digit grouping is checked. If grouping and found_grouping don't
 // match, then get very very upset, and set failbit.
 if (__found_grouping.size())
   {
     // Add the ending grouping.
     __found_grouping += static_cast<char>(__sep_pos);
#pragma empty_line
     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }
#pragma empty_line
 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;
#pragma empty_line
 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }
#pragma empty_line
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 17.  Bad bool parsing
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
   // Parse bool values as long.
          // NB: We can't just call do_get(long) here, as it might
          // refer to a derived class.
   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {
   // Parse bool values as alphanumeric.
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
#pragma empty_line
   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;
#pragma empty_line
       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = __c == __lc->_M_falsename[__n];
  else
    break;
#pragma empty_line
       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = __c == __lc->_M_truename[__n];
  else
    break;
#pragma empty_line
       if (!__testf && !__testt)
  break;
#pragma empty_line
       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;
#pragma empty_line
          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
#pragma line 864 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
      // Prepare for hex formatted input.
      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);
#pragma empty_line
      // LLVM LOCAL begin mainline
      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
#pragma empty_line
      _UIntPtrType __ul;
      // LLVM LOCAL end mainline
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
#pragma empty_line
      // Reset from hex formatted input.
      __io.flags(__fmt);
#pragma empty_line
      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
#pragma empty_line
  // For use by integer and floating-point types after they have been
  // converted into a char_type string.
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {
      // [22.2.2.2.2] Stage 3.
      // If necessary, pad.
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {
   // Decimal.
   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {
   // Octal.
   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {
   // Hex.
   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();
#pragma empty_line
 // Long enough to hold hex, dec, and octal representations.
 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));
#pragma empty_line
 // [22.2.2.2.2] Stage 1, numeric conversion to character.
 // Result is returned right-justified in the buffer.
 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = (__v > 0 || !__dec) ? __v : -__v;
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;
#pragma empty_line
 // Add grouping, if necessary.
 if (__lc->_M_use_grouping)
   {
     // Grouping can add (almost) as many separators as the number
     // of digits + space is reserved for numeric base or sign.
     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }
#pragma empty_line
 // Complete Stage 1, prepend numeric base or sign.
 if (__builtin_expect(__dec, true))
   {
     // Decimal.
     if (__v > 0)
       {
  if (__flags & ios_base::showpos
      && numeric_limits<_ValueT>::is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else if (__v)
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (__flags & ios_base::showbase && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {
  // 'x' or 'X'
  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];
  // '0'
  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }
#pragma empty_line
 // Pad.
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);
#pragma empty_line
 // [22.2.2.2.2] Stage 4.
 // Write resulting, fully-formatted string to output iterator.
 return std::__write(__s, __cs, __len);
      }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 282. What types does numpunct grouping refer to?
      // Add grouping, if necessary.
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);
#pragma empty_line
      // Tack on decimal part.
      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
#pragma empty_line
  // The following code uses vsnprintf (or vsprintf(), when
  // _GLIBCXX_USE_C99 is not defined) to convert floating point values
  // for insertion into a stream.  An optimization would be to replace
  // them with code that works directly on a wide buffer and then use
  // __pad to do the padding.  It would be good to replace them anyway
  // to gain back the efficiency that C++ provides by knowing up front
  // the type of the values to insert.  Also, sprintf is dangerous
  // since may lead to accidental buffer overruns.  This
  // implementation follows the C++ standard fairly directly as
  // outlined in 22.2.2.2 [lib.locale.num.put]
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
#pragma empty_line
 // Use default precision if out of range.
 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
#pragma empty_line
 const int __max_digits = numeric_limits<_ValueT>::digits10;
#pragma empty_line
 // [22.2.2.2.2] Stage 1, numeric conversion to character.
 int __len;
 // Long enough for the max format spec.
 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);
#pragma empty_line
#pragma empty_line
 // First try a buffer perhaps big enough (most probably sufficient
 // for non-ios_base::fixed outputs)
 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);
#pragma empty_line
 // If the buffer was not large enough, try again with the correct size.
 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
#pragma line 1156 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
 // [22.2.2.2.2] Stage 2, convert to char_type, using correct
 // numpunct.decimal_point() values for '.' and adding grouping.
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);
#pragma empty_line
 // Replace decimal point.
 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }
#pragma empty_line
 // Add grouping, if necessary.
 // N.B. Make sure to not group things like 2e20, i.e., no decimal
 // point, scientific notation.
 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {
     // Grouping can add (almost) as many separators as the
     // number of digits, but no more.
     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
#pragma empty_line
     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }
#pragma empty_line
     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;
#pragma empty_line
     __ws = __ws2;
   }
#pragma empty_line
 // Pad.
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);
#pragma empty_line
 // [22.2.2.2.2] Stage 4.
 // Write resulting, fully-formatted string to output iterator.
 return std::__write(__s, __ws, __len);
      }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
#pragma empty_line
   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;
#pragma empty_line
   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#pragma line 1297 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));
#pragma empty_line
      // LLVM LOCAL begin mainline
      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
#pragma empty_line
      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      // LLVM LOCAL end mainline
      __io.flags(__flags);
      return __s;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
#pragma empty_line
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
#pragma empty_line
 // Deduced sign.
 bool __negative = false;
 // Sign size.
 size_type __sign_size = 0;
 // True if sign is mandatory.
 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);
 // String of grouping info from thousands_sep plucked from __units.
 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);
 // Last position before the decimal point.
 int __last_pos = 0;
 // Separator positions, then, possibly, fractional digits.
 int __n = 0;
 // If input iterator is in a valid state.
 bool __testvalid = true;
 // Flag marking when a decimal point is found.
 bool __testdecfound = false;
#pragma empty_line
 // The tentative returned string is stored here.
 string __res;
 __res.reserve(32);
#pragma empty_line
 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:
  // According to 22.2.6.1.2, p2, symbol is required
  // if (__io.flags() & ios_base::showbase), otherwise
  // is optional and consumed only if other characters
  // are needed to complete the format.
  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:
  // Sign might not exist, or be more than one character long.
  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)
    // "... if no sign is detected, the result is given the sign
    // that corresponds to the source of the empty string"
    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:
  // Extract digits, remove and stash away the
  // grouping of found thousands separators.
  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {
       // Mark position for later analysis.
       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:
  // At least one space is required.
  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:
  // Only if not at the end of the pattern.
  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }
#pragma empty_line
 // Need to get the rest of the sign characters, if they exist.
 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);
#pragma empty_line
     if (__i != __sign_size)
       __testvalid = false;
   }
#pragma empty_line
 if (__testvalid)
   {
     // Strip leading zeros.
     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }
#pragma empty_line
     // 22.2.6.1.2, p4
     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');
#pragma empty_line
     // Test for grouping fidelity.
     if (__grouping_tmp.size())
       {
  // Add the ending grouping.
  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }
#pragma empty_line
     // Iff not enough digits were supplied after the decimal-point.
     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }
#pragma empty_line
 // Iff valid sequence is not recognized.
 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);
#pragma empty_line
 // Iff no more characters are available.
 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
#pragma line 1559 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;
#pragma empty_line
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
#pragma empty_line
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
#pragma empty_line
 // Determine if negative or positive formats are to be used, and
 // discard leading negative_sign if it is present.
 const char_type* __beg = __digits.data();
#pragma empty_line
 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }
#pragma empty_line
 // Look for valid numbers in the ctype facet within input digits.
 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {
     // Assume valid input, and attempt to format.
     // Break down input numbers into base components, as follows:
     //   final_value = grouped units + (decimal point) + (digits)
     string_type __value;
     __value.reserve(2 * __len);
#pragma empty_line
     // Add thousands separators to non-decimal digits, per
     // grouping rules.
     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }
#pragma empty_line
     // Deal with decimal point, decimal digits.
     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {
      // Have to pad zeros in the decimal position.
      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }
#pragma empty_line
     // Calculate length of resulting string.
     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);
#pragma empty_line
     string_type __res;
     __res.reserve(2 * __len);
#pragma empty_line
     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);
     // Fit formatted digits into the required pattern.
     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:
      // Sign might not exist, or be more than one
      // charater long. In that case, add in the rest
      // below.
      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:
      // At least one space is required, but if internal
      // formatting is required, an arbitrary number of
      // fill spaces will be necessary.
      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }
#pragma empty_line
     // Special case of multi-part sign parts.
     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);
#pragma empty_line
     // Pad, if still necessary.
     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)
    // After.
    __res.append(__width - __len, __fill);
  else
    // Before.
    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }
#pragma empty_line
     // Write resulting, fully-formatted string to output iterator.
     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
#pragma line 1764 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
      // First try a buffer perhaps big enough.
      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 328. Bad sprintf format modifier in money_put<>::do_put()
      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
      // If the buffer was not large enough, try again with the correct size.
      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  // NB: Not especially useful. Without an ios_base object or some
  // kind of locale reference, we are left clawing at the air where
  // the side of the mountain used to be...
  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }
#pragma empty_line
  // Expand a strftime format string and parse it.  E.g., do_get_date() may
  // pass %m/%d/%Y => extracted characters.
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);
#pragma empty_line
      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {
       // Verify valid formatting code, attempt to extract.
       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':
    // Abbreviated weekday name [tm_wday]
    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':
    // Weekday name [tm_wday].
    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':
    // Abbreviated month name [tm_mon]
    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':
    // Month name [tm_mon].
    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':
    // Default time and date representation.
    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':
    // Day [01, 31]. [tm_mday]
    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':
    // Day [1, 31], with single digits preceded by
    // space. [tm_mday]
    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':
    // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]
    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':
    // Hour [00, 23]. [tm_hour]
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':
    // Hour [01, 12]. [tm_hour]
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':
    // Month [01, 12]. [tm_mon]
    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':
    // Minute [00, 59]. [tm_min]
    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':
    // Equivalent to (%H:%M).
    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':
    // Seconds. [tm_sec]
    // [00, 60] in C99 (one leap-second), [00, 61] in C89.
#pragma empty_line
    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':
    // Equivalent to (%H:%M:%S).
    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':
    // Locale's date.
    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':
    // Locale's time.
    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C': // C99
    // Two digit year. [tm_year]
    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __tmperr);
    break;
  case 'Y':
    // Year [1900). [tm_year]
    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':
    // Timezone info.
    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);
#pragma empty_line
        // GMT requires special effort.
        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:
    // Not recognized.
    __tmperr |= ios_base::failbit;
  }
     }
   else
     {
       // Verify format and input match, extract and discard.
       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }
#pragma empty_line
      if (__tmperr)
 __err |= ios_base::failbit;
#pragma empty_line
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
      // As-is works for __len = 1, 2, 4, the values actually used.
      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);
#pragma empty_line
      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;
#pragma empty_line
      return __beg;
    }
#pragma empty_line
  // Assumptions:
  // All elements in __names are unique.
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;
#pragma empty_line
      // Look for initial matches.
      // NB: Some of the locale data is in the form of all lowercase
      // names, and some is in the form of initially-capitalized
      // names. Look for both.
      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }
#pragma empty_line
      while (__nmatches > 1)
 {
   // Find smallest matching string.
   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }
#pragma empty_line
      if (__nmatches == 1)
 {
   // Make sure found name is completely extracted.
   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;
#pragma empty_line
   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
#pragma empty_line
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,
         __io, __tmperr);
#pragma empty_line
      // Check to see if non-abbreviated name exists, and extract.
      // NB: Assumes both _M_days and _M_days_abbreviated organized in
      // exact same order, first to last, such that the resulting
      // __days array with the same index points to a day, and that
      // day's abbreviated form.
      // NB: Also assumes that an abbreviated name is a subset of the name.
      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {
       // Extract the rest of it.
       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;
#pragma empty_line
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __tmperr);
#pragma empty_line
      // Check to see if non-abbreviated name exists, and extract.
      // NB: Assumes both _M_months and _M_months_abbreviated organized in
      // exact same order, first to last, such that the resulting
      // __months array with the same index points to a month, and that
      // month's abbreviated form.
      // NB: Also assumes that an abbreviated name is a subset of the name.
      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {
       // Extract the rest of it.
       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;
#pragma empty_line
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;
#pragma empty_line
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
#pragma empty_line
      // NB: This size is arbitrary. Should this be a data member,
      // initialized at construction?
      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));
#pragma empty_line
      // NB: In IEE 1003.1-200x, and perhaps other locale models, it
      // is possible that the format character will be longer than one
      // character. Possibilities include 'E' or 'O' followed by a
      // format character: if __mod is not the default argument, assume
      // it's a valid modifier.
      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }
#pragma empty_line
      __tp._M_put(__res, __maxlen, __fmt, __tm);
#pragma empty_line
      // Write resulting, fully-formatted string to output iterator.
      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }
#pragma empty_line
  // Generic version does nothing.
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }
#pragma empty_line
  // Generic version does nothing.
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }
#pragma empty_line
  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {
      // strcoll assumes zero-terminated strings so we make a copy
      // and then put a zero at the end.
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);
#pragma empty_line
      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();
#pragma empty_line
      // strcoll stops when it sees a nul character so we break
      // the strings into zero-terminated substrings and pass those
      // to strcoll.
      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;
#pragma empty_line
   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;
#pragma empty_line
   __p++;
   __q++;
 }
    }
#pragma empty_line
  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;
#pragma empty_line
      // strxfrm assumes zero-terminated strings so we make a copy
      const string_type __str(__lo, __hi);
#pragma empty_line
      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();
#pragma empty_line
      size_t __len = (__hi - __lo) * 2;
#pragma empty_line
      _CharT* __c = new _CharT[__len];
#pragma empty_line
      if (true)
 {
   // strxfrm stops when it sees a nul character so we break
   // the string into zero-terminated substrings and pass those
   // to strxfrm.
   for (;;)
     {
       // First try a buffer perhaps big enough.
       size_t __res = _M_transform(__c, __p, __len);
       // If the buffer was not large enough, try again with the
       // correct size.
       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }
#pragma empty_line
       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;
#pragma empty_line
       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
   ;
 }
#pragma empty_line
      delete [] __c;
#pragma empty_line
      return __ret;
    }
#pragma empty_line
  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
#pragma empty_line
  // Construct correctly padded string, as per 22.2.2.2.2
  // Assumes
  // __newlen > __oldlen
  // __news is allocated for __newlen size
  // Used by both num_put and ostream inserters: if __num,
  // internal-adjusted objects are padded according to the rules below
  // concerning 0[xX] and +-, otherwise, exactly as right-adjusted
  // ones are.
#pragma empty_line
  // NB: Of the two parameters, _CharT can be deduced from the
  // function arguments. The other (_Traits) has to be explicitly specified.
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
#pragma empty_line
      // Padding last.
      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }
#pragma empty_line
      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {
   // Pad after the sign, if there is one.
   // Pad after 0[xX], if there is one.
   // Who came up with these rules, anyway? Jeeze.
          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   // else Padding first.
 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }
#pragma empty_line
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, size_t(__grouping_size - 1));
    size_t __i = __n;
    bool __test = true;
#pragma empty_line
    // Parsed number groupings have to match the
    // numpunct::grouping string exactly, starting at the
    // right-most point of the parsed sequence of elements ...
    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];
    // ... but the first parsed grouping can be <= numpunct
    // grouping (only do the check if the numpunct char is > 0
    // because <= 0 means any size is ok).
    if (static_cast<signed char>(__grouping[__min]) > 0)
      __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }
#pragma empty_line
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;
#pragma empty_line
      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }
#pragma empty_line
      while (__first != __last)
 *__s++ = *__first++;
#pragma empty_line
      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
#pragma empty_line
      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
#pragma empty_line
      return __s;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB: This syntax is a GNU extension.
#pragma empty_line
  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;
#pragma empty_line
  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);
#pragma empty_line
  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);
#pragma empty_line
  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);
#pragma empty_line
  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);
#pragma empty_line
  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);
#pragma empty_line
  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);
#pragma empty_line
  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);
#pragma empty_line
  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);
#pragma empty_line
  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);
#pragma empty_line
  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);
#pragma empty_line
  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);
#pragma empty_line
  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);
#pragma empty_line
  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<ctype<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<collate<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<numpunct<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_put<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_get<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<money_put<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<money_get<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<time_put<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<time_get<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<messages<char> >(const locale&);
#pragma empty_line
#pragma empty_line
  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;
#pragma empty_line
  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);
#pragma empty_line
  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);
#pragma empty_line
  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);
#pragma empty_line
  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);
#pragma empty_line
 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 2 3
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/ostream.tcc" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
      // XXX MT
      if (__os.tie() && __os.good())
 __os.tie()->flush();
#pragma empty_line
      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::put(char_type) is an unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::write(const char_type*, streamsize) is an
      // unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::flush() is *not* an unformatted output function.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);
#pragma empty_line
       // 129. Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);
#pragma empty_line
       // 129. Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 167.  Improper use of traits_type::length()
   const size_t __clen = char_traits<char>::length(__s);
   _CharT* __ws = 0;
   if (true)
     {
       __ws = new _CharT[__clen];
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
     }
   if (false)
     {
       delete [] __ws;
       __out._M_setstate(ios_base::badbit);
       return __out;
     }
#pragma empty_line
   if (true)
     {
       __ostream_insert(__out, __ws, __clen);
       delete [] __ws;
     }
   if (false)
     {
       delete [] __ws;
       ;
     }
 }
      return __out;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB:  This syntax is a GNU extension.
#pragma empty_line
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
#pragma empty_line
  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);
#pragma empty_line
  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);
#pragma empty_line
  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);
#pragma empty_line
#pragma empty_line
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
#pragma empty_line
  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);
#pragma empty_line
  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);
#pragma empty_line
  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 573 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 2 3
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iostream" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/istream" 1 3
// Input streams -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
//
// ISO C++ 14882: 27.6.1  Input streams
//
#pragma empty_line
/** @file istream
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 43 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/istream" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ios" 1 3
// Iostreams base classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ios
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.4  Iostreams base classes
//
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/istream" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/limits" 1 3
// The template and inlines for the numeric_limits classes. -*- C++ -*- 
#pragma empty_line
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2005 
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file limits
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>
#pragma empty_line
//
// ISO 14882:1998
// 18.2.1
//
#pragma line 46 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/istream" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  // [27.6.1.1] Template class basic_istream
  /**
   *  @brief  Controlling input.
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios (27.4.4)):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);
#pragma empty_line
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
#pragma empty_line
    protected:
      // Data Members:
      /**
       *  @if maint
       *  The number of characters extracted in the previous unformatted
       *  function; see gcount().
       *  @endif
      */
      streamsize _M_gcount;
#pragma empty_line
    public:
      // [27.6.1.1.1] constructor/destructor
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }
#pragma empty_line
      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
#pragma empty_line
      // [27.6.1.1.2] prefix/suffix
      class sentry;
      friend class sentry;
#pragma empty_line
      // [27.6.1.2] formatted input
      // [27.6.1.2.3] basic_istream::operator>>
      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manuipulators such as @c std::ws and @c std::dec use these
       *  functions in constructs like "std::cin >> std::ws".  For more
       *  information, see the iomanip header.
      */
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }
#pragma empty_line
      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }
#pragma empty_line
      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
      //@}
#pragma empty_line
      // [27.6.1.2.2] arithmetic extractors
      /**
       *  @name Arithmetic Extractors
       *
       *  All the @c operator>> functions (aka <em>formatted input
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_istream::sentry
       *  with the second argument (noskipws) set to false.  This has several
       *  effects, concluding with the setting of a status flag; see the
       *  sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Basic arithmetic extractors
       *  @param  A variable of builtin type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      */
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(short& __n);
#pragma empty_line
      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(int& __n);
#pragma empty_line
      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }
#pragma empty_line
#pragma empty_line
      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
#pragma empty_line
#pragma empty_line
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
#pragma empty_line
      /**
       *  @brief  Extracting into another streambuf.
       *  @param  sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @a sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from this stream and inserted into the
       *  @a sb streambuf until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs (and in this case is caught)
       *
       *  If the function inserts no characters, failbit is set.
      */
      __istream_type&
      operator>>(__streambuf_type* __sb);
      //@}
#pragma empty_line
      // [27.6.1.3] unformatted input
      /**
       *  @brief  Character counting
       *  @return  The number of characters extracted by the previous
       *           unformatted input function dispatched for this stream.
      */
      streamsize
      gcount() const
      { return _M_gcount; }
#pragma empty_line
      /**
       *  @name Unformatted Input Functions
       *
       *  All the unformatted input functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_istream::sentry with the second argument (noskipws)
       *  set to true.  This has several effects, concluding with the
       *  setting of a status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  The number of characters extracted is stored for later retrieval
       *  by gcount().
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Simple extraction.
       *  @return  A character, or eof().
       *
       *  Tries to extract a character.  If none are available, sets failbit
       *  and returns traits::eof().
      */
      int_type
      get();
#pragma empty_line
      /**
       *  @brief  Simple extraction.
       *  @param  c  The character in which to store data.
       *  @return  *this
       *
       *  Tries to extract a character and store it in @a c.  If none are
       *  available, sets failbit and returns traits::eof().
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type& __c);
#pragma empty_line
      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  s  Pointer to an array.
       *  @param  n  Maximum number of characters to store in @a s.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and stored into @a s until one of the
       *  following happens:
       *
       *  - @c n-1 characters are stored
       *  - the input sequence reaches EOF
       *  - the next character equals @a delim, in which case the character
       *    is not extracted
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
       *
       * In any case, a null character is stored into the next location in
       * the array.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  s  Pointer to an array.
       *  @param  n  Maximum number of characters to store in @a s.
       *  @return  *this
       *
       *  Returns @c get(s,n,widen('\n')).
      */
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
#pragma empty_line
      /**
       *  @brief  Extraction into another streambuf.
       *  @param  sb  A streambuf in which to store data.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and inserted into @a sb until one of the
       *  following happens:
       *
       *  - the input sequence reaches EOF
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted)
       *  - the next character equals @a delim (in this case, the character
       *    is not extracted)
       *  - an exception occurs (and in this case is caught)
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
      */
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
#pragma empty_line
      /**
       *  @brief  Extraction into another streambuf.
       *  @param  sb  A streambuf in which to store data.
       *  @return  *this
       *
       *  Returns @c get(sb,widen('\n')).
      */
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
#pragma empty_line
      /**
       *  @brief  String extraction.
       *  @param  s  A character array in which to store the data.
       *  @param  n  Maximum number of characters to extract.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts and stores characters into @a s until one of the
       *  following happens.  Note that these criteria are required to be
       *  tested in the order listed here, to allow an input line to exactly
       *  fill the @a s array without setting failbit.
       *
       *  -# the input sequence reaches end-of-file, in which case eofbit
       *     is set in the stream error state
       *  -# the next character equals @c delim, in which case the character
       *     is extracted (and therefore counted in @c gcount()) but not stored
       *  -# @c n-1 characters are stored, in which case failbit is set
       *     in the stream error state
       *
       *  If no characters are extracted, failbit is set.  (An empty line of
       *  input should therefore not cause failbit to be set.)
       *
       *  In any case, a null character is stored in the next location in
       *  the array.
      */
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
      /**
       *  @brief  String extraction.
       *  @param  s  A character array in which to store the data.
       *  @param  n  Maximum number of characters to extract.
       *  @return  *this
       *
       *  Returns @c getline(s,n,widen('\n')).
      */
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
#pragma empty_line
      /**
       *  @brief  Discarding characters
       *  @param  n  Number of characters to discard.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts characters and throws them away until one of the
       *  following happens:
       *  - if @a n @c != @c std::numeric_limits<int>::max(), @a n
       *    characters are extracted
       *  - the input sequence reaches end-of-file
       *  - the next character equals @a delim (in this case, the character
       *    is extracted); note that this condition will never occur if
       *    @a delim equals @c traits::eof().
       *
       *  NB: Provide three overloads, instead of the single function
       *  (with defaults) mandated by the Standard: this leads to a
       *  better performing implementation, while still conforming to
       *  the Standard.
      */
      __istream_type&
      ignore();
#pragma empty_line
      __istream_type&
      ignore(streamsize __n);
#pragma empty_line
      __istream_type&
      ignore(streamsize __n, int_type __delim);
#pragma empty_line
      /**
       *  @brief  Looking ahead in the stream
       *  @return  The next character, or eof().
       *
       *  If, after constructing the sentry object, @c good() is false,
       *  returns @c traits::eof().  Otherwise reads but does not extract
       *  the next input character.
      */
      int_type
      peek();
#pragma empty_line
      /**
       *  @brief  Extraction without delimiters.
       *  @param  s  A character array.
       *  @param  n  Maximum number of characters to store.
       *  @return  *this
       *
       *  If the stream state is @c good(), extracts characters and stores
       *  them into @a s until one of the following happens:
       *  - @a n characters are stored
       *  - the input sequence reaches end-of-file, in which case the error
       *    state is set to @c failbit|eofbit.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      read(char_type* __s, streamsize __n);
#pragma empty_line
      /**
       *  @brief  Extraction until the buffer is exhausted, but no more.
       *  @param  s  A character array.
       *  @param  n  Maximum number of characters to store.
       *  @return  The number of characters extracted.
       *
       *  Extracts characters and stores them into @a s depending on the
       *  number of characters remaining in the streambuf's buffer,
       *  @c rdbuf()->in_avail(), called @c A here:
       *  - if @c A @c == @c -1, sets eofbit and extracts no characters
       *  - if @c A @c == @c 0, extracts no characters
       *  - if @c A @c > @c 0, extracts @c min(A,n)
       *
       *  The goal is to empty the current buffer, and to not request any
       *  more from the external input sequence controlled by the streambuf.
      */
      streamsize
      readsome(char_type* __s, streamsize __n);
#pragma empty_line
      /**
       *  @brief  Unextracting a single character.
       *  @param  c  The character to push back into the input stream.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
       *
       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
       *  the error state.
       *
       *  @note  Since no characters are extracted, the next call to
       *         @c gcount() will return 0, as required by DR 60.
      */
      __istream_type&
      putback(char_type __c);
#pragma empty_line
      /**
       *  @brief  Unextracting the previous character.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
       *
       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
       *  the error state.
       *
       *  @note  Since no characters are extracted, the next call to
       *         @c gcount() will return 0, as required by DR 60.
      */
      __istream_type&
      unget();
#pragma empty_line
      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  0 on success, -1 on failure
       *
       *  If @c rdbuf() is a null pointer, returns -1.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit and returns -1.
       *
       *  Otherwise, returns 0.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      int
      sync();
#pragma empty_line
      /**
       *  @brief  Getting the current read position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      pos_type
      tellg();
#pragma empty_line
      /**
       *  @brief  Changing the current read position.
       *  @param  pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      __istream_type&
      seekg(pos_type);
#pragma empty_line
      /**
       *  @brief  Changing the current read position.
       *  @param  off  A file offset object.
       *  @param  dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      __istream_type&
      seekg(off_type, ios_base::seekdir);
      //@}
#pragma empty_line
    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }
#pragma empty_line
      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };
#pragma empty_line
  // Explicit specialization declarations, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);
#pragma empty_line
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#pragma empty_line
#pragma empty_line
  /**
   *  @brief  Performs setup work for input streams.
   *
   *  Objects of this class are created before all of the standard
   *  extractors are run.  It is responsible for "exception-safe prefix and
   *  suffix operations," although only prefix actions are currently required
   *  by the standard.  Additional actions may be added by the
   *  implementation, and we list them in
   *  http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/howto.html#5
   *  under [27.6] notes.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:
      /// Easy access to dependant types.
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
#pragma empty_line
      /**
       *  @brief  The constructor performs all the work.
       *  @param  is  The input stream to guard.
       *  @param  noskipws  Whether to consume whitespace or not.
       *
       *  If the stream state is good (@a is.good() is true), then the
       *  following actions are performed, otherwise the sentry state is
       *  false ("not okay") and failbit is set in the stream state.
       *
       *  The sentry's preparatory actions are:
       *
       *  -# if the stream is tied to an output stream, @c is.tie()->flush()
       *     is called to synchronize the output sequence
       *  -# if @a noskipws is false, and @c ios_base::skipws is set in
       *     @c is.flags(), the sentry extracts and discards whitespace
       *     characters from the stream.  The currently imbued locale is
       *     used to determine whether each character is whitespace.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true ("okay").
      */
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
#pragma empty_line
      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */
      operator bool() const
      { return _M_ok; }
#pragma empty_line
    private:
      bool _M_ok;
    };
#pragma empty_line
  // [27.6.1.2.3] character extraction templates
  //@{
  /**
   *  @brief  Character extractors
   *  @param  in  An input stream.
   *  @param  c  A character reference.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts a character (if one is available) and
   *  stores it in @a c.  Otherwise, sets failbit in the input stream.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  //@}
#pragma empty_line
  //@{
  /**
   *  @brief  Character string extractors
   *  @param  in  An input stream.
   *  @param  s  A pointer to a character array.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts up to @c n characters and stores them
   *  into the array starting at @a s.  @c n is defined as:
   *
   *  - if @c width() is greater than zero, @c n is width()
   *  - otherwise @c n is "the number of elements of the largest array of
   *    @c char_type that can store a terminating @c eos." [27.6.1.2.3]/6
   *
   *  Characters are extracted and stored until one of the following happens:
   *  - @c n-1 characters are stored
   *  - EOF is reached
   *  - the next character is whitespace according to the current locale
   *  - the next character is a null byte (i.e., @c charT() )
   *
   *  @c width(0) is then called for the input stream.
   *
   *  If no characters are extracted, sets failbit.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);
#pragma empty_line
  // Explicit specialization declaration, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  //@}
#pragma empty_line
  // 27.6.1.5 Template class basic_iostream
  /**
   *  @brief  Merging istream and ostream capabilities.
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
  */
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 271. basic_iostream missing typedefs
      // Types (inherited):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
      // Non-standard Types:
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
#pragma empty_line
      /**
       *  @brief  Constructor does nothing.
       *
       *  Both of the parent classes are initialized with the same
       *  streambuf pointer passed to this constructor.
      */
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }
#pragma empty_line
      /**
       *  @brief  Destructor does nothing.
      */
      virtual
      ~basic_iostream() { }
#pragma empty_line
    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
#pragma empty_line
  // [27.6.1.4] standard basic_istream manipulators
  /**
   *  @brief  Quick and easy way to eat whitespace
   *
   *  This manipulator extracts whitespace characters, stopping when the
   *  next character is non-whitespace, or when the input sequence is empty.
   *  If the sequence is empty, @c eofbit is set in the stream, but not
   *  @c failbit.
   *
   *  The current locale is used to distinguish whitespace characters.
   *
   *  Example:
   *  @code
   *     MyClass   mc;
   *
   *     std::cin >> std::ws >> mc;
   *  @endcode
   *  will skip leading whitespace before calling operator>> on cin and your
   *  object.  Note that the same effect can be achieved by creating a
   *  std::basic_istream::sentry inside your definition of operator>>.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/istream.tcc" 1 3
// istream classes -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file istream.tcc
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.6.1  Input streams
//
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 45 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/istream.tcc" 3
#pragma empty_line
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/locale" 1 3
// Locale support -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2002, 2003 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
//
// ISO C++ 14882: 22.1  Locales
//
#pragma empty_line
/** @file locale
 *  This is a Standard C++ Library header.
 */
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/istream.tcc" 2 3
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/ostream" 1 3
// Output streams -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file ostream
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 27.6.2  Output streams
//
#pragma line 48 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/bits/istream.tcc" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
#pragma empty_line
       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();
#pragma empty_line
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 195. Should basic_istream::sentry's constructor ever
       // set eofbit?
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }
#pragma empty_line
      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<short>::min() <= __l
       && __l <= numeric_limits<short>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<int>::min() <= __l
       && __l <= numeric_limits<int>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();
       // 27.6.1.1 paragraph 3
       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();
       // 27.6.1.1 paragraph 3
       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();
#pragma empty_line
       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
#pragma empty_line
       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma empty_line
              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }
#pragma empty_line
  // We provide three overloads, since the first two are much simpler
  // than the general case. Also, the latter two can thus adopt the
  // same "batchy" strategy used by getline above.
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
#pragma empty_line
       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma empty_line
       // N.B. On LFS-enabled platforms streamsize is still 32 bits
       // wide: if we want to implement the standard mandated behavior
       // for n == max() (see 27.6.1.3/24) we are at risk of signed
       // integer overflow: thus these contortions. Also note that,
       // by definition, when more than 2G chars are actually ignored,
       // _M_gcount (the return value of gcount, that is) cannot be
       // really correct, being unavoidably too small.
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }
#pragma empty_line
       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();
#pragma empty_line
       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma empty_line
       // See comment above.
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }
#pragma empty_line
       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();
#pragma empty_line
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount < numeric_limits<streamsize>::max())
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       // Cannot compare int_type with streamsize generically.
       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);
#pragma empty_line
       // 129.  Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);
#pragma empty_line
       // 129.  Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  // 27.6.1.2.3 Character extraction templates
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
#pragma empty_line
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {
       // Figure out how many characters to extract.
       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();
#pragma empty_line
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
#pragma empty_line
       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();
#pragma empty_line
       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
#pragma empty_line
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 68.  Extractors for char* should store null at end
       *__s = char_type();
       __in.width(0);
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
  // 27.6.1.4 Standard basic_istream manipulators
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;
#pragma empty_line
      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();
#pragma empty_line
      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }
#pragma empty_line
  // 21.3.7.9 basic_string::getline and operators
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
#pragma empty_line
      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {
       // Avoid reallocation for common case.
       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
#pragma empty_line
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 91. Description of operator>> and getline() for string<>
       // might cause endless loop
       __in._M_setstate(ios_base::badbit);
     }
 }
      // 211.  operator>>(istream&, string&) doesn't set failbit
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
#pragma empty_line
      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
#pragma empty_line
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   if (false)
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 91. Description of operator>> and getline() for string<>
       // might cause endless loop
       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
  // NB:  This syntax is a GNU extension.
#pragma empty_line
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);
#pragma empty_line
  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);
#pragma empty_line
  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);
#pragma empty_line
  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);
#pragma empty_line
  extern template class basic_iostream<char>;
#pragma empty_line
#pragma empty_line
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
#pragma empty_line
  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);
#pragma empty_line
  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);
#pragma empty_line
  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);
#pragma empty_line
  extern template class basic_iostream<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 846 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/istream" 2 3
#pragma line 47 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/iostream" 2 3
#pragma empty_line
namespace std {
#pragma empty_line
  /**
   *  @name Standard Stream Objects
   *
   *  The &lt;iostream&gt; header declares the eight <em>standard stream
   *  objects</em>.  For other declarations, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#10 and the
   *  @link s27_2_iosfwd I/O forward declarations @endlink
   *
   *  They are required by default to cooperate with the global C library's
   *  @c FILE streams, and to be available during program startup and
   *  termination.  For more information, see the HOWTO linked to above.
  */
  //@{
  extern istream cin; ///< Linked to standard input
  extern ostream cout; ///< Linked to standard output
  extern ostream cerr; ///< Linked to standard error (unbuffered)
  extern ostream clog; ///< Linked to standard error (buffered)
#pragma empty_line
#pragma empty_line
  extern wistream wcin; ///< Linked to standard input
  extern wostream wcout; ///< Linked to standard output
  extern wostream wcerr; ///< Linked to standard error (unbuffered)
  extern wostream wclog; ///< Linked to standard error (buffered)
#pragma empty_line
  //@}
#pragma empty_line
  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
#pragma empty_line
}
#pragma line 23 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 1 3
/* 
 * math.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Mathematical functions.
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 17 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
#pragma empty_line
#pragma empty_line
/* All the headers include this file. */
#pragma empty_line
#pragma empty_line
/*
 * Types for the _exception structure.
 */
#pragma line 33 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/*
 * Exception types with non-ANSI names for compatibility.
 */
#pragma line 51 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* Traditional/XOPEN math constants (double precison) */
#pragma line 68 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* These are also defined in Mingw float.h; needed here as well to work 
   around GCC build issues.  */
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* IEEE 754 classication */
#pragma line 90 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
/*
 * HUGE_VAL is returned by strtod when the value would overflow the
 * representation of 'double'. There are other uses as well.
 *
 * __imp__HUGE is a pointer to the actual variable _HUGE in
 * MSVCRT.DLL. If we used _HUGE directly we would get a pointer
 * to a thunk function.
 *
 * NOTE: The CRTDLL version uses _HUGE_dll instead.
 */
#pragma line 134 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
struct _exception
{
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};
#pragma empty_line
 double __attribute__((__cdecl__)) sin (double);
 double __attribute__((__cdecl__)) cos (double);
 double __attribute__((__cdecl__)) tan (double);
 double __attribute__((__cdecl__)) sinh (double);
 double __attribute__((__cdecl__)) cosh (double);
 double __attribute__((__cdecl__)) tanh (double);
 double __attribute__((__cdecl__)) asin (double);
 double __attribute__((__cdecl__)) acos (double);
 double __attribute__((__cdecl__)) atan (double);
 double __attribute__((__cdecl__)) atan2 (double, double);
 double __attribute__((__cdecl__)) exp (double);
 double __attribute__((__cdecl__)) log (double);
 double __attribute__((__cdecl__)) log10 (double);
 double __attribute__((__cdecl__)) pow (double, double);
 double __attribute__((__cdecl__)) sqrt (double);
 double __attribute__((__cdecl__)) ceil (double);
 double __attribute__((__cdecl__)) floor (double);
 double __attribute__((__cdecl__)) fabs (double);
 double __attribute__((__cdecl__)) ldexp (double, int);
 double __attribute__((__cdecl__)) frexp (double, int*);
 double __attribute__((__cdecl__)) modf (double, double*);
 double __attribute__((__cdecl__)) fmod (double, double);
#pragma empty_line
/* Excess precision when using a 64-bit mantissa for FPU math ops can
   cause unexpected results with some of the MSVCRT math functions.  For
   example, unless the function return value is stored (truncating to
   53-bit mantissa), calls to pow with both x and y as integral values
   sometimes produce a non-integral result.
   One workaround is to reset the FPU env to 53-bit mantissa
   by a call to fesetenv (FE_PC53_ENV).  Amother is to force storage
   of the return value of individual math functions using wrappers.
   NB, using these wrappers will disable builtin math functions and
   hence disable the folding of function results at compile time when
   arguments are constant.  */
#pragma line 196 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* For example, here is how to force the result of the pow function
   to be stored:   */
#pragma line 207 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* Complex number (for _cabs). This is the MS version. The ISO
   C99 counterpart _Complex is an intrinsic type in GCC and
   'complex' is defined as a macro.  See complex.h  */
struct _complex
{
 double x; /* Real part */
 double y; /* Imaginary part */
};
#pragma empty_line
 double __attribute__((__cdecl__)) _cabs (struct _complex);
#pragma empty_line
 double __attribute__((__cdecl__)) _hypot (double, double);
 double __attribute__((__cdecl__)) _j0 (double);
 double __attribute__((__cdecl__)) _j1 (double);
 double __attribute__((__cdecl__)) _jn (int, double);
 double __attribute__((__cdecl__)) _y0 (double);
 double __attribute__((__cdecl__)) _y1 (double);
 double __attribute__((__cdecl__)) _yn (int, double);
 int __attribute__((__cdecl__)) _matherr (struct _exception *);
#pragma empty_line
/* These are also declared in Mingw float.h; needed here as well to work 
   around GCC build issues.  */
/* BEGIN FLOAT.H COPY */
/*
 * IEEE recommended functions
 */
#pragma empty_line
 double __attribute__((__cdecl__)) _chgsign (double);
 double __attribute__((__cdecl__)) _copysign (double, double);
 double __attribute__((__cdecl__)) _logb (double);
 double __attribute__((__cdecl__)) _nextafter (double, double);
 double __attribute__((__cdecl__)) _scalb (double, long);
#pragma empty_line
 int __attribute__((__cdecl__)) _finite (double);
 int __attribute__((__cdecl__)) _fpclass (double);
 int __attribute__((__cdecl__)) _isnan (double);
#pragma empty_line
/* END FLOAT.H COPY */
#pragma empty_line
#pragma empty_line
/*
 * Non-underscored versions of non-ANSI functions.
 * These reside in liboldnames.a.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
 double __attribute__((__cdecl__)) j0 (double);
 double __attribute__((__cdecl__)) j1 (double);
 double __attribute__((__cdecl__)) jn (int, double);
 double __attribute__((__cdecl__)) y0 (double);
 double __attribute__((__cdecl__)) y1 (double);
 double __attribute__((__cdecl__)) yn (int, double);
#pragma empty_line
 double __attribute__((__cdecl__)) chgsign (double);
/*
 * scalb() is a GCC built-in.
 * Exclude this _scalb() stub; the semantics are incompatible
 * with the built-in implementation.
 *
_CRTIMP double __cdecl scalb (double, long);
 *
 */
 int __attribute__((__cdecl__)) finite (double);
 int __attribute__((__cdecl__)) fpclass (double);
#pragma line 286 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* This require msvcr70.dll or higher. */
#pragma line 314 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* Use the compiler's builtin define for FLT_EVAL_METHOD to
   set float_t and double_t.  */
#pragma line 324 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
typedef long double float_t;
typedef long double double_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* 7.12.3.1 */
/*
   Return values for fpclassify.
   These are based on Intel x87 fpu condition codes
   in the high byte of status word and differ from
   the return values for MS IEEE 754 extension _fpclass()
*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* 0x0200 is signbit mask */
#pragma empty_line
#pragma empty_line
/*
  We can't inline float or double, because we want to ensure truncation
  to semantic type before classification. 
  (A normal long double value might become subnormal when 
  converted to double, and zero when converted to float.)
*/
#pragma empty_line
extern int __attribute__((__cdecl__)) __fpclassifyf (float);
extern int __attribute__((__cdecl__)) __fpclassify (double);
extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
#pragma line 370 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* 7.12.3.2 */
#pragma empty_line
#pragma empty_line
/* 7.12.3.3 */
#pragma empty_line
#pragma empty_line
/* 7.12.3.4 */
/* We don't need to worry about truncation here:
   A NaN stays a NaN. */
extern int __attribute__((__cdecl__)) __isnan (double);
extern int __attribute__((__cdecl__)) __isnanf (float);
extern int __attribute__((__cdecl__)) __isnanl (long double);
#pragma line 415 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* 7.12.3.5 */
#pragma empty_line
#pragma empty_line
/* 7.12.3.6 The signbit macro */
extern int __attribute__((__cdecl__)) __signbit (double);
extern int __attribute__((__cdecl__)) __signbitf (float);
extern int __attribute__((__cdecl__)) __signbitl (long double);
#pragma line 446 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* 7.12.4 Trigonometric functions: Double in C89 */
extern float __attribute__((__cdecl__)) sinf (float);
extern long double __attribute__((__cdecl__)) sinl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) cosf (float);
extern long double __attribute__((__cdecl__)) cosl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) tanf (float);
extern long double __attribute__((__cdecl__)) tanl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) asinf (float);
extern long double __attribute__((__cdecl__)) asinl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) acosf (float);
extern long double __attribute__((__cdecl__)) acosl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) atan2f (float, float);
extern long double __attribute__((__cdecl__)) atan2l (long double, long double);
#pragma empty_line
/* 7.12.5 Hyperbolic functions: Double in C89  */
extern float __attribute__((__cdecl__)) sinhf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) sinhl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) coshf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) coshl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) tanhf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) tanhl (long double);
#pragma empty_line
/* Inverse hyperbolic trig functions  */
/* 7.12.5.1 */
extern double __attribute__((__cdecl__)) acosh (double);
extern float __attribute__((__cdecl__)) acoshf (float);
extern long double __attribute__((__cdecl__)) acoshl (long double);
#pragma empty_line
/* 7.12.5.2 */
extern double __attribute__((__cdecl__)) asinh (double);
extern float __attribute__((__cdecl__)) asinhf (float);
extern long double __attribute__((__cdecl__)) asinhl (long double);
#pragma empty_line
/* 7.12.5.3 */
extern double __attribute__((__cdecl__)) atanh (double);
extern float __attribute__((__cdecl__)) atanhf (float);
extern long double __attribute__((__cdecl__)) atanhl (long double);
#pragma empty_line
/* Exponentials and logarithms  */
/* 7.12.6.1 Double in C89 */
extern float __attribute__((__cdecl__)) expf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) expl (long double);
#pragma empty_line
/* 7.12.6.2 */
extern double __attribute__((__cdecl__)) exp2(double);
extern float __attribute__((__cdecl__)) exp2f(float);
extern long double __attribute__((__cdecl__)) exp2l(long double);
#pragma empty_line
/* 7.12.6.3 The expm1 functions */
/* TODO: These could be inlined */
extern double __attribute__((__cdecl__)) expm1(double);
extern float __attribute__((__cdecl__)) expm1f(float);
extern long double __attribute__((__cdecl__)) expm1l(long double);
#pragma empty_line
/* 7.12.6.4 Double in C89 */
extern float __attribute__((__cdecl__)) frexpf (float, int*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) frexpl (long double, int*);
#pragma empty_line
/* 7.12.6.5 */
#pragma empty_line
#pragma empty_line
extern int __attribute__((__cdecl__)) ilogb (double);
extern int __attribute__((__cdecl__)) ilogbf (float);
extern int __attribute__((__cdecl__)) ilogbl (long double);
#pragma empty_line
/* 7.12.6.6  Double in C89 */
extern float __attribute__((__cdecl__)) ldexpf (float, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) ldexpl (long double, int);
#pragma empty_line
/* 7.12.6.7 Double in C89 */
extern float __attribute__((__cdecl__)) logf (float);
extern long double __attribute__((__cdecl__)) logl (long double);
#pragma empty_line
/* 7.12.6.8 Double in C89 */
extern float __attribute__((__cdecl__)) log10f (float);
extern long double __attribute__((__cdecl__)) log10l (long double);
#pragma empty_line
/* 7.12.6.9 */
extern double __attribute__((__cdecl__)) log1p(double);
extern float __attribute__((__cdecl__)) log1pf(float);
extern long double __attribute__((__cdecl__)) log1pl(long double);
#pragma empty_line
/* 7.12.6.10 */
extern double __attribute__((__cdecl__)) log2 (double);
extern float __attribute__((__cdecl__)) log2f (float);
extern long double __attribute__((__cdecl__)) log2l (long double);
#pragma empty_line
/* 7.12.6.11 */
extern double __attribute__((__cdecl__)) logb (double);
extern float __attribute__((__cdecl__)) logbf (float);
extern long double __attribute__((__cdecl__)) logbl (long double);
#pragma empty_line
/* Inline versions.  GCC-4.0+ can do a better fast-math optimization
   with __builtins. */
#pragma line 602 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* 7.12.6.12  Double in C89 */
extern float __attribute__((__cdecl__)) modff (float, float*);
extern long double __attribute__((__cdecl__)) modfl (long double, long double*);
#pragma empty_line
/* 7.12.6.13 */
extern double __attribute__((__cdecl__)) scalbn (double, int);
extern float __attribute__((__cdecl__)) scalbnf (float, int);
extern long double __attribute__((__cdecl__)) scalbnl (long double, int);
#pragma empty_line
extern double __attribute__((__cdecl__)) scalbln (double, long);
extern float __attribute__((__cdecl__)) scalblnf (float, long);
extern long double __attribute__((__cdecl__)) scalblnl (long double, long);
#pragma empty_line
/* 7.12.7.1 */
/* Implementations adapted from Cephes versions */
extern double __attribute__((__cdecl__)) cbrt (double);
extern float __attribute__((__cdecl__)) cbrtf (float);
extern long double __attribute__((__cdecl__)) cbrtl (long double);
#pragma empty_line
/* 7.12.7.2 The fabs functions: Double in C89 */
extern float __attribute__((__cdecl__)) fabsf (float x);
extern long double __attribute__((__cdecl__)) fabsl (long double x);
#pragma empty_line
/* 7.12.7.3  */
extern double __attribute__((__cdecl__)) hypot (double, double); /* in libmoldname.a */
extern float __attribute__((__cdecl__)) hypotf (float, float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) hypotl (long double, long double);
#pragma empty_line
/* 7.12.7.4 The pow functions. Double in C89 */
extern float __attribute__((__cdecl__)) powf (float, float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) powl (long double, long double);
#pragma empty_line
/* 7.12.7.5 The sqrt functions. Double in C89. */
extern float __attribute__((__cdecl__)) sqrtf (float);
extern long double __attribute__((__cdecl__)) sqrtl (long double);
#pragma empty_line
/* 7.12.8.1 The erf functions  */
extern double __attribute__((__cdecl__)) erf (double);
extern float __attribute__((__cdecl__)) erff (float);
extern long double __attribute__((__cdecl__)) erfl (long double);
#pragma empty_line
/* 7.12.8.2 The erfc functions  */
extern double __attribute__((__cdecl__)) erfc (double);
extern float __attribute__((__cdecl__)) erfcf (float);
extern long double __attribute__((__cdecl__)) erfcl (long double);
#pragma empty_line
/* 7.12.8.3 The lgamma functions */
extern double __attribute__((__cdecl__)) lgamma (double);
extern float __attribute__((__cdecl__)) lgammaf (float);
extern long double __attribute__((__cdecl__)) lgammal (long double);
#pragma empty_line
/* 7.12.8.4 The tgamma functions */
extern double __attribute__((__cdecl__)) tgamma (double);
extern float __attribute__((__cdecl__)) tgammaf (float);
extern long double __attribute__((__cdecl__)) tgammal (long double);
#pragma empty_line
/* 7.12.9.1 Double in C89 */
extern float __attribute__((__cdecl__)) ceilf (float);
extern long double __attribute__((__cdecl__)) ceill (long double);
#pragma empty_line
/* 7.12.9.2 Double in C89 */
extern float __attribute__((__cdecl__)) floorf (float);
extern long double __attribute__((__cdecl__)) floorl (long double);
#pragma empty_line
/* 7.12.9.3 */
extern double __attribute__((__cdecl__)) nearbyint ( double);
extern float __attribute__((__cdecl__)) nearbyintf (float);
extern long double __attribute__((__cdecl__)) nearbyintl (long double);
#pragma empty_line
/* 7.12.9.4 */
/* round, using fpu control word settings */
extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);
#pragma empty_line
/* 7.12.9.5 */
extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);
#pragma empty_line
extern long long __attribute__((__cdecl__)) llrint (double);
extern long long __attribute__((__cdecl__)) llrintf (float);
extern long long __attribute__((__cdecl__)) llrintl (long double);
#pragma empty_line
/* Inline versions of above. 
   GCC 4.0+ can do a better fast-math job with __builtins. */
#pragma line 769 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
/* 7.12.9.6 */
/* round away from zero, regardless of fpu control word settings */
extern double __attribute__((__cdecl__)) round (double);
extern float __attribute__((__cdecl__)) roundf (float);
extern long double __attribute__((__cdecl__)) roundl (long double);
#pragma empty_line
/* 7.12.9.7  */
extern long __attribute__((__cdecl__)) lround (double);
extern long __attribute__((__cdecl__)) lroundf (float);
extern long __attribute__((__cdecl__)) lroundl (long double);
#pragma empty_line
extern long long __attribute__((__cdecl__)) llround (double);
extern long long __attribute__((__cdecl__)) llroundf (float);
extern long long __attribute__((__cdecl__)) llroundl (long double);
#pragma empty_line
/* 7.12.9.8 */
/* round towards zero, regardless of fpu control word settings */
extern double __attribute__((__cdecl__)) trunc (double);
extern float __attribute__((__cdecl__)) truncf (float);
extern long double __attribute__((__cdecl__)) truncl (long double);
#pragma empty_line
/* 7.12.10.1 Double in C89 */
extern float __attribute__((__cdecl__)) fmodf (float, float);
extern long double __attribute__((__cdecl__)) fmodl (long double, long double);
#pragma empty_line
/* 7.12.10.2 */
extern double __attribute__((__cdecl__)) remainder (double, double);
extern float __attribute__((__cdecl__)) remainderf (float, float);
extern long double __attribute__((__cdecl__)) remainderl (long double, long double);
#pragma empty_line
/* 7.12.10.3 */
extern double __attribute__((__cdecl__)) remquo(double, double, int *);
extern float __attribute__((__cdecl__)) remquof(float, float, int *);
extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);
#pragma empty_line
/* 7.12.11.1 */
extern double __attribute__((__cdecl__)) copysign (double, double); /* in libmoldname.a */
extern float __attribute__((__cdecl__)) copysignf (float, float);
extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
#pragma empty_line
/* 7.12.11.2 Return a NaN */
extern double __attribute__((__cdecl__)) nan(const char *tagp);
extern float __attribute__((__cdecl__)) nanf(const char *tagp);
extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* 7.12.11.3 */
extern double __attribute__((__cdecl__)) nextafter (double, double); /* in libmoldname.a */
extern float __attribute__((__cdecl__)) nextafterf (float, float);
extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);
#pragma empty_line
/* 7.12.11.4 The nexttoward functions */
extern double __attribute__((__cdecl__)) nexttoward (double, long double);
extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);
#pragma empty_line
/* 7.12.12.1 */
/*  x > y ? (x - y) : 0.0  */
extern double __attribute__((__cdecl__)) fdim (double x, double y);
extern float __attribute__((__cdecl__)) fdimf (float x, float y);
extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);
#pragma empty_line
/* fmax and fmin.
   NaN arguments are treated as missing data: if one argument is a NaN
   and the other numeric, then these functions choose the numeric
   value. */
#pragma empty_line
/* 7.12.12.2 */
extern double __attribute__((__cdecl__)) fmax (double, double);
extern float __attribute__((__cdecl__)) fmaxf (float, float);
extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);
#pragma empty_line
/* 7.12.12.3 */
extern double __attribute__((__cdecl__)) fmin (double, double);
extern float __attribute__((__cdecl__)) fminf (float, float);
extern long double __attribute__((__cdecl__)) fminl (long double, long double);
#pragma empty_line
/* 7.12.13.1 */
/* return x * y + z as a ternary op */
extern double __attribute__((__cdecl__)) fma (double, double, double);
extern float __attribute__((__cdecl__)) fmaf (float, float, float);
extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
#pragma empty_line
#pragma empty_line
/* 7.12.14 */
/* 
 *  With these functions, comparisons involving quiet NaNs set the FP
 *  condition code to "unordered".  The IEEE floating-point spec
 *  dictates that the result of floating-point comparisons should be
 *  false whenever a NaN is involved, with the exception of the != op, 
 *  which always returns true: yes, (NaN != NaN) is true).
 */
#pragma line 910 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/math.h" 3
}
#pragma line 24 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/c++/4.2.1/string" 1 3
// Components for manipulating sequences of characters -*- C++ -*-
#pragma empty_line
// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.
#pragma empty_line
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
#pragma empty_line
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.
#pragma empty_line
// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.
#pragma empty_line
/** @file include/string
 *  This is a Standard C++ Library header.
 */
#pragma empty_line
//
// ISO C++ 14882: 21  Strings library
//
#pragma line 25 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma line 34 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
/* for safety*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* for safety*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*for safety*/
#pragma line 65 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    typedef unsigned long long ap_ulong;
    typedef signed long long ap_slong;
#pragma line 83 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
/*support SC mode*/
#pragma line 101 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
extern "C" void _ssdm_string2bits(...);
#pragma empty_line
/* Basic AP data types.
 ----------------------------------------------------------------
*/
template<int _AP_N, bool _AP_S> struct ssdm_int;
#pragma line 132 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_dt.def" 1
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<1 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<2 + 1024 * 0,true> { int V __attribute__ ((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<2 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<3 + 1024 * 0,true> { int V __attribute__ ((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<3 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<4 + 1024 * 0,true> { int V __attribute__ ((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<4 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<5 + 1024 * 0,true> { int V __attribute__ ((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<5 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<6 + 1024 * 0,true> { int V __attribute__ ((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<6 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<7 + 1024 * 0,true> { int V __attribute__ ((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<7 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<8 + 1024 * 0,true> { int V __attribute__ ((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<8 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<9 + 1024 * 0,true> { int V __attribute__ ((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<9 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<10 + 1024 * 0,true> { int V __attribute__ ((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<10 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<11 + 1024 * 0,true> { int V __attribute__ ((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<11 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<12 + 1024 * 0,true> { int V __attribute__ ((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<12 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<13 + 1024 * 0,true> { int V __attribute__ ((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<13 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<14 + 1024 * 0,true> { int V __attribute__ ((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<14 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<15 + 1024 * 0,true> { int V __attribute__ ((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<15 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<16 + 1024 * 0,true> { int V __attribute__ ((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<16 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<17 + 1024 * 0,true> { int V __attribute__ ((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<17 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<18 + 1024 * 0,true> { int V __attribute__ ((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<18 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<19 + 1024 * 0,true> { int V __attribute__ ((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<19 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<20 + 1024 * 0,true> { int V __attribute__ ((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<20 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<21 + 1024 * 0,true> { int V __attribute__ ((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<21 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<22 + 1024 * 0,true> { int V __attribute__ ((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<22 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<23 + 1024 * 0,true> { int V __attribute__ ((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<23 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<24 + 1024 * 0,true> { int V __attribute__ ((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<24 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<25 + 1024 * 0,true> { int V __attribute__ ((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<25 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<26 + 1024 * 0,true> { int V __attribute__ ((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<26 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<27 + 1024 * 0,true> { int V __attribute__ ((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<27 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<28 + 1024 * 0,true> { int V __attribute__ ((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<28 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<29 + 1024 * 0,true> { int V __attribute__ ((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<29 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<30 + 1024 * 0,true> { int V __attribute__ ((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<30 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<31 + 1024 * 0,true> { int V __attribute__ ((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<31 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<32 + 1024 * 0,true> { int V __attribute__ ((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<32 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<33 + 1024 * 0,true> { int V __attribute__ ((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<33 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<34 + 1024 * 0,true> { int V __attribute__ ((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<34 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<35 + 1024 * 0,true> { int V __attribute__ ((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<35 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<36 + 1024 * 0,true> { int V __attribute__ ((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<36 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<37 + 1024 * 0,true> { int V __attribute__ ((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<37 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<38 + 1024 * 0,true> { int V __attribute__ ((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<38 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<39 + 1024 * 0,true> { int V __attribute__ ((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<39 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<40 + 1024 * 0,true> { int V __attribute__ ((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<40 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<41 + 1024 * 0,true> { int V __attribute__ ((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<41 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<42 + 1024 * 0,true> { int V __attribute__ ((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<42 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<43 + 1024 * 0,true> { int V __attribute__ ((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<43 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<44 + 1024 * 0,true> { int V __attribute__ ((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<44 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<45 + 1024 * 0,true> { int V __attribute__ ((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<45 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<46 + 1024 * 0,true> { int V __attribute__ ((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<46 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<47 + 1024 * 0,true> { int V __attribute__ ((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<47 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<48 + 1024 * 0,true> { int V __attribute__ ((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<48 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<49 + 1024 * 0,true> { int V __attribute__ ((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<49 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<50 + 1024 * 0,true> { int V __attribute__ ((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<50 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<51 + 1024 * 0,true> { int V __attribute__ ((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<51 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<52 + 1024 * 0,true> { int V __attribute__ ((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<52 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<53 + 1024 * 0,true> { int V __attribute__ ((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<53 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<54 + 1024 * 0,true> { int V __attribute__ ((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<54 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<55 + 1024 * 0,true> { int V __attribute__ ((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<55 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<56 + 1024 * 0,true> { int V __attribute__ ((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<56 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<57 + 1024 * 0,true> { int V __attribute__ ((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<57 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<58 + 1024 * 0,true> { int V __attribute__ ((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<58 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<59 + 1024 * 0,true> { int V __attribute__ ((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<59 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<60 + 1024 * 0,true> { int V __attribute__ ((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<60 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<61 + 1024 * 0,true> { int V __attribute__ ((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<61 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<62 + 1024 * 0,true> { int V __attribute__ ((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<62 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<63 + 1024 * 0,true> { int V __attribute__ ((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<63 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0 , false>() { }; };
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<64 + 1024 * 0,true> { int V __attribute__ ((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<64 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0 , false>() { }; };
#pragma empty_line
#pragma empty_line
/*#if AUTOPILOT_VERSION >= 1 */
#pragma empty_line
template<> struct ssdm_int<65 + 1024 * 0,true> { int V __attribute__ ((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<65 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<66 + 1024 * 0,true> { int V __attribute__ ((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<66 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<67 + 1024 * 0,true> { int V __attribute__ ((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<67 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<68 + 1024 * 0,true> { int V __attribute__ ((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<68 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<69 + 1024 * 0,true> { int V __attribute__ ((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<69 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<70 + 1024 * 0,true> { int V __attribute__ ((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<70 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<71 + 1024 * 0,true> { int V __attribute__ ((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<71 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<72 + 1024 * 0,true> { int V __attribute__ ((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<72 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<73 + 1024 * 0,true> { int V __attribute__ ((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<73 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<74 + 1024 * 0,true> { int V __attribute__ ((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<74 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<75 + 1024 * 0,true> { int V __attribute__ ((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<75 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<76 + 1024 * 0,true> { int V __attribute__ ((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<76 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<77 + 1024 * 0,true> { int V __attribute__ ((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<77 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<78 + 1024 * 0,true> { int V __attribute__ ((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<78 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<79 + 1024 * 0,true> { int V __attribute__ ((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<79 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<80 + 1024 * 0,true> { int V __attribute__ ((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<80 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<81 + 1024 * 0,true> { int V __attribute__ ((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<81 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<82 + 1024 * 0,true> { int V __attribute__ ((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<82 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<83 + 1024 * 0,true> { int V __attribute__ ((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<83 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<84 + 1024 * 0,true> { int V __attribute__ ((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<84 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<85 + 1024 * 0,true> { int V __attribute__ ((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<85 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<86 + 1024 * 0,true> { int V __attribute__ ((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<86 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<87 + 1024 * 0,true> { int V __attribute__ ((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<87 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<88 + 1024 * 0,true> { int V __attribute__ ((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<88 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<89 + 1024 * 0,true> { int V __attribute__ ((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<89 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<90 + 1024 * 0,true> { int V __attribute__ ((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<90 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<91 + 1024 * 0,true> { int V __attribute__ ((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<91 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<92 + 1024 * 0,true> { int V __attribute__ ((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<92 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<93 + 1024 * 0,true> { int V __attribute__ ((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<93 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<94 + 1024 * 0,true> { int V __attribute__ ((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<94 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<95 + 1024 * 0,true> { int V __attribute__ ((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<95 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<96 + 1024 * 0,true> { int V __attribute__ ((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<96 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<97 + 1024 * 0,true> { int V __attribute__ ((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<97 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<98 + 1024 * 0,true> { int V __attribute__ ((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<98 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<99 + 1024 * 0,true> { int V __attribute__ ((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<99 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<100 + 1024 * 0,true> { int V __attribute__ ((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<100 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<101 + 1024 * 0,true> { int V __attribute__ ((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<101 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<102 + 1024 * 0,true> { int V __attribute__ ((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<102 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<103 + 1024 * 0,true> { int V __attribute__ ((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<103 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<104 + 1024 * 0,true> { int V __attribute__ ((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<104 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<105 + 1024 * 0,true> { int V __attribute__ ((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<105 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<106 + 1024 * 0,true> { int V __attribute__ ((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<106 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<107 + 1024 * 0,true> { int V __attribute__ ((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<107 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<108 + 1024 * 0,true> { int V __attribute__ ((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<108 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<109 + 1024 * 0,true> { int V __attribute__ ((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<109 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<110 + 1024 * 0,true> { int V __attribute__ ((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<110 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<111 + 1024 * 0,true> { int V __attribute__ ((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<111 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<112 + 1024 * 0,true> { int V __attribute__ ((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<112 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<113 + 1024 * 0,true> { int V __attribute__ ((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<113 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<114 + 1024 * 0,true> { int V __attribute__ ((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<114 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<115 + 1024 * 0,true> { int V __attribute__ ((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<115 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<116 + 1024 * 0,true> { int V __attribute__ ((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<116 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<117 + 1024 * 0,true> { int V __attribute__ ((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<117 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<118 + 1024 * 0,true> { int V __attribute__ ((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<118 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<119 + 1024 * 0,true> { int V __attribute__ ((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<119 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<120 + 1024 * 0,true> { int V __attribute__ ((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<120 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<121 + 1024 * 0,true> { int V __attribute__ ((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<121 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<122 + 1024 * 0,true> { int V __attribute__ ((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<122 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<123 + 1024 * 0,true> { int V __attribute__ ((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<123 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<124 + 1024 * 0,true> { int V __attribute__ ((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<124 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<125 + 1024 * 0,true> { int V __attribute__ ((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<125 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<126 + 1024 * 0,true> { int V __attribute__ ((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<126 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<127 + 1024 * 0,true> { int V __attribute__ ((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<127 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<128 + 1024 * 0,true> { int V __attribute__ ((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<128 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0 , false>() { }; };
#pragma empty_line
/*#endif*/
#pragma empty_line
#pragma empty_line
/*#ifdef EXTENDED_GCC*/
#pragma empty_line
template<> struct ssdm_int<129 + 1024 * 0,true> { int V __attribute__ ((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<129 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<130 + 1024 * 0,true> { int V __attribute__ ((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<130 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<131 + 1024 * 0,true> { int V __attribute__ ((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<131 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<132 + 1024 * 0,true> { int V __attribute__ ((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<132 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<133 + 1024 * 0,true> { int V __attribute__ ((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<133 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<134 + 1024 * 0,true> { int V __attribute__ ((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<134 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<135 + 1024 * 0,true> { int V __attribute__ ((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<135 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<136 + 1024 * 0,true> { int V __attribute__ ((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<136 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<137 + 1024 * 0,true> { int V __attribute__ ((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<137 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<138 + 1024 * 0,true> { int V __attribute__ ((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<138 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<139 + 1024 * 0,true> { int V __attribute__ ((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<139 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<140 + 1024 * 0,true> { int V __attribute__ ((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<140 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<141 + 1024 * 0,true> { int V __attribute__ ((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<141 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<142 + 1024 * 0,true> { int V __attribute__ ((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<142 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<143 + 1024 * 0,true> { int V __attribute__ ((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<143 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<144 + 1024 * 0,true> { int V __attribute__ ((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<144 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<145 + 1024 * 0,true> { int V __attribute__ ((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<145 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<146 + 1024 * 0,true> { int V __attribute__ ((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<146 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<147 + 1024 * 0,true> { int V __attribute__ ((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<147 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<148 + 1024 * 0,true> { int V __attribute__ ((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<148 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<149 + 1024 * 0,true> { int V __attribute__ ((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<149 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<150 + 1024 * 0,true> { int V __attribute__ ((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<150 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<151 + 1024 * 0,true> { int V __attribute__ ((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<151 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<152 + 1024 * 0,true> { int V __attribute__ ((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<152 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<153 + 1024 * 0,true> { int V __attribute__ ((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<153 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<154 + 1024 * 0,true> { int V __attribute__ ((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<154 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<155 + 1024 * 0,true> { int V __attribute__ ((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<155 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<156 + 1024 * 0,true> { int V __attribute__ ((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<156 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<157 + 1024 * 0,true> { int V __attribute__ ((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<157 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<158 + 1024 * 0,true> { int V __attribute__ ((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<158 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<159 + 1024 * 0,true> { int V __attribute__ ((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<159 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<160 + 1024 * 0,true> { int V __attribute__ ((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<160 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<161 + 1024 * 0,true> { int V __attribute__ ((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<161 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<162 + 1024 * 0,true> { int V __attribute__ ((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<162 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<163 + 1024 * 0,true> { int V __attribute__ ((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<163 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<164 + 1024 * 0,true> { int V __attribute__ ((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<164 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<165 + 1024 * 0,true> { int V __attribute__ ((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<165 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<166 + 1024 * 0,true> { int V __attribute__ ((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<166 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<167 + 1024 * 0,true> { int V __attribute__ ((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<167 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<168 + 1024 * 0,true> { int V __attribute__ ((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<168 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<169 + 1024 * 0,true> { int V __attribute__ ((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<169 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<170 + 1024 * 0,true> { int V __attribute__ ((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<170 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<171 + 1024 * 0,true> { int V __attribute__ ((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<171 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<172 + 1024 * 0,true> { int V __attribute__ ((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<172 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<173 + 1024 * 0,true> { int V __attribute__ ((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<173 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<174 + 1024 * 0,true> { int V __attribute__ ((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<174 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<175 + 1024 * 0,true> { int V __attribute__ ((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<175 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<176 + 1024 * 0,true> { int V __attribute__ ((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<176 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<177 + 1024 * 0,true> { int V __attribute__ ((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<177 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<178 + 1024 * 0,true> { int V __attribute__ ((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<178 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<179 + 1024 * 0,true> { int V __attribute__ ((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<179 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<180 + 1024 * 0,true> { int V __attribute__ ((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<180 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<181 + 1024 * 0,true> { int V __attribute__ ((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<181 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<182 + 1024 * 0,true> { int V __attribute__ ((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<182 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<183 + 1024 * 0,true> { int V __attribute__ ((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<183 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<184 + 1024 * 0,true> { int V __attribute__ ((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<184 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<185 + 1024 * 0,true> { int V __attribute__ ((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<185 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<186 + 1024 * 0,true> { int V __attribute__ ((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<186 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<187 + 1024 * 0,true> { int V __attribute__ ((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<187 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<188 + 1024 * 0,true> { int V __attribute__ ((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<188 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<189 + 1024 * 0,true> { int V __attribute__ ((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<189 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<190 + 1024 * 0,true> { int V __attribute__ ((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<190 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<191 + 1024 * 0,true> { int V __attribute__ ((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<191 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<192 + 1024 * 0,true> { int V __attribute__ ((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<192 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<193 + 1024 * 0,true> { int V __attribute__ ((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<193 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<194 + 1024 * 0,true> { int V __attribute__ ((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<194 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<195 + 1024 * 0,true> { int V __attribute__ ((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<195 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<196 + 1024 * 0,true> { int V __attribute__ ((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<196 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<197 + 1024 * 0,true> { int V __attribute__ ((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<197 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<198 + 1024 * 0,true> { int V __attribute__ ((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<198 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<199 + 1024 * 0,true> { int V __attribute__ ((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<199 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<200 + 1024 * 0,true> { int V __attribute__ ((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<200 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<201 + 1024 * 0,true> { int V __attribute__ ((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<201 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<202 + 1024 * 0,true> { int V __attribute__ ((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<202 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<203 + 1024 * 0,true> { int V __attribute__ ((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<203 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<204 + 1024 * 0,true> { int V __attribute__ ((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<204 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<205 + 1024 * 0,true> { int V __attribute__ ((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<205 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<206 + 1024 * 0,true> { int V __attribute__ ((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<206 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<207 + 1024 * 0,true> { int V __attribute__ ((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<207 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<208 + 1024 * 0,true> { int V __attribute__ ((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<208 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<209 + 1024 * 0,true> { int V __attribute__ ((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<209 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<210 + 1024 * 0,true> { int V __attribute__ ((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<210 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<211 + 1024 * 0,true> { int V __attribute__ ((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<211 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<212 + 1024 * 0,true> { int V __attribute__ ((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<212 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<213 + 1024 * 0,true> { int V __attribute__ ((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<213 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<214 + 1024 * 0,true> { int V __attribute__ ((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<214 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<215 + 1024 * 0,true> { int V __attribute__ ((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<215 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<216 + 1024 * 0,true> { int V __attribute__ ((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<216 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<217 + 1024 * 0,true> { int V __attribute__ ((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<217 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<218 + 1024 * 0,true> { int V __attribute__ ((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<218 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<219 + 1024 * 0,true> { int V __attribute__ ((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<219 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<220 + 1024 * 0,true> { int V __attribute__ ((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<220 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<221 + 1024 * 0,true> { int V __attribute__ ((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<221 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<222 + 1024 * 0,true> { int V __attribute__ ((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<222 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<223 + 1024 * 0,true> { int V __attribute__ ((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<223 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<224 + 1024 * 0,true> { int V __attribute__ ((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<224 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<225 + 1024 * 0,true> { int V __attribute__ ((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<225 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<226 + 1024 * 0,true> { int V __attribute__ ((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<226 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<227 + 1024 * 0,true> { int V __attribute__ ((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<227 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<228 + 1024 * 0,true> { int V __attribute__ ((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<228 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<229 + 1024 * 0,true> { int V __attribute__ ((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<229 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<230 + 1024 * 0,true> { int V __attribute__ ((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<230 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<231 + 1024 * 0,true> { int V __attribute__ ((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<231 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<232 + 1024 * 0,true> { int V __attribute__ ((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<232 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<233 + 1024 * 0,true> { int V __attribute__ ((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<233 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<234 + 1024 * 0,true> { int V __attribute__ ((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<234 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<235 + 1024 * 0,true> { int V __attribute__ ((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<235 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<236 + 1024 * 0,true> { int V __attribute__ ((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<236 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<237 + 1024 * 0,true> { int V __attribute__ ((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<237 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<238 + 1024 * 0,true> { int V __attribute__ ((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<238 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<239 + 1024 * 0,true> { int V __attribute__ ((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<239 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<240 + 1024 * 0,true> { int V __attribute__ ((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<240 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<241 + 1024 * 0,true> { int V __attribute__ ((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<241 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<242 + 1024 * 0,true> { int V __attribute__ ((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<242 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<243 + 1024 * 0,true> { int V __attribute__ ((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<243 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<244 + 1024 * 0,true> { int V __attribute__ ((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<244 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<245 + 1024 * 0,true> { int V __attribute__ ((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<245 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<246 + 1024 * 0,true> { int V __attribute__ ((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<246 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<247 + 1024 * 0,true> { int V __attribute__ ((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<247 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<248 + 1024 * 0,true> { int V __attribute__ ((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<248 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<249 + 1024 * 0,true> { int V __attribute__ ((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<249 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<250 + 1024 * 0,true> { int V __attribute__ ((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<250 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<251 + 1024 * 0,true> { int V __attribute__ ((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<251 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<252 + 1024 * 0,true> { int V __attribute__ ((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<252 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<253 + 1024 * 0,true> { int V __attribute__ ((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<253 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<254 + 1024 * 0,true> { int V __attribute__ ((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<254 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<255 + 1024 * 0,true> { int V __attribute__ ((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<255 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<256 + 1024 * 0,true> { int V __attribute__ ((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<256 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<257 + 1024 * 0,true> { int V __attribute__ ((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<257 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<258 + 1024 * 0,true> { int V __attribute__ ((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<258 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<259 + 1024 * 0,true> { int V __attribute__ ((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<259 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<260 + 1024 * 0,true> { int V __attribute__ ((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<260 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<261 + 1024 * 0,true> { int V __attribute__ ((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<261 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<262 + 1024 * 0,true> { int V __attribute__ ((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<262 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<263 + 1024 * 0,true> { int V __attribute__ ((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<263 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<264 + 1024 * 0,true> { int V __attribute__ ((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<264 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<265 + 1024 * 0,true> { int V __attribute__ ((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<265 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<266 + 1024 * 0,true> { int V __attribute__ ((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<266 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<267 + 1024 * 0,true> { int V __attribute__ ((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<267 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<268 + 1024 * 0,true> { int V __attribute__ ((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<268 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<269 + 1024 * 0,true> { int V __attribute__ ((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<269 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<270 + 1024 * 0,true> { int V __attribute__ ((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<270 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<271 + 1024 * 0,true> { int V __attribute__ ((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<271 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<272 + 1024 * 0,true> { int V __attribute__ ((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<272 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<273 + 1024 * 0,true> { int V __attribute__ ((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<273 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<274 + 1024 * 0,true> { int V __attribute__ ((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<274 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<275 + 1024 * 0,true> { int V __attribute__ ((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<275 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<276 + 1024 * 0,true> { int V __attribute__ ((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<276 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<277 + 1024 * 0,true> { int V __attribute__ ((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<277 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<278 + 1024 * 0,true> { int V __attribute__ ((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<278 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<279 + 1024 * 0,true> { int V __attribute__ ((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<279 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<280 + 1024 * 0,true> { int V __attribute__ ((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<280 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<281 + 1024 * 0,true> { int V __attribute__ ((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<281 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<282 + 1024 * 0,true> { int V __attribute__ ((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<282 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<283 + 1024 * 0,true> { int V __attribute__ ((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<283 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<284 + 1024 * 0,true> { int V __attribute__ ((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<284 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<285 + 1024 * 0,true> { int V __attribute__ ((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<285 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<286 + 1024 * 0,true> { int V __attribute__ ((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<286 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<287 + 1024 * 0,true> { int V __attribute__ ((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<287 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<288 + 1024 * 0,true> { int V __attribute__ ((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<288 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<289 + 1024 * 0,true> { int V __attribute__ ((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<289 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<290 + 1024 * 0,true> { int V __attribute__ ((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<290 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<291 + 1024 * 0,true> { int V __attribute__ ((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<291 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<292 + 1024 * 0,true> { int V __attribute__ ((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<292 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<293 + 1024 * 0,true> { int V __attribute__ ((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<293 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<294 + 1024 * 0,true> { int V __attribute__ ((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<294 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<295 + 1024 * 0,true> { int V __attribute__ ((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<295 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<296 + 1024 * 0,true> { int V __attribute__ ((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<296 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<297 + 1024 * 0,true> { int V __attribute__ ((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<297 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<298 + 1024 * 0,true> { int V __attribute__ ((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<298 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<299 + 1024 * 0,true> { int V __attribute__ ((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<299 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<300 + 1024 * 0,true> { int V __attribute__ ((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<300 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<301 + 1024 * 0,true> { int V __attribute__ ((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<301 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<302 + 1024 * 0,true> { int V __attribute__ ((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<302 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<303 + 1024 * 0,true> { int V __attribute__ ((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<303 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<304 + 1024 * 0,true> { int V __attribute__ ((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<304 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<305 + 1024 * 0,true> { int V __attribute__ ((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<305 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<306 + 1024 * 0,true> { int V __attribute__ ((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<306 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<307 + 1024 * 0,true> { int V __attribute__ ((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<307 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<308 + 1024 * 0,true> { int V __attribute__ ((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<308 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<309 + 1024 * 0,true> { int V __attribute__ ((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<309 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<310 + 1024 * 0,true> { int V __attribute__ ((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<310 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<311 + 1024 * 0,true> { int V __attribute__ ((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<311 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<312 + 1024 * 0,true> { int V __attribute__ ((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<312 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<313 + 1024 * 0,true> { int V __attribute__ ((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<313 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<314 + 1024 * 0,true> { int V __attribute__ ((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<314 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<315 + 1024 * 0,true> { int V __attribute__ ((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<315 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<316 + 1024 * 0,true> { int V __attribute__ ((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<316 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<317 + 1024 * 0,true> { int V __attribute__ ((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<317 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<318 + 1024 * 0,true> { int V __attribute__ ((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<318 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<319 + 1024 * 0,true> { int V __attribute__ ((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<319 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<320 + 1024 * 0,true> { int V __attribute__ ((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<320 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<321 + 1024 * 0,true> { int V __attribute__ ((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<321 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<322 + 1024 * 0,true> { int V __attribute__ ((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<322 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<323 + 1024 * 0,true> { int V __attribute__ ((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<323 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<324 + 1024 * 0,true> { int V __attribute__ ((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<324 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<325 + 1024 * 0,true> { int V __attribute__ ((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<325 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<326 + 1024 * 0,true> { int V __attribute__ ((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<326 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<327 + 1024 * 0,true> { int V __attribute__ ((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<327 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<328 + 1024 * 0,true> { int V __attribute__ ((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<328 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<329 + 1024 * 0,true> { int V __attribute__ ((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<329 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<330 + 1024 * 0,true> { int V __attribute__ ((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<330 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<331 + 1024 * 0,true> { int V __attribute__ ((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<331 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<332 + 1024 * 0,true> { int V __attribute__ ((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<332 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<333 + 1024 * 0,true> { int V __attribute__ ((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<333 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<334 + 1024 * 0,true> { int V __attribute__ ((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<334 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<335 + 1024 * 0,true> { int V __attribute__ ((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<335 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<336 + 1024 * 0,true> { int V __attribute__ ((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<336 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<337 + 1024 * 0,true> { int V __attribute__ ((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<337 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<338 + 1024 * 0,true> { int V __attribute__ ((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<338 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<339 + 1024 * 0,true> { int V __attribute__ ((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<339 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<340 + 1024 * 0,true> { int V __attribute__ ((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<340 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<341 + 1024 * 0,true> { int V __attribute__ ((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<341 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<342 + 1024 * 0,true> { int V __attribute__ ((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<342 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<343 + 1024 * 0,true> { int V __attribute__ ((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<343 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<344 + 1024 * 0,true> { int V __attribute__ ((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<344 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<345 + 1024 * 0,true> { int V __attribute__ ((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<345 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<346 + 1024 * 0,true> { int V __attribute__ ((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<346 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<347 + 1024 * 0,true> { int V __attribute__ ((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<347 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<348 + 1024 * 0,true> { int V __attribute__ ((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<348 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<349 + 1024 * 0,true> { int V __attribute__ ((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<349 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<350 + 1024 * 0,true> { int V __attribute__ ((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<350 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<351 + 1024 * 0,true> { int V __attribute__ ((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<351 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<352 + 1024 * 0,true> { int V __attribute__ ((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<352 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<353 + 1024 * 0,true> { int V __attribute__ ((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<353 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<354 + 1024 * 0,true> { int V __attribute__ ((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<354 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<355 + 1024 * 0,true> { int V __attribute__ ((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<355 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<356 + 1024 * 0,true> { int V __attribute__ ((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<356 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<357 + 1024 * 0,true> { int V __attribute__ ((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<357 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<358 + 1024 * 0,true> { int V __attribute__ ((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<358 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<359 + 1024 * 0,true> { int V __attribute__ ((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<359 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<360 + 1024 * 0,true> { int V __attribute__ ((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<360 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<361 + 1024 * 0,true> { int V __attribute__ ((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<361 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<362 + 1024 * 0,true> { int V __attribute__ ((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<362 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<363 + 1024 * 0,true> { int V __attribute__ ((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<363 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<364 + 1024 * 0,true> { int V __attribute__ ((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<364 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<365 + 1024 * 0,true> { int V __attribute__ ((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<365 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<366 + 1024 * 0,true> { int V __attribute__ ((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<366 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<367 + 1024 * 0,true> { int V __attribute__ ((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<367 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<368 + 1024 * 0,true> { int V __attribute__ ((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<368 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<369 + 1024 * 0,true> { int V __attribute__ ((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<369 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<370 + 1024 * 0,true> { int V __attribute__ ((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<370 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<371 + 1024 * 0,true> { int V __attribute__ ((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<371 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<372 + 1024 * 0,true> { int V __attribute__ ((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<372 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<373 + 1024 * 0,true> { int V __attribute__ ((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<373 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<374 + 1024 * 0,true> { int V __attribute__ ((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<374 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<375 + 1024 * 0,true> { int V __attribute__ ((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<375 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<376 + 1024 * 0,true> { int V __attribute__ ((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<376 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<377 + 1024 * 0,true> { int V __attribute__ ((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<377 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<378 + 1024 * 0,true> { int V __attribute__ ((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<378 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<379 + 1024 * 0,true> { int V __attribute__ ((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<379 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<380 + 1024 * 0,true> { int V __attribute__ ((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<380 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<381 + 1024 * 0,true> { int V __attribute__ ((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<381 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<382 + 1024 * 0,true> { int V __attribute__ ((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<382 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<383 + 1024 * 0,true> { int V __attribute__ ((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<383 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<384 + 1024 * 0,true> { int V __attribute__ ((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<384 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<385 + 1024 * 0,true> { int V __attribute__ ((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<385 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<386 + 1024 * 0,true> { int V __attribute__ ((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<386 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<387 + 1024 * 0,true> { int V __attribute__ ((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<387 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<388 + 1024 * 0,true> { int V __attribute__ ((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<388 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<389 + 1024 * 0,true> { int V __attribute__ ((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<389 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<390 + 1024 * 0,true> { int V __attribute__ ((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<390 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<391 + 1024 * 0,true> { int V __attribute__ ((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<391 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<392 + 1024 * 0,true> { int V __attribute__ ((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<392 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<393 + 1024 * 0,true> { int V __attribute__ ((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<393 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<394 + 1024 * 0,true> { int V __attribute__ ((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<394 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<395 + 1024 * 0,true> { int V __attribute__ ((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<395 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<396 + 1024 * 0,true> { int V __attribute__ ((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<396 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<397 + 1024 * 0,true> { int V __attribute__ ((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<397 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<398 + 1024 * 0,true> { int V __attribute__ ((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<398 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<399 + 1024 * 0,true> { int V __attribute__ ((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<399 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<400 + 1024 * 0,true> { int V __attribute__ ((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<400 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<401 + 1024 * 0,true> { int V __attribute__ ((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<401 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<402 + 1024 * 0,true> { int V __attribute__ ((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<402 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<403 + 1024 * 0,true> { int V __attribute__ ((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<403 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<404 + 1024 * 0,true> { int V __attribute__ ((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<404 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<405 + 1024 * 0,true> { int V __attribute__ ((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<405 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<406 + 1024 * 0,true> { int V __attribute__ ((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<406 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<407 + 1024 * 0,true> { int V __attribute__ ((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<407 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<408 + 1024 * 0,true> { int V __attribute__ ((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<408 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<409 + 1024 * 0,true> { int V __attribute__ ((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<409 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<410 + 1024 * 0,true> { int V __attribute__ ((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<410 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<411 + 1024 * 0,true> { int V __attribute__ ((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<411 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<412 + 1024 * 0,true> { int V __attribute__ ((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<412 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<413 + 1024 * 0,true> { int V __attribute__ ((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<413 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<414 + 1024 * 0,true> { int V __attribute__ ((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<414 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<415 + 1024 * 0,true> { int V __attribute__ ((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<415 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<416 + 1024 * 0,true> { int V __attribute__ ((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<416 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<417 + 1024 * 0,true> { int V __attribute__ ((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<417 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<418 + 1024 * 0,true> { int V __attribute__ ((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<418 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<419 + 1024 * 0,true> { int V __attribute__ ((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<419 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<420 + 1024 * 0,true> { int V __attribute__ ((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<420 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<421 + 1024 * 0,true> { int V __attribute__ ((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<421 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<422 + 1024 * 0,true> { int V __attribute__ ((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<422 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<423 + 1024 * 0,true> { int V __attribute__ ((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<423 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<424 + 1024 * 0,true> { int V __attribute__ ((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<424 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<425 + 1024 * 0,true> { int V __attribute__ ((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<425 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<426 + 1024 * 0,true> { int V __attribute__ ((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<426 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<427 + 1024 * 0,true> { int V __attribute__ ((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<427 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<428 + 1024 * 0,true> { int V __attribute__ ((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<428 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<429 + 1024 * 0,true> { int V __attribute__ ((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<429 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<430 + 1024 * 0,true> { int V __attribute__ ((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<430 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<431 + 1024 * 0,true> { int V __attribute__ ((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<431 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<432 + 1024 * 0,true> { int V __attribute__ ((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<432 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<433 + 1024 * 0,true> { int V __attribute__ ((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<433 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<434 + 1024 * 0,true> { int V __attribute__ ((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<434 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<435 + 1024 * 0,true> { int V __attribute__ ((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<435 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<436 + 1024 * 0,true> { int V __attribute__ ((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<436 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<437 + 1024 * 0,true> { int V __attribute__ ((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<437 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<438 + 1024 * 0,true> { int V __attribute__ ((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<438 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<439 + 1024 * 0,true> { int V __attribute__ ((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<439 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<440 + 1024 * 0,true> { int V __attribute__ ((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<440 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<441 + 1024 * 0,true> { int V __attribute__ ((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<441 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<442 + 1024 * 0,true> { int V __attribute__ ((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<442 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<443 + 1024 * 0,true> { int V __attribute__ ((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<443 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<444 + 1024 * 0,true> { int V __attribute__ ((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<444 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<445 + 1024 * 0,true> { int V __attribute__ ((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<445 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<446 + 1024 * 0,true> { int V __attribute__ ((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<446 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<447 + 1024 * 0,true> { int V __attribute__ ((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<447 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<448 + 1024 * 0,true> { int V __attribute__ ((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<448 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<449 + 1024 * 0,true> { int V __attribute__ ((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<449 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<450 + 1024 * 0,true> { int V __attribute__ ((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<450 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<451 + 1024 * 0,true> { int V __attribute__ ((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<451 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<452 + 1024 * 0,true> { int V __attribute__ ((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<452 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<453 + 1024 * 0,true> { int V __attribute__ ((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<453 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<454 + 1024 * 0,true> { int V __attribute__ ((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<454 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<455 + 1024 * 0,true> { int V __attribute__ ((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<455 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<456 + 1024 * 0,true> { int V __attribute__ ((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<456 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<457 + 1024 * 0,true> { int V __attribute__ ((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<457 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<458 + 1024 * 0,true> { int V __attribute__ ((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<458 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<459 + 1024 * 0,true> { int V __attribute__ ((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<459 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<460 + 1024 * 0,true> { int V __attribute__ ((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<460 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<461 + 1024 * 0,true> { int V __attribute__ ((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<461 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<462 + 1024 * 0,true> { int V __attribute__ ((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<462 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<463 + 1024 * 0,true> { int V __attribute__ ((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<463 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<464 + 1024 * 0,true> { int V __attribute__ ((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<464 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<465 + 1024 * 0,true> { int V __attribute__ ((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<465 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<466 + 1024 * 0,true> { int V __attribute__ ((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<466 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<467 + 1024 * 0,true> { int V __attribute__ ((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<467 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<468 + 1024 * 0,true> { int V __attribute__ ((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<468 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<469 + 1024 * 0,true> { int V __attribute__ ((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<469 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<470 + 1024 * 0,true> { int V __attribute__ ((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<470 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<471 + 1024 * 0,true> { int V __attribute__ ((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<471 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<472 + 1024 * 0,true> { int V __attribute__ ((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<472 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<473 + 1024 * 0,true> { int V __attribute__ ((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<473 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<474 + 1024 * 0,true> { int V __attribute__ ((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<474 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<475 + 1024 * 0,true> { int V __attribute__ ((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<475 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<476 + 1024 * 0,true> { int V __attribute__ ((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<476 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<477 + 1024 * 0,true> { int V __attribute__ ((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<477 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<478 + 1024 * 0,true> { int V __attribute__ ((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<478 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<479 + 1024 * 0,true> { int V __attribute__ ((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<479 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<480 + 1024 * 0,true> { int V __attribute__ ((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<480 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<481 + 1024 * 0,true> { int V __attribute__ ((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<481 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<482 + 1024 * 0,true> { int V __attribute__ ((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<482 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<483 + 1024 * 0,true> { int V __attribute__ ((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<483 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<484 + 1024 * 0,true> { int V __attribute__ ((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<484 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<485 + 1024 * 0,true> { int V __attribute__ ((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<485 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<486 + 1024 * 0,true> { int V __attribute__ ((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<486 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<487 + 1024 * 0,true> { int V __attribute__ ((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<487 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<488 + 1024 * 0,true> { int V __attribute__ ((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<488 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<489 + 1024 * 0,true> { int V __attribute__ ((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<489 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<490 + 1024 * 0,true> { int V __attribute__ ((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<490 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<491 + 1024 * 0,true> { int V __attribute__ ((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<491 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<492 + 1024 * 0,true> { int V __attribute__ ((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<492 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<493 + 1024 * 0,true> { int V __attribute__ ((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<493 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<494 + 1024 * 0,true> { int V __attribute__ ((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<494 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<495 + 1024 * 0,true> { int V __attribute__ ((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<495 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<496 + 1024 * 0,true> { int V __attribute__ ((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<496 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<497 + 1024 * 0,true> { int V __attribute__ ((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<497 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<498 + 1024 * 0,true> { int V __attribute__ ((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<498 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<499 + 1024 * 0,true> { int V __attribute__ ((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<499 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<500 + 1024 * 0,true> { int V __attribute__ ((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<500 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<501 + 1024 * 0,true> { int V __attribute__ ((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<501 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<502 + 1024 * 0,true> { int V __attribute__ ((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<502 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<503 + 1024 * 0,true> { int V __attribute__ ((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<503 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<504 + 1024 * 0,true> { int V __attribute__ ((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<504 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<505 + 1024 * 0,true> { int V __attribute__ ((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<505 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<506 + 1024 * 0,true> { int V __attribute__ ((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<506 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<507 + 1024 * 0,true> { int V __attribute__ ((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<507 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<508 + 1024 * 0,true> { int V __attribute__ ((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<508 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<509 + 1024 * 0,true> { int V __attribute__ ((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<509 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<510 + 1024 * 0,true> { int V __attribute__ ((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<510 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<511 + 1024 * 0,true> { int V __attribute__ ((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<511 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<512 + 1024 * 0,true> { int V __attribute__ ((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<512 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<513 + 1024 * 0,true> { int V __attribute__ ((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<513 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<514 + 1024 * 0,true> { int V __attribute__ ((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<514 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<515 + 1024 * 0,true> { int V __attribute__ ((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<515 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<516 + 1024 * 0,true> { int V __attribute__ ((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<516 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<517 + 1024 * 0,true> { int V __attribute__ ((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<517 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<518 + 1024 * 0,true> { int V __attribute__ ((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<518 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<519 + 1024 * 0,true> { int V __attribute__ ((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<519 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<520 + 1024 * 0,true> { int V __attribute__ ((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<520 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<521 + 1024 * 0,true> { int V __attribute__ ((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<521 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<522 + 1024 * 0,true> { int V __attribute__ ((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<522 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<523 + 1024 * 0,true> { int V __attribute__ ((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<523 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<524 + 1024 * 0,true> { int V __attribute__ ((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<524 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<525 + 1024 * 0,true> { int V __attribute__ ((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<525 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<526 + 1024 * 0,true> { int V __attribute__ ((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<526 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<527 + 1024 * 0,true> { int V __attribute__ ((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<527 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<528 + 1024 * 0,true> { int V __attribute__ ((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<528 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<529 + 1024 * 0,true> { int V __attribute__ ((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<529 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<530 + 1024 * 0,true> { int V __attribute__ ((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<530 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<531 + 1024 * 0,true> { int V __attribute__ ((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<531 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<532 + 1024 * 0,true> { int V __attribute__ ((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<532 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<533 + 1024 * 0,true> { int V __attribute__ ((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<533 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<534 + 1024 * 0,true> { int V __attribute__ ((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<534 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<535 + 1024 * 0,true> { int V __attribute__ ((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<535 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<536 + 1024 * 0,true> { int V __attribute__ ((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<536 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<537 + 1024 * 0,true> { int V __attribute__ ((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<537 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<538 + 1024 * 0,true> { int V __attribute__ ((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<538 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<539 + 1024 * 0,true> { int V __attribute__ ((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<539 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<540 + 1024 * 0,true> { int V __attribute__ ((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<540 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<541 + 1024 * 0,true> { int V __attribute__ ((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<541 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<542 + 1024 * 0,true> { int V __attribute__ ((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<542 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<543 + 1024 * 0,true> { int V __attribute__ ((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<543 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<544 + 1024 * 0,true> { int V __attribute__ ((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<544 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<545 + 1024 * 0,true> { int V __attribute__ ((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<545 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<546 + 1024 * 0,true> { int V __attribute__ ((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<546 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<547 + 1024 * 0,true> { int V __attribute__ ((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<547 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<548 + 1024 * 0,true> { int V __attribute__ ((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<548 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<549 + 1024 * 0,true> { int V __attribute__ ((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<549 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<550 + 1024 * 0,true> { int V __attribute__ ((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<550 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<551 + 1024 * 0,true> { int V __attribute__ ((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<551 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<552 + 1024 * 0,true> { int V __attribute__ ((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<552 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<553 + 1024 * 0,true> { int V __attribute__ ((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<553 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<554 + 1024 * 0,true> { int V __attribute__ ((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<554 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<555 + 1024 * 0,true> { int V __attribute__ ((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<555 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<556 + 1024 * 0,true> { int V __attribute__ ((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<556 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<557 + 1024 * 0,true> { int V __attribute__ ((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<557 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<558 + 1024 * 0,true> { int V __attribute__ ((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<558 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<559 + 1024 * 0,true> { int V __attribute__ ((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<559 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<560 + 1024 * 0,true> { int V __attribute__ ((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<560 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<561 + 1024 * 0,true> { int V __attribute__ ((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<561 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<562 + 1024 * 0,true> { int V __attribute__ ((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<562 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<563 + 1024 * 0,true> { int V __attribute__ ((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<563 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<564 + 1024 * 0,true> { int V __attribute__ ((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<564 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<565 + 1024 * 0,true> { int V __attribute__ ((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<565 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<566 + 1024 * 0,true> { int V __attribute__ ((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<566 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<567 + 1024 * 0,true> { int V __attribute__ ((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<567 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<568 + 1024 * 0,true> { int V __attribute__ ((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<568 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<569 + 1024 * 0,true> { int V __attribute__ ((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<569 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<570 + 1024 * 0,true> { int V __attribute__ ((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<570 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<571 + 1024 * 0,true> { int V __attribute__ ((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<571 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<572 + 1024 * 0,true> { int V __attribute__ ((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<572 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<573 + 1024 * 0,true> { int V __attribute__ ((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<573 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<574 + 1024 * 0,true> { int V __attribute__ ((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<574 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<575 + 1024 * 0,true> { int V __attribute__ ((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<575 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<576 + 1024 * 0,true> { int V __attribute__ ((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<576 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<577 + 1024 * 0,true> { int V __attribute__ ((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<577 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<578 + 1024 * 0,true> { int V __attribute__ ((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<578 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<579 + 1024 * 0,true> { int V __attribute__ ((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<579 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<580 + 1024 * 0,true> { int V __attribute__ ((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<580 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<581 + 1024 * 0,true> { int V __attribute__ ((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<581 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<582 + 1024 * 0,true> { int V __attribute__ ((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<582 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<583 + 1024 * 0,true> { int V __attribute__ ((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<583 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<584 + 1024 * 0,true> { int V __attribute__ ((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<584 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<585 + 1024 * 0,true> { int V __attribute__ ((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<585 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<586 + 1024 * 0,true> { int V __attribute__ ((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<586 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<587 + 1024 * 0,true> { int V __attribute__ ((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<587 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<588 + 1024 * 0,true> { int V __attribute__ ((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<588 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<589 + 1024 * 0,true> { int V __attribute__ ((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<589 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<590 + 1024 * 0,true> { int V __attribute__ ((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<590 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<591 + 1024 * 0,true> { int V __attribute__ ((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<591 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<592 + 1024 * 0,true> { int V __attribute__ ((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<592 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<593 + 1024 * 0,true> { int V __attribute__ ((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<593 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<594 + 1024 * 0,true> { int V __attribute__ ((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<594 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<595 + 1024 * 0,true> { int V __attribute__ ((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<595 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<596 + 1024 * 0,true> { int V __attribute__ ((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<596 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<597 + 1024 * 0,true> { int V __attribute__ ((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<597 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<598 + 1024 * 0,true> { int V __attribute__ ((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<598 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<599 + 1024 * 0,true> { int V __attribute__ ((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<599 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<600 + 1024 * 0,true> { int V __attribute__ ((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<600 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<601 + 1024 * 0,true> { int V __attribute__ ((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<601 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<602 + 1024 * 0,true> { int V __attribute__ ((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<602 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<603 + 1024 * 0,true> { int V __attribute__ ((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<603 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<604 + 1024 * 0,true> { int V __attribute__ ((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<604 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<605 + 1024 * 0,true> { int V __attribute__ ((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<605 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<606 + 1024 * 0,true> { int V __attribute__ ((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<606 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<607 + 1024 * 0,true> { int V __attribute__ ((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<607 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<608 + 1024 * 0,true> { int V __attribute__ ((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<608 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<609 + 1024 * 0,true> { int V __attribute__ ((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<609 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<610 + 1024 * 0,true> { int V __attribute__ ((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<610 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<611 + 1024 * 0,true> { int V __attribute__ ((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<611 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<612 + 1024 * 0,true> { int V __attribute__ ((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<612 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<613 + 1024 * 0,true> { int V __attribute__ ((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<613 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<614 + 1024 * 0,true> { int V __attribute__ ((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<614 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<615 + 1024 * 0,true> { int V __attribute__ ((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<615 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<616 + 1024 * 0,true> { int V __attribute__ ((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<616 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<617 + 1024 * 0,true> { int V __attribute__ ((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<617 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<618 + 1024 * 0,true> { int V __attribute__ ((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<618 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<619 + 1024 * 0,true> { int V __attribute__ ((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<619 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<620 + 1024 * 0,true> { int V __attribute__ ((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<620 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<621 + 1024 * 0,true> { int V __attribute__ ((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<621 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<622 + 1024 * 0,true> { int V __attribute__ ((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<622 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<623 + 1024 * 0,true> { int V __attribute__ ((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<623 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<624 + 1024 * 0,true> { int V __attribute__ ((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<624 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<625 + 1024 * 0,true> { int V __attribute__ ((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<625 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<626 + 1024 * 0,true> { int V __attribute__ ((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<626 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<627 + 1024 * 0,true> { int V __attribute__ ((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<627 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<628 + 1024 * 0,true> { int V __attribute__ ((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<628 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<629 + 1024 * 0,true> { int V __attribute__ ((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<629 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<630 + 1024 * 0,true> { int V __attribute__ ((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<630 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<631 + 1024 * 0,true> { int V __attribute__ ((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<631 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<632 + 1024 * 0,true> { int V __attribute__ ((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<632 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<633 + 1024 * 0,true> { int V __attribute__ ((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<633 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<634 + 1024 * 0,true> { int V __attribute__ ((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<634 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<635 + 1024 * 0,true> { int V __attribute__ ((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<635 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<636 + 1024 * 0,true> { int V __attribute__ ((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<636 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<637 + 1024 * 0,true> { int V __attribute__ ((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<637 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<638 + 1024 * 0,true> { int V __attribute__ ((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<638 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<639 + 1024 * 0,true> { int V __attribute__ ((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<639 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<640 + 1024 * 0,true> { int V __attribute__ ((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<640 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<641 + 1024 * 0,true> { int V __attribute__ ((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<641 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<642 + 1024 * 0,true> { int V __attribute__ ((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<642 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<643 + 1024 * 0,true> { int V __attribute__ ((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<643 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<644 + 1024 * 0,true> { int V __attribute__ ((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<644 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<645 + 1024 * 0,true> { int V __attribute__ ((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<645 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<646 + 1024 * 0,true> { int V __attribute__ ((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<646 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<647 + 1024 * 0,true> { int V __attribute__ ((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<647 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<648 + 1024 * 0,true> { int V __attribute__ ((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<648 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<649 + 1024 * 0,true> { int V __attribute__ ((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<649 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<650 + 1024 * 0,true> { int V __attribute__ ((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<650 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<651 + 1024 * 0,true> { int V __attribute__ ((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<651 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<652 + 1024 * 0,true> { int V __attribute__ ((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<652 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<653 + 1024 * 0,true> { int V __attribute__ ((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<653 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<654 + 1024 * 0,true> { int V __attribute__ ((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<654 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<655 + 1024 * 0,true> { int V __attribute__ ((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<655 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<656 + 1024 * 0,true> { int V __attribute__ ((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<656 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<657 + 1024 * 0,true> { int V __attribute__ ((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<657 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<658 + 1024 * 0,true> { int V __attribute__ ((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<658 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<659 + 1024 * 0,true> { int V __attribute__ ((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<659 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<660 + 1024 * 0,true> { int V __attribute__ ((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<660 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<661 + 1024 * 0,true> { int V __attribute__ ((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<661 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<662 + 1024 * 0,true> { int V __attribute__ ((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<662 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<663 + 1024 * 0,true> { int V __attribute__ ((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<663 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<664 + 1024 * 0,true> { int V __attribute__ ((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<664 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<665 + 1024 * 0,true> { int V __attribute__ ((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<665 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<666 + 1024 * 0,true> { int V __attribute__ ((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<666 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<667 + 1024 * 0,true> { int V __attribute__ ((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<667 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<668 + 1024 * 0,true> { int V __attribute__ ((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<668 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<669 + 1024 * 0,true> { int V __attribute__ ((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<669 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<670 + 1024 * 0,true> { int V __attribute__ ((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<670 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<671 + 1024 * 0,true> { int V __attribute__ ((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<671 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<672 + 1024 * 0,true> { int V __attribute__ ((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<672 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<673 + 1024 * 0,true> { int V __attribute__ ((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<673 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<674 + 1024 * 0,true> { int V __attribute__ ((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<674 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<675 + 1024 * 0,true> { int V __attribute__ ((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<675 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<676 + 1024 * 0,true> { int V __attribute__ ((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<676 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<677 + 1024 * 0,true> { int V __attribute__ ((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<677 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<678 + 1024 * 0,true> { int V __attribute__ ((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<678 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<679 + 1024 * 0,true> { int V __attribute__ ((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<679 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<680 + 1024 * 0,true> { int V __attribute__ ((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<680 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<681 + 1024 * 0,true> { int V __attribute__ ((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<681 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<682 + 1024 * 0,true> { int V __attribute__ ((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<682 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<683 + 1024 * 0,true> { int V __attribute__ ((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<683 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<684 + 1024 * 0,true> { int V __attribute__ ((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<684 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<685 + 1024 * 0,true> { int V __attribute__ ((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<685 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<686 + 1024 * 0,true> { int V __attribute__ ((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<686 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<687 + 1024 * 0,true> { int V __attribute__ ((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<687 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<688 + 1024 * 0,true> { int V __attribute__ ((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<688 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<689 + 1024 * 0,true> { int V __attribute__ ((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<689 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<690 + 1024 * 0,true> { int V __attribute__ ((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<690 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<691 + 1024 * 0,true> { int V __attribute__ ((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<691 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<692 + 1024 * 0,true> { int V __attribute__ ((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<692 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<693 + 1024 * 0,true> { int V __attribute__ ((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<693 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<694 + 1024 * 0,true> { int V __attribute__ ((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<694 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<695 + 1024 * 0,true> { int V __attribute__ ((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<695 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<696 + 1024 * 0,true> { int V __attribute__ ((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<696 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<697 + 1024 * 0,true> { int V __attribute__ ((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<697 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<698 + 1024 * 0,true> { int V __attribute__ ((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<698 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<699 + 1024 * 0,true> { int V __attribute__ ((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<699 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<700 + 1024 * 0,true> { int V __attribute__ ((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<700 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<701 + 1024 * 0,true> { int V __attribute__ ((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<701 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<702 + 1024 * 0,true> { int V __attribute__ ((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<702 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<703 + 1024 * 0,true> { int V __attribute__ ((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<703 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<704 + 1024 * 0,true> { int V __attribute__ ((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<704 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<705 + 1024 * 0,true> { int V __attribute__ ((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<705 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<706 + 1024 * 0,true> { int V __attribute__ ((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<706 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<707 + 1024 * 0,true> { int V __attribute__ ((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<707 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<708 + 1024 * 0,true> { int V __attribute__ ((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<708 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<709 + 1024 * 0,true> { int V __attribute__ ((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<709 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<710 + 1024 * 0,true> { int V __attribute__ ((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<710 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<711 + 1024 * 0,true> { int V __attribute__ ((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<711 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<712 + 1024 * 0,true> { int V __attribute__ ((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<712 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<713 + 1024 * 0,true> { int V __attribute__ ((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<713 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<714 + 1024 * 0,true> { int V __attribute__ ((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<714 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<715 + 1024 * 0,true> { int V __attribute__ ((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<715 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<716 + 1024 * 0,true> { int V __attribute__ ((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<716 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<717 + 1024 * 0,true> { int V __attribute__ ((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<717 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<718 + 1024 * 0,true> { int V __attribute__ ((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<718 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<719 + 1024 * 0,true> { int V __attribute__ ((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<719 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<720 + 1024 * 0,true> { int V __attribute__ ((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<720 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<721 + 1024 * 0,true> { int V __attribute__ ((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<721 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<722 + 1024 * 0,true> { int V __attribute__ ((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<722 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<723 + 1024 * 0,true> { int V __attribute__ ((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<723 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<724 + 1024 * 0,true> { int V __attribute__ ((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<724 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<725 + 1024 * 0,true> { int V __attribute__ ((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<725 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<726 + 1024 * 0,true> { int V __attribute__ ((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<726 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<727 + 1024 * 0,true> { int V __attribute__ ((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<727 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<728 + 1024 * 0,true> { int V __attribute__ ((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<728 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<729 + 1024 * 0,true> { int V __attribute__ ((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<729 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<730 + 1024 * 0,true> { int V __attribute__ ((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<730 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<731 + 1024 * 0,true> { int V __attribute__ ((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<731 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<732 + 1024 * 0,true> { int V __attribute__ ((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<732 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<733 + 1024 * 0,true> { int V __attribute__ ((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<733 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<734 + 1024 * 0,true> { int V __attribute__ ((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<734 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<735 + 1024 * 0,true> { int V __attribute__ ((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<735 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<736 + 1024 * 0,true> { int V __attribute__ ((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<736 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<737 + 1024 * 0,true> { int V __attribute__ ((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<737 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<738 + 1024 * 0,true> { int V __attribute__ ((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<738 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<739 + 1024 * 0,true> { int V __attribute__ ((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<739 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<740 + 1024 * 0,true> { int V __attribute__ ((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<740 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<741 + 1024 * 0,true> { int V __attribute__ ((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<741 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<742 + 1024 * 0,true> { int V __attribute__ ((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<742 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<743 + 1024 * 0,true> { int V __attribute__ ((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<743 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<744 + 1024 * 0,true> { int V __attribute__ ((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<744 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<745 + 1024 * 0,true> { int V __attribute__ ((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<745 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<746 + 1024 * 0,true> { int V __attribute__ ((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<746 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<747 + 1024 * 0,true> { int V __attribute__ ((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<747 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<748 + 1024 * 0,true> { int V __attribute__ ((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<748 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<749 + 1024 * 0,true> { int V __attribute__ ((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<749 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<750 + 1024 * 0,true> { int V __attribute__ ((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<750 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<751 + 1024 * 0,true> { int V __attribute__ ((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<751 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<752 + 1024 * 0,true> { int V __attribute__ ((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<752 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<753 + 1024 * 0,true> { int V __attribute__ ((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<753 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<754 + 1024 * 0,true> { int V __attribute__ ((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<754 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<755 + 1024 * 0,true> { int V __attribute__ ((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<755 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<756 + 1024 * 0,true> { int V __attribute__ ((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<756 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<757 + 1024 * 0,true> { int V __attribute__ ((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<757 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<758 + 1024 * 0,true> { int V __attribute__ ((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<758 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<759 + 1024 * 0,true> { int V __attribute__ ((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<759 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<760 + 1024 * 0,true> { int V __attribute__ ((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<760 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<761 + 1024 * 0,true> { int V __attribute__ ((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<761 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<762 + 1024 * 0,true> { int V __attribute__ ((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<762 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<763 + 1024 * 0,true> { int V __attribute__ ((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<763 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<764 + 1024 * 0,true> { int V __attribute__ ((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<764 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<765 + 1024 * 0,true> { int V __attribute__ ((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<765 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<766 + 1024 * 0,true> { int V __attribute__ ((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<766 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<767 + 1024 * 0,true> { int V __attribute__ ((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<767 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<768 + 1024 * 0,true> { int V __attribute__ ((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<768 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<769 + 1024 * 0,true> { int V __attribute__ ((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<769 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<770 + 1024 * 0,true> { int V __attribute__ ((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<770 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<771 + 1024 * 0,true> { int V __attribute__ ((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<771 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<772 + 1024 * 0,true> { int V __attribute__ ((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<772 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<773 + 1024 * 0,true> { int V __attribute__ ((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<773 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<774 + 1024 * 0,true> { int V __attribute__ ((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<774 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<775 + 1024 * 0,true> { int V __attribute__ ((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<775 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<776 + 1024 * 0,true> { int V __attribute__ ((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<776 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<777 + 1024 * 0,true> { int V __attribute__ ((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<777 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<778 + 1024 * 0,true> { int V __attribute__ ((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<778 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<779 + 1024 * 0,true> { int V __attribute__ ((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<779 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<780 + 1024 * 0,true> { int V __attribute__ ((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<780 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<781 + 1024 * 0,true> { int V __attribute__ ((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<781 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<782 + 1024 * 0,true> { int V __attribute__ ((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<782 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<783 + 1024 * 0,true> { int V __attribute__ ((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<783 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<784 + 1024 * 0,true> { int V __attribute__ ((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<784 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<785 + 1024 * 0,true> { int V __attribute__ ((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<785 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<786 + 1024 * 0,true> { int V __attribute__ ((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<786 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<787 + 1024 * 0,true> { int V __attribute__ ((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<787 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<788 + 1024 * 0,true> { int V __attribute__ ((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<788 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<789 + 1024 * 0,true> { int V __attribute__ ((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<789 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<790 + 1024 * 0,true> { int V __attribute__ ((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<790 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<791 + 1024 * 0,true> { int V __attribute__ ((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<791 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<792 + 1024 * 0,true> { int V __attribute__ ((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<792 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<793 + 1024 * 0,true> { int V __attribute__ ((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<793 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<794 + 1024 * 0,true> { int V __attribute__ ((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<794 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<795 + 1024 * 0,true> { int V __attribute__ ((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<795 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<796 + 1024 * 0,true> { int V __attribute__ ((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<796 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<797 + 1024 * 0,true> { int V __attribute__ ((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<797 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<798 + 1024 * 0,true> { int V __attribute__ ((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<798 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<799 + 1024 * 0,true> { int V __attribute__ ((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<799 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<800 + 1024 * 0,true> { int V __attribute__ ((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<800 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<801 + 1024 * 0,true> { int V __attribute__ ((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<801 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<802 + 1024 * 0,true> { int V __attribute__ ((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<802 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<803 + 1024 * 0,true> { int V __attribute__ ((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<803 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<804 + 1024 * 0,true> { int V __attribute__ ((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<804 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<805 + 1024 * 0,true> { int V __attribute__ ((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<805 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<806 + 1024 * 0,true> { int V __attribute__ ((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<806 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<807 + 1024 * 0,true> { int V __attribute__ ((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<807 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<808 + 1024 * 0,true> { int V __attribute__ ((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<808 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<809 + 1024 * 0,true> { int V __attribute__ ((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<809 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<810 + 1024 * 0,true> { int V __attribute__ ((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<810 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<811 + 1024 * 0,true> { int V __attribute__ ((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<811 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<812 + 1024 * 0,true> { int V __attribute__ ((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<812 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<813 + 1024 * 0,true> { int V __attribute__ ((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<813 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<814 + 1024 * 0,true> { int V __attribute__ ((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<814 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<815 + 1024 * 0,true> { int V __attribute__ ((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<815 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<816 + 1024 * 0,true> { int V __attribute__ ((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<816 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<817 + 1024 * 0,true> { int V __attribute__ ((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<817 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<818 + 1024 * 0,true> { int V __attribute__ ((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<818 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<819 + 1024 * 0,true> { int V __attribute__ ((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<819 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<820 + 1024 * 0,true> { int V __attribute__ ((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<820 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<821 + 1024 * 0,true> { int V __attribute__ ((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<821 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<822 + 1024 * 0,true> { int V __attribute__ ((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<822 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<823 + 1024 * 0,true> { int V __attribute__ ((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<823 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<824 + 1024 * 0,true> { int V __attribute__ ((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<824 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<825 + 1024 * 0,true> { int V __attribute__ ((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<825 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<826 + 1024 * 0,true> { int V __attribute__ ((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<826 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<827 + 1024 * 0,true> { int V __attribute__ ((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<827 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<828 + 1024 * 0,true> { int V __attribute__ ((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<828 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<829 + 1024 * 0,true> { int V __attribute__ ((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<829 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<830 + 1024 * 0,true> { int V __attribute__ ((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<830 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<831 + 1024 * 0,true> { int V __attribute__ ((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<831 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<832 + 1024 * 0,true> { int V __attribute__ ((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<832 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<833 + 1024 * 0,true> { int V __attribute__ ((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<833 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<834 + 1024 * 0,true> { int V __attribute__ ((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<834 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<835 + 1024 * 0,true> { int V __attribute__ ((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<835 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<836 + 1024 * 0,true> { int V __attribute__ ((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<836 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<837 + 1024 * 0,true> { int V __attribute__ ((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<837 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<838 + 1024 * 0,true> { int V __attribute__ ((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<838 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<839 + 1024 * 0,true> { int V __attribute__ ((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<839 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<840 + 1024 * 0,true> { int V __attribute__ ((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<840 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<841 + 1024 * 0,true> { int V __attribute__ ((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<841 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<842 + 1024 * 0,true> { int V __attribute__ ((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<842 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<843 + 1024 * 0,true> { int V __attribute__ ((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<843 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<844 + 1024 * 0,true> { int V __attribute__ ((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<844 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<845 + 1024 * 0,true> { int V __attribute__ ((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<845 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<846 + 1024 * 0,true> { int V __attribute__ ((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<846 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<847 + 1024 * 0,true> { int V __attribute__ ((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<847 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<848 + 1024 * 0,true> { int V __attribute__ ((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<848 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<849 + 1024 * 0,true> { int V __attribute__ ((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<849 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<850 + 1024 * 0,true> { int V __attribute__ ((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<850 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<851 + 1024 * 0,true> { int V __attribute__ ((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<851 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<852 + 1024 * 0,true> { int V __attribute__ ((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<852 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<853 + 1024 * 0,true> { int V __attribute__ ((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<853 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<854 + 1024 * 0,true> { int V __attribute__ ((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<854 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<855 + 1024 * 0,true> { int V __attribute__ ((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<855 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<856 + 1024 * 0,true> { int V __attribute__ ((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<856 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<857 + 1024 * 0,true> { int V __attribute__ ((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<857 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<858 + 1024 * 0,true> { int V __attribute__ ((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<858 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<859 + 1024 * 0,true> { int V __attribute__ ((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<859 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<860 + 1024 * 0,true> { int V __attribute__ ((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<860 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<861 + 1024 * 0,true> { int V __attribute__ ((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<861 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<862 + 1024 * 0,true> { int V __attribute__ ((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<862 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<863 + 1024 * 0,true> { int V __attribute__ ((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<863 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<864 + 1024 * 0,true> { int V __attribute__ ((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<864 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<865 + 1024 * 0,true> { int V __attribute__ ((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<865 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<866 + 1024 * 0,true> { int V __attribute__ ((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<866 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<867 + 1024 * 0,true> { int V __attribute__ ((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<867 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<868 + 1024 * 0,true> { int V __attribute__ ((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<868 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<869 + 1024 * 0,true> { int V __attribute__ ((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<869 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<870 + 1024 * 0,true> { int V __attribute__ ((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<870 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<871 + 1024 * 0,true> { int V __attribute__ ((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<871 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<872 + 1024 * 0,true> { int V __attribute__ ((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<872 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<873 + 1024 * 0,true> { int V __attribute__ ((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<873 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<874 + 1024 * 0,true> { int V __attribute__ ((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<874 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<875 + 1024 * 0,true> { int V __attribute__ ((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<875 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<876 + 1024 * 0,true> { int V __attribute__ ((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<876 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<877 + 1024 * 0,true> { int V __attribute__ ((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<877 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<878 + 1024 * 0,true> { int V __attribute__ ((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<878 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<879 + 1024 * 0,true> { int V __attribute__ ((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<879 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<880 + 1024 * 0,true> { int V __attribute__ ((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<880 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<881 + 1024 * 0,true> { int V __attribute__ ((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<881 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<882 + 1024 * 0,true> { int V __attribute__ ((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<882 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<883 + 1024 * 0,true> { int V __attribute__ ((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<883 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<884 + 1024 * 0,true> { int V __attribute__ ((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<884 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<885 + 1024 * 0,true> { int V __attribute__ ((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<885 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<886 + 1024 * 0,true> { int V __attribute__ ((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<886 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<887 + 1024 * 0,true> { int V __attribute__ ((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<887 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<888 + 1024 * 0,true> { int V __attribute__ ((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<888 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<889 + 1024 * 0,true> { int V __attribute__ ((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<889 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<890 + 1024 * 0,true> { int V __attribute__ ((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<890 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<891 + 1024 * 0,true> { int V __attribute__ ((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<891 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<892 + 1024 * 0,true> { int V __attribute__ ((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<892 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<893 + 1024 * 0,true> { int V __attribute__ ((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<893 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<894 + 1024 * 0,true> { int V __attribute__ ((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<894 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<895 + 1024 * 0,true> { int V __attribute__ ((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<895 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<896 + 1024 * 0,true> { int V __attribute__ ((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<896 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<897 + 1024 * 0,true> { int V __attribute__ ((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<897 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<898 + 1024 * 0,true> { int V __attribute__ ((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<898 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<899 + 1024 * 0,true> { int V __attribute__ ((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<899 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<900 + 1024 * 0,true> { int V __attribute__ ((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<900 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<901 + 1024 * 0,true> { int V __attribute__ ((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<901 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<902 + 1024 * 0,true> { int V __attribute__ ((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<902 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<903 + 1024 * 0,true> { int V __attribute__ ((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<903 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<904 + 1024 * 0,true> { int V __attribute__ ((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<904 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<905 + 1024 * 0,true> { int V __attribute__ ((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<905 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<906 + 1024 * 0,true> { int V __attribute__ ((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<906 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<907 + 1024 * 0,true> { int V __attribute__ ((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<907 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<908 + 1024 * 0,true> { int V __attribute__ ((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<908 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<909 + 1024 * 0,true> { int V __attribute__ ((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<909 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<910 + 1024 * 0,true> { int V __attribute__ ((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<910 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<911 + 1024 * 0,true> { int V __attribute__ ((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<911 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<912 + 1024 * 0,true> { int V __attribute__ ((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<912 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<913 + 1024 * 0,true> { int V __attribute__ ((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<913 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<914 + 1024 * 0,true> { int V __attribute__ ((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<914 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<915 + 1024 * 0,true> { int V __attribute__ ((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<915 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<916 + 1024 * 0,true> { int V __attribute__ ((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<916 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<917 + 1024 * 0,true> { int V __attribute__ ((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<917 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<918 + 1024 * 0,true> { int V __attribute__ ((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<918 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<919 + 1024 * 0,true> { int V __attribute__ ((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<919 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<920 + 1024 * 0,true> { int V __attribute__ ((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<920 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<921 + 1024 * 0,true> { int V __attribute__ ((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<921 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<922 + 1024 * 0,true> { int V __attribute__ ((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<922 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<923 + 1024 * 0,true> { int V __attribute__ ((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<923 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<924 + 1024 * 0,true> { int V __attribute__ ((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<924 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<925 + 1024 * 0,true> { int V __attribute__ ((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<925 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<926 + 1024 * 0,true> { int V __attribute__ ((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<926 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<927 + 1024 * 0,true> { int V __attribute__ ((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<927 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<928 + 1024 * 0,true> { int V __attribute__ ((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<928 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<929 + 1024 * 0,true> { int V __attribute__ ((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<929 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<930 + 1024 * 0,true> { int V __attribute__ ((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<930 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<931 + 1024 * 0,true> { int V __attribute__ ((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<931 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<932 + 1024 * 0,true> { int V __attribute__ ((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<932 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<933 + 1024 * 0,true> { int V __attribute__ ((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<933 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<934 + 1024 * 0,true> { int V __attribute__ ((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<934 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<935 + 1024 * 0,true> { int V __attribute__ ((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<935 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<936 + 1024 * 0,true> { int V __attribute__ ((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<936 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<937 + 1024 * 0,true> { int V __attribute__ ((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<937 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<938 + 1024 * 0,true> { int V __attribute__ ((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<938 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<939 + 1024 * 0,true> { int V __attribute__ ((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<939 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<940 + 1024 * 0,true> { int V __attribute__ ((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<940 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<941 + 1024 * 0,true> { int V __attribute__ ((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<941 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<942 + 1024 * 0,true> { int V __attribute__ ((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<942 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<943 + 1024 * 0,true> { int V __attribute__ ((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<943 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<944 + 1024 * 0,true> { int V __attribute__ ((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<944 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<945 + 1024 * 0,true> { int V __attribute__ ((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<945 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<946 + 1024 * 0,true> { int V __attribute__ ((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<946 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<947 + 1024 * 0,true> { int V __attribute__ ((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<947 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<948 + 1024 * 0,true> { int V __attribute__ ((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<948 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<949 + 1024 * 0,true> { int V __attribute__ ((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<949 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<950 + 1024 * 0,true> { int V __attribute__ ((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<950 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<951 + 1024 * 0,true> { int V __attribute__ ((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<951 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<952 + 1024 * 0,true> { int V __attribute__ ((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<952 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<953 + 1024 * 0,true> { int V __attribute__ ((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<953 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<954 + 1024 * 0,true> { int V __attribute__ ((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<954 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<955 + 1024 * 0,true> { int V __attribute__ ((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<955 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<956 + 1024 * 0,true> { int V __attribute__ ((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<956 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<957 + 1024 * 0,true> { int V __attribute__ ((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<957 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<958 + 1024 * 0,true> { int V __attribute__ ((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<958 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<959 + 1024 * 0,true> { int V __attribute__ ((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<959 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<960 + 1024 * 0,true> { int V __attribute__ ((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<960 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<961 + 1024 * 0,true> { int V __attribute__ ((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<961 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<962 + 1024 * 0,true> { int V __attribute__ ((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<962 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<963 + 1024 * 0,true> { int V __attribute__ ((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<963 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<964 + 1024 * 0,true> { int V __attribute__ ((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<964 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<965 + 1024 * 0,true> { int V __attribute__ ((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<965 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<966 + 1024 * 0,true> { int V __attribute__ ((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<966 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<967 + 1024 * 0,true> { int V __attribute__ ((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<967 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<968 + 1024 * 0,true> { int V __attribute__ ((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<968 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<969 + 1024 * 0,true> { int V __attribute__ ((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<969 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<970 + 1024 * 0,true> { int V __attribute__ ((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<970 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<971 + 1024 * 0,true> { int V __attribute__ ((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<971 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<972 + 1024 * 0,true> { int V __attribute__ ((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<972 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<973 + 1024 * 0,true> { int V __attribute__ ((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<973 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<974 + 1024 * 0,true> { int V __attribute__ ((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<974 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<975 + 1024 * 0,true> { int V __attribute__ ((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<975 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<976 + 1024 * 0,true> { int V __attribute__ ((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<976 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<977 + 1024 * 0,true> { int V __attribute__ ((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<977 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<978 + 1024 * 0,true> { int V __attribute__ ((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<978 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<979 + 1024 * 0,true> { int V __attribute__ ((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<979 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<980 + 1024 * 0,true> { int V __attribute__ ((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<980 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<981 + 1024 * 0,true> { int V __attribute__ ((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<981 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<982 + 1024 * 0,true> { int V __attribute__ ((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<982 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<983 + 1024 * 0,true> { int V __attribute__ ((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<983 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<984 + 1024 * 0,true> { int V __attribute__ ((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<984 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<985 + 1024 * 0,true> { int V __attribute__ ((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<985 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<986 + 1024 * 0,true> { int V __attribute__ ((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<986 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<987 + 1024 * 0,true> { int V __attribute__ ((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<987 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<988 + 1024 * 0,true> { int V __attribute__ ((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<988 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<989 + 1024 * 0,true> { int V __attribute__ ((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<989 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<990 + 1024 * 0,true> { int V __attribute__ ((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<990 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<991 + 1024 * 0,true> { int V __attribute__ ((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<991 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<992 + 1024 * 0,true> { int V __attribute__ ((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<992 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<993 + 1024 * 0,true> { int V __attribute__ ((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<993 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<994 + 1024 * 0,true> { int V __attribute__ ((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<994 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<995 + 1024 * 0,true> { int V __attribute__ ((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<995 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<996 + 1024 * 0,true> { int V __attribute__ ((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<996 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<997 + 1024 * 0,true> { int V __attribute__ ((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<997 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<998 + 1024 * 0,true> { int V __attribute__ ((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<998 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<999 + 1024 * 0,true> { int V __attribute__ ((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<999 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1000 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1000 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1001 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1001 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1002 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1002 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1003 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1003 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1004 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1004 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1005 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1005 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1006 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1006 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1007 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1007 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1008 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1008 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1009 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1009 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1010 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1010 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1011 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1011 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1012 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1012 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1013 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1013 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1014 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1014 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1015 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1015 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1016 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1016 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1017 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1017 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1018 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1018 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1019 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1019 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1020 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1020 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1021 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1021 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1022 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1022 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1023 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1023 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1024 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1024 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0 , false>() { }; };
#pragma line 133 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_dt.def" 1
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<1 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<2 + 1024 * 1,true> { int V __attribute__ ((bitwidth(2 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<2 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(2 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<3 + 1024 * 1,true> { int V __attribute__ ((bitwidth(3 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<3 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(3 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<4 + 1024 * 1,true> { int V __attribute__ ((bitwidth(4 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<4 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(4 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<5 + 1024 * 1,true> { int V __attribute__ ((bitwidth(5 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<5 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(5 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<6 + 1024 * 1,true> { int V __attribute__ ((bitwidth(6 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<6 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(6 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<7 + 1024 * 1,true> { int V __attribute__ ((bitwidth(7 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<7 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(7 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<8 + 1024 * 1,true> { int V __attribute__ ((bitwidth(8 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<8 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(8 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<9 + 1024 * 1,true> { int V __attribute__ ((bitwidth(9 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<9 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(9 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<10 + 1024 * 1,true> { int V __attribute__ ((bitwidth(10 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<10 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(10 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<11 + 1024 * 1,true> { int V __attribute__ ((bitwidth(11 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<11 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(11 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<12 + 1024 * 1,true> { int V __attribute__ ((bitwidth(12 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<12 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(12 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<13 + 1024 * 1,true> { int V __attribute__ ((bitwidth(13 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<13 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(13 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<14 + 1024 * 1,true> { int V __attribute__ ((bitwidth(14 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<14 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(14 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<15 + 1024 * 1,true> { int V __attribute__ ((bitwidth(15 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<15 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(15 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<16 + 1024 * 1,true> { int V __attribute__ ((bitwidth(16 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<16 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(16 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<17 + 1024 * 1,true> { int V __attribute__ ((bitwidth(17 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<17 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(17 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<18 + 1024 * 1,true> { int V __attribute__ ((bitwidth(18 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<18 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(18 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<19 + 1024 * 1,true> { int V __attribute__ ((bitwidth(19 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<19 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(19 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<20 + 1024 * 1,true> { int V __attribute__ ((bitwidth(20 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<20 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(20 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<21 + 1024 * 1,true> { int V __attribute__ ((bitwidth(21 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<21 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(21 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<22 + 1024 * 1,true> { int V __attribute__ ((bitwidth(22 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<22 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(22 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<23 + 1024 * 1,true> { int V __attribute__ ((bitwidth(23 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<23 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(23 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<24 + 1024 * 1,true> { int V __attribute__ ((bitwidth(24 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<24 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(24 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<25 + 1024 * 1,true> { int V __attribute__ ((bitwidth(25 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<25 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(25 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<26 + 1024 * 1,true> { int V __attribute__ ((bitwidth(26 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<26 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(26 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<27 + 1024 * 1,true> { int V __attribute__ ((bitwidth(27 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<27 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(27 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<28 + 1024 * 1,true> { int V __attribute__ ((bitwidth(28 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<28 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(28 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<29 + 1024 * 1,true> { int V __attribute__ ((bitwidth(29 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<29 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(29 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<30 + 1024 * 1,true> { int V __attribute__ ((bitwidth(30 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<30 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(30 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<31 + 1024 * 1,true> { int V __attribute__ ((bitwidth(31 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<31 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(31 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<32 + 1024 * 1,true> { int V __attribute__ ((bitwidth(32 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<32 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(32 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<33 + 1024 * 1,true> { int V __attribute__ ((bitwidth(33 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<33 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(33 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<34 + 1024 * 1,true> { int V __attribute__ ((bitwidth(34 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<34 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(34 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<35 + 1024 * 1,true> { int V __attribute__ ((bitwidth(35 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<35 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(35 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<36 + 1024 * 1,true> { int V __attribute__ ((bitwidth(36 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<36 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(36 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<37 + 1024 * 1,true> { int V __attribute__ ((bitwidth(37 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<37 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(37 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<38 + 1024 * 1,true> { int V __attribute__ ((bitwidth(38 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<38 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(38 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<39 + 1024 * 1,true> { int V __attribute__ ((bitwidth(39 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<39 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(39 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<40 + 1024 * 1,true> { int V __attribute__ ((bitwidth(40 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<40 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(40 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<41 + 1024 * 1,true> { int V __attribute__ ((bitwidth(41 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<41 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(41 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<42 + 1024 * 1,true> { int V __attribute__ ((bitwidth(42 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<42 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(42 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<43 + 1024 * 1,true> { int V __attribute__ ((bitwidth(43 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<43 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(43 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<44 + 1024 * 1,true> { int V __attribute__ ((bitwidth(44 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<44 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(44 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<45 + 1024 * 1,true> { int V __attribute__ ((bitwidth(45 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<45 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(45 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<46 + 1024 * 1,true> { int V __attribute__ ((bitwidth(46 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<46 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(46 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<47 + 1024 * 1,true> { int V __attribute__ ((bitwidth(47 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<47 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(47 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<48 + 1024 * 1,true> { int V __attribute__ ((bitwidth(48 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<48 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(48 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<49 + 1024 * 1,true> { int V __attribute__ ((bitwidth(49 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<49 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(49 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<50 + 1024 * 1,true> { int V __attribute__ ((bitwidth(50 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<50 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(50 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<51 + 1024 * 1,true> { int V __attribute__ ((bitwidth(51 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<51 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(51 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<52 + 1024 * 1,true> { int V __attribute__ ((bitwidth(52 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<52 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(52 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<53 + 1024 * 1,true> { int V __attribute__ ((bitwidth(53 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<53 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(53 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<54 + 1024 * 1,true> { int V __attribute__ ((bitwidth(54 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<54 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(54 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<55 + 1024 * 1,true> { int V __attribute__ ((bitwidth(55 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<55 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(55 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<56 + 1024 * 1,true> { int V __attribute__ ((bitwidth(56 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<56 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(56 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<57 + 1024 * 1,true> { int V __attribute__ ((bitwidth(57 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<57 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(57 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<58 + 1024 * 1,true> { int V __attribute__ ((bitwidth(58 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<58 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(58 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<59 + 1024 * 1,true> { int V __attribute__ ((bitwidth(59 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<59 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(59 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<60 + 1024 * 1,true> { int V __attribute__ ((bitwidth(60 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<60 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(60 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<61 + 1024 * 1,true> { int V __attribute__ ((bitwidth(61 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<61 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(61 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<62 + 1024 * 1,true> { int V __attribute__ ((bitwidth(62 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<62 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(62 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<63 + 1024 * 1,true> { int V __attribute__ ((bitwidth(63 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<63 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(63 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 1 , false>() { }; };
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<64 + 1024 * 1,true> { int V __attribute__ ((bitwidth(64 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<64 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(64 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 1 , false>() { }; };
#pragma empty_line
#pragma empty_line
/*#if AUTOPILOT_VERSION >= 1 */
#pragma empty_line
template<> struct ssdm_int<65 + 1024 * 1,true> { int V __attribute__ ((bitwidth(65 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<65 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(65 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<66 + 1024 * 1,true> { int V __attribute__ ((bitwidth(66 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<66 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(66 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<67 + 1024 * 1,true> { int V __attribute__ ((bitwidth(67 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<67 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(67 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<68 + 1024 * 1,true> { int V __attribute__ ((bitwidth(68 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<68 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(68 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<69 + 1024 * 1,true> { int V __attribute__ ((bitwidth(69 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<69 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(69 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<70 + 1024 * 1,true> { int V __attribute__ ((bitwidth(70 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<70 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(70 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<71 + 1024 * 1,true> { int V __attribute__ ((bitwidth(71 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<71 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(71 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<72 + 1024 * 1,true> { int V __attribute__ ((bitwidth(72 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<72 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(72 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<73 + 1024 * 1,true> { int V __attribute__ ((bitwidth(73 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<73 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(73 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<74 + 1024 * 1,true> { int V __attribute__ ((bitwidth(74 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<74 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(74 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<75 + 1024 * 1,true> { int V __attribute__ ((bitwidth(75 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<75 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(75 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<76 + 1024 * 1,true> { int V __attribute__ ((bitwidth(76 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<76 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(76 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<77 + 1024 * 1,true> { int V __attribute__ ((bitwidth(77 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<77 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(77 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<78 + 1024 * 1,true> { int V __attribute__ ((bitwidth(78 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<78 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(78 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<79 + 1024 * 1,true> { int V __attribute__ ((bitwidth(79 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<79 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(79 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<80 + 1024 * 1,true> { int V __attribute__ ((bitwidth(80 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<80 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(80 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<81 + 1024 * 1,true> { int V __attribute__ ((bitwidth(81 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<81 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(81 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<82 + 1024 * 1,true> { int V __attribute__ ((bitwidth(82 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<82 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(82 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<83 + 1024 * 1,true> { int V __attribute__ ((bitwidth(83 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<83 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(83 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<84 + 1024 * 1,true> { int V __attribute__ ((bitwidth(84 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<84 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(84 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<85 + 1024 * 1,true> { int V __attribute__ ((bitwidth(85 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<85 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(85 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<86 + 1024 * 1,true> { int V __attribute__ ((bitwidth(86 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<86 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(86 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<87 + 1024 * 1,true> { int V __attribute__ ((bitwidth(87 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<87 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(87 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<88 + 1024 * 1,true> { int V __attribute__ ((bitwidth(88 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<88 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(88 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<89 + 1024 * 1,true> { int V __attribute__ ((bitwidth(89 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<89 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(89 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<90 + 1024 * 1,true> { int V __attribute__ ((bitwidth(90 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<90 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(90 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<91 + 1024 * 1,true> { int V __attribute__ ((bitwidth(91 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<91 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(91 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<92 + 1024 * 1,true> { int V __attribute__ ((bitwidth(92 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<92 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(92 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<93 + 1024 * 1,true> { int V __attribute__ ((bitwidth(93 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<93 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(93 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<94 + 1024 * 1,true> { int V __attribute__ ((bitwidth(94 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<94 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(94 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<95 + 1024 * 1,true> { int V __attribute__ ((bitwidth(95 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<95 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(95 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<96 + 1024 * 1,true> { int V __attribute__ ((bitwidth(96 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<96 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(96 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<97 + 1024 * 1,true> { int V __attribute__ ((bitwidth(97 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<97 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(97 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<98 + 1024 * 1,true> { int V __attribute__ ((bitwidth(98 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<98 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(98 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<99 + 1024 * 1,true> { int V __attribute__ ((bitwidth(99 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<99 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(99 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<100 + 1024 * 1,true> { int V __attribute__ ((bitwidth(100 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<100 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(100 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<101 + 1024 * 1,true> { int V __attribute__ ((bitwidth(101 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<101 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(101 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<102 + 1024 * 1,true> { int V __attribute__ ((bitwidth(102 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<102 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(102 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<103 + 1024 * 1,true> { int V __attribute__ ((bitwidth(103 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<103 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(103 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<104 + 1024 * 1,true> { int V __attribute__ ((bitwidth(104 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<104 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(104 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<105 + 1024 * 1,true> { int V __attribute__ ((bitwidth(105 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<105 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(105 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<106 + 1024 * 1,true> { int V __attribute__ ((bitwidth(106 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<106 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(106 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<107 + 1024 * 1,true> { int V __attribute__ ((bitwidth(107 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<107 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(107 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<108 + 1024 * 1,true> { int V __attribute__ ((bitwidth(108 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<108 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(108 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<109 + 1024 * 1,true> { int V __attribute__ ((bitwidth(109 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<109 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(109 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<110 + 1024 * 1,true> { int V __attribute__ ((bitwidth(110 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<110 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(110 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<111 + 1024 * 1,true> { int V __attribute__ ((bitwidth(111 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<111 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(111 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<112 + 1024 * 1,true> { int V __attribute__ ((bitwidth(112 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<112 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(112 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<113 + 1024 * 1,true> { int V __attribute__ ((bitwidth(113 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<113 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(113 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<114 + 1024 * 1,true> { int V __attribute__ ((bitwidth(114 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<114 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(114 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<115 + 1024 * 1,true> { int V __attribute__ ((bitwidth(115 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<115 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(115 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<116 + 1024 * 1,true> { int V __attribute__ ((bitwidth(116 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<116 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(116 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<117 + 1024 * 1,true> { int V __attribute__ ((bitwidth(117 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<117 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(117 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<118 + 1024 * 1,true> { int V __attribute__ ((bitwidth(118 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<118 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(118 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<119 + 1024 * 1,true> { int V __attribute__ ((bitwidth(119 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<119 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(119 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<120 + 1024 * 1,true> { int V __attribute__ ((bitwidth(120 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<120 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(120 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<121 + 1024 * 1,true> { int V __attribute__ ((bitwidth(121 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<121 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(121 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<122 + 1024 * 1,true> { int V __attribute__ ((bitwidth(122 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<122 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(122 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<123 + 1024 * 1,true> { int V __attribute__ ((bitwidth(123 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<123 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(123 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<124 + 1024 * 1,true> { int V __attribute__ ((bitwidth(124 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<124 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(124 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<125 + 1024 * 1,true> { int V __attribute__ ((bitwidth(125 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<125 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(125 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<126 + 1024 * 1,true> { int V __attribute__ ((bitwidth(126 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<126 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(126 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<127 + 1024 * 1,true> { int V __attribute__ ((bitwidth(127 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<127 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(127 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<128 + 1024 * 1,true> { int V __attribute__ ((bitwidth(128 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<128 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(128 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 1 , false>() { }; };
#pragma empty_line
/*#endif*/
#pragma empty_line
#pragma empty_line
/*#ifdef EXTENDED_GCC*/
#pragma empty_line
template<> struct ssdm_int<129 + 1024 * 1,true> { int V __attribute__ ((bitwidth(129 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<129 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(129 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<130 + 1024 * 1,true> { int V __attribute__ ((bitwidth(130 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<130 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(130 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<131 + 1024 * 1,true> { int V __attribute__ ((bitwidth(131 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<131 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(131 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<132 + 1024 * 1,true> { int V __attribute__ ((bitwidth(132 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<132 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(132 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<133 + 1024 * 1,true> { int V __attribute__ ((bitwidth(133 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<133 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(133 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<134 + 1024 * 1,true> { int V __attribute__ ((bitwidth(134 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<134 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(134 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<135 + 1024 * 1,true> { int V __attribute__ ((bitwidth(135 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<135 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(135 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<136 + 1024 * 1,true> { int V __attribute__ ((bitwidth(136 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<136 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(136 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<137 + 1024 * 1,true> { int V __attribute__ ((bitwidth(137 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<137 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(137 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<138 + 1024 * 1,true> { int V __attribute__ ((bitwidth(138 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<138 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(138 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<139 + 1024 * 1,true> { int V __attribute__ ((bitwidth(139 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<139 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(139 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<140 + 1024 * 1,true> { int V __attribute__ ((bitwidth(140 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<140 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(140 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<141 + 1024 * 1,true> { int V __attribute__ ((bitwidth(141 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<141 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(141 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<142 + 1024 * 1,true> { int V __attribute__ ((bitwidth(142 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<142 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(142 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<143 + 1024 * 1,true> { int V __attribute__ ((bitwidth(143 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<143 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(143 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<144 + 1024 * 1,true> { int V __attribute__ ((bitwidth(144 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<144 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(144 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<145 + 1024 * 1,true> { int V __attribute__ ((bitwidth(145 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<145 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(145 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<146 + 1024 * 1,true> { int V __attribute__ ((bitwidth(146 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<146 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(146 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<147 + 1024 * 1,true> { int V __attribute__ ((bitwidth(147 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<147 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(147 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<148 + 1024 * 1,true> { int V __attribute__ ((bitwidth(148 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<148 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(148 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<149 + 1024 * 1,true> { int V __attribute__ ((bitwidth(149 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<149 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(149 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<150 + 1024 * 1,true> { int V __attribute__ ((bitwidth(150 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<150 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(150 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<151 + 1024 * 1,true> { int V __attribute__ ((bitwidth(151 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<151 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(151 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<152 + 1024 * 1,true> { int V __attribute__ ((bitwidth(152 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<152 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(152 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<153 + 1024 * 1,true> { int V __attribute__ ((bitwidth(153 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<153 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(153 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<154 + 1024 * 1,true> { int V __attribute__ ((bitwidth(154 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<154 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(154 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<155 + 1024 * 1,true> { int V __attribute__ ((bitwidth(155 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<155 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(155 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<156 + 1024 * 1,true> { int V __attribute__ ((bitwidth(156 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<156 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(156 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<157 + 1024 * 1,true> { int V __attribute__ ((bitwidth(157 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<157 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(157 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<158 + 1024 * 1,true> { int V __attribute__ ((bitwidth(158 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<158 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(158 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<159 + 1024 * 1,true> { int V __attribute__ ((bitwidth(159 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<159 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(159 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<160 + 1024 * 1,true> { int V __attribute__ ((bitwidth(160 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<160 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(160 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<161 + 1024 * 1,true> { int V __attribute__ ((bitwidth(161 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<161 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(161 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<162 + 1024 * 1,true> { int V __attribute__ ((bitwidth(162 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<162 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(162 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<163 + 1024 * 1,true> { int V __attribute__ ((bitwidth(163 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<163 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(163 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<164 + 1024 * 1,true> { int V __attribute__ ((bitwidth(164 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<164 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(164 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<165 + 1024 * 1,true> { int V __attribute__ ((bitwidth(165 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<165 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(165 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<166 + 1024 * 1,true> { int V __attribute__ ((bitwidth(166 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<166 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(166 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<167 + 1024 * 1,true> { int V __attribute__ ((bitwidth(167 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<167 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(167 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<168 + 1024 * 1,true> { int V __attribute__ ((bitwidth(168 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<168 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(168 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<169 + 1024 * 1,true> { int V __attribute__ ((bitwidth(169 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<169 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(169 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<170 + 1024 * 1,true> { int V __attribute__ ((bitwidth(170 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<170 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(170 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<171 + 1024 * 1,true> { int V __attribute__ ((bitwidth(171 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<171 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(171 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<172 + 1024 * 1,true> { int V __attribute__ ((bitwidth(172 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<172 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(172 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<173 + 1024 * 1,true> { int V __attribute__ ((bitwidth(173 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<173 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(173 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<174 + 1024 * 1,true> { int V __attribute__ ((bitwidth(174 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<174 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(174 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<175 + 1024 * 1,true> { int V __attribute__ ((bitwidth(175 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<175 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(175 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<176 + 1024 * 1,true> { int V __attribute__ ((bitwidth(176 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<176 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(176 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<177 + 1024 * 1,true> { int V __attribute__ ((bitwidth(177 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<177 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(177 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<178 + 1024 * 1,true> { int V __attribute__ ((bitwidth(178 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<178 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(178 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<179 + 1024 * 1,true> { int V __attribute__ ((bitwidth(179 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<179 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(179 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<180 + 1024 * 1,true> { int V __attribute__ ((bitwidth(180 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<180 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(180 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<181 + 1024 * 1,true> { int V __attribute__ ((bitwidth(181 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<181 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(181 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<182 + 1024 * 1,true> { int V __attribute__ ((bitwidth(182 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<182 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(182 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<183 + 1024 * 1,true> { int V __attribute__ ((bitwidth(183 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<183 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(183 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<184 + 1024 * 1,true> { int V __attribute__ ((bitwidth(184 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<184 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(184 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<185 + 1024 * 1,true> { int V __attribute__ ((bitwidth(185 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<185 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(185 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<186 + 1024 * 1,true> { int V __attribute__ ((bitwidth(186 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<186 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(186 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<187 + 1024 * 1,true> { int V __attribute__ ((bitwidth(187 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<187 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(187 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<188 + 1024 * 1,true> { int V __attribute__ ((bitwidth(188 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<188 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(188 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<189 + 1024 * 1,true> { int V __attribute__ ((bitwidth(189 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<189 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(189 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<190 + 1024 * 1,true> { int V __attribute__ ((bitwidth(190 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<190 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(190 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<191 + 1024 * 1,true> { int V __attribute__ ((bitwidth(191 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<191 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(191 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<192 + 1024 * 1,true> { int V __attribute__ ((bitwidth(192 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<192 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(192 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<193 + 1024 * 1,true> { int V __attribute__ ((bitwidth(193 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<193 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(193 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<194 + 1024 * 1,true> { int V __attribute__ ((bitwidth(194 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<194 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(194 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<195 + 1024 * 1,true> { int V __attribute__ ((bitwidth(195 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<195 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(195 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<196 + 1024 * 1,true> { int V __attribute__ ((bitwidth(196 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<196 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(196 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<197 + 1024 * 1,true> { int V __attribute__ ((bitwidth(197 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<197 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(197 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<198 + 1024 * 1,true> { int V __attribute__ ((bitwidth(198 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<198 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(198 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<199 + 1024 * 1,true> { int V __attribute__ ((bitwidth(199 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<199 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(199 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<200 + 1024 * 1,true> { int V __attribute__ ((bitwidth(200 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<200 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(200 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<201 + 1024 * 1,true> { int V __attribute__ ((bitwidth(201 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<201 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(201 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<202 + 1024 * 1,true> { int V __attribute__ ((bitwidth(202 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<202 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(202 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<203 + 1024 * 1,true> { int V __attribute__ ((bitwidth(203 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<203 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(203 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<204 + 1024 * 1,true> { int V __attribute__ ((bitwidth(204 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<204 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(204 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<205 + 1024 * 1,true> { int V __attribute__ ((bitwidth(205 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<205 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(205 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<206 + 1024 * 1,true> { int V __attribute__ ((bitwidth(206 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<206 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(206 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<207 + 1024 * 1,true> { int V __attribute__ ((bitwidth(207 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<207 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(207 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<208 + 1024 * 1,true> { int V __attribute__ ((bitwidth(208 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<208 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(208 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<209 + 1024 * 1,true> { int V __attribute__ ((bitwidth(209 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<209 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(209 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<210 + 1024 * 1,true> { int V __attribute__ ((bitwidth(210 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<210 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(210 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<211 + 1024 * 1,true> { int V __attribute__ ((bitwidth(211 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<211 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(211 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<212 + 1024 * 1,true> { int V __attribute__ ((bitwidth(212 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<212 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(212 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<213 + 1024 * 1,true> { int V __attribute__ ((bitwidth(213 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<213 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(213 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<214 + 1024 * 1,true> { int V __attribute__ ((bitwidth(214 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<214 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(214 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<215 + 1024 * 1,true> { int V __attribute__ ((bitwidth(215 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<215 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(215 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<216 + 1024 * 1,true> { int V __attribute__ ((bitwidth(216 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<216 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(216 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<217 + 1024 * 1,true> { int V __attribute__ ((bitwidth(217 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<217 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(217 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<218 + 1024 * 1,true> { int V __attribute__ ((bitwidth(218 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<218 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(218 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<219 + 1024 * 1,true> { int V __attribute__ ((bitwidth(219 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<219 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(219 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<220 + 1024 * 1,true> { int V __attribute__ ((bitwidth(220 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<220 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(220 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<221 + 1024 * 1,true> { int V __attribute__ ((bitwidth(221 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<221 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(221 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<222 + 1024 * 1,true> { int V __attribute__ ((bitwidth(222 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<222 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(222 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<223 + 1024 * 1,true> { int V __attribute__ ((bitwidth(223 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<223 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(223 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<224 + 1024 * 1,true> { int V __attribute__ ((bitwidth(224 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<224 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(224 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<225 + 1024 * 1,true> { int V __attribute__ ((bitwidth(225 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<225 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(225 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<226 + 1024 * 1,true> { int V __attribute__ ((bitwidth(226 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<226 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(226 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<227 + 1024 * 1,true> { int V __attribute__ ((bitwidth(227 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<227 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(227 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<228 + 1024 * 1,true> { int V __attribute__ ((bitwidth(228 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<228 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(228 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<229 + 1024 * 1,true> { int V __attribute__ ((bitwidth(229 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<229 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(229 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<230 + 1024 * 1,true> { int V __attribute__ ((bitwidth(230 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<230 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(230 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<231 + 1024 * 1,true> { int V __attribute__ ((bitwidth(231 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<231 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(231 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<232 + 1024 * 1,true> { int V __attribute__ ((bitwidth(232 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<232 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(232 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<233 + 1024 * 1,true> { int V __attribute__ ((bitwidth(233 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<233 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(233 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<234 + 1024 * 1,true> { int V __attribute__ ((bitwidth(234 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<234 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(234 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<235 + 1024 * 1,true> { int V __attribute__ ((bitwidth(235 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<235 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(235 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<236 + 1024 * 1,true> { int V __attribute__ ((bitwidth(236 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<236 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(236 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<237 + 1024 * 1,true> { int V __attribute__ ((bitwidth(237 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<237 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(237 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<238 + 1024 * 1,true> { int V __attribute__ ((bitwidth(238 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<238 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(238 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<239 + 1024 * 1,true> { int V __attribute__ ((bitwidth(239 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<239 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(239 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<240 + 1024 * 1,true> { int V __attribute__ ((bitwidth(240 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<240 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(240 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<241 + 1024 * 1,true> { int V __attribute__ ((bitwidth(241 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<241 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(241 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<242 + 1024 * 1,true> { int V __attribute__ ((bitwidth(242 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<242 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(242 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<243 + 1024 * 1,true> { int V __attribute__ ((bitwidth(243 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<243 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(243 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<244 + 1024 * 1,true> { int V __attribute__ ((bitwidth(244 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<244 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(244 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<245 + 1024 * 1,true> { int V __attribute__ ((bitwidth(245 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<245 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(245 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<246 + 1024 * 1,true> { int V __attribute__ ((bitwidth(246 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<246 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(246 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<247 + 1024 * 1,true> { int V __attribute__ ((bitwidth(247 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<247 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(247 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<248 + 1024 * 1,true> { int V __attribute__ ((bitwidth(248 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<248 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(248 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<249 + 1024 * 1,true> { int V __attribute__ ((bitwidth(249 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<249 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(249 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<250 + 1024 * 1,true> { int V __attribute__ ((bitwidth(250 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<250 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(250 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<251 + 1024 * 1,true> { int V __attribute__ ((bitwidth(251 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<251 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(251 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<252 + 1024 * 1,true> { int V __attribute__ ((bitwidth(252 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<252 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(252 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<253 + 1024 * 1,true> { int V __attribute__ ((bitwidth(253 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<253 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(253 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<254 + 1024 * 1,true> { int V __attribute__ ((bitwidth(254 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<254 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(254 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<255 + 1024 * 1,true> { int V __attribute__ ((bitwidth(255 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<255 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(255 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<256 + 1024 * 1,true> { int V __attribute__ ((bitwidth(256 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<256 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(256 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<257 + 1024 * 1,true> { int V __attribute__ ((bitwidth(257 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<257 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(257 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<258 + 1024 * 1,true> { int V __attribute__ ((bitwidth(258 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<258 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(258 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<259 + 1024 * 1,true> { int V __attribute__ ((bitwidth(259 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<259 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(259 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<260 + 1024 * 1,true> { int V __attribute__ ((bitwidth(260 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<260 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(260 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<261 + 1024 * 1,true> { int V __attribute__ ((bitwidth(261 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<261 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(261 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<262 + 1024 * 1,true> { int V __attribute__ ((bitwidth(262 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<262 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(262 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<263 + 1024 * 1,true> { int V __attribute__ ((bitwidth(263 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<263 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(263 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<264 + 1024 * 1,true> { int V __attribute__ ((bitwidth(264 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<264 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(264 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<265 + 1024 * 1,true> { int V __attribute__ ((bitwidth(265 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<265 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(265 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<266 + 1024 * 1,true> { int V __attribute__ ((bitwidth(266 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<266 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(266 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<267 + 1024 * 1,true> { int V __attribute__ ((bitwidth(267 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<267 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(267 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<268 + 1024 * 1,true> { int V __attribute__ ((bitwidth(268 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<268 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(268 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<269 + 1024 * 1,true> { int V __attribute__ ((bitwidth(269 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<269 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(269 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<270 + 1024 * 1,true> { int V __attribute__ ((bitwidth(270 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<270 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(270 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<271 + 1024 * 1,true> { int V __attribute__ ((bitwidth(271 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<271 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(271 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<272 + 1024 * 1,true> { int V __attribute__ ((bitwidth(272 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<272 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(272 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<273 + 1024 * 1,true> { int V __attribute__ ((bitwidth(273 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<273 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(273 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<274 + 1024 * 1,true> { int V __attribute__ ((bitwidth(274 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<274 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(274 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<275 + 1024 * 1,true> { int V __attribute__ ((bitwidth(275 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<275 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(275 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<276 + 1024 * 1,true> { int V __attribute__ ((bitwidth(276 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<276 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(276 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<277 + 1024 * 1,true> { int V __attribute__ ((bitwidth(277 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<277 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(277 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<278 + 1024 * 1,true> { int V __attribute__ ((bitwidth(278 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<278 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(278 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<279 + 1024 * 1,true> { int V __attribute__ ((bitwidth(279 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<279 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(279 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<280 + 1024 * 1,true> { int V __attribute__ ((bitwidth(280 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<280 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(280 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<281 + 1024 * 1,true> { int V __attribute__ ((bitwidth(281 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<281 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(281 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<282 + 1024 * 1,true> { int V __attribute__ ((bitwidth(282 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<282 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(282 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<283 + 1024 * 1,true> { int V __attribute__ ((bitwidth(283 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<283 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(283 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<284 + 1024 * 1,true> { int V __attribute__ ((bitwidth(284 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<284 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(284 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<285 + 1024 * 1,true> { int V __attribute__ ((bitwidth(285 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<285 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(285 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<286 + 1024 * 1,true> { int V __attribute__ ((bitwidth(286 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<286 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(286 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<287 + 1024 * 1,true> { int V __attribute__ ((bitwidth(287 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<287 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(287 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<288 + 1024 * 1,true> { int V __attribute__ ((bitwidth(288 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<288 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(288 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<289 + 1024 * 1,true> { int V __attribute__ ((bitwidth(289 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<289 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(289 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<290 + 1024 * 1,true> { int V __attribute__ ((bitwidth(290 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<290 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(290 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<291 + 1024 * 1,true> { int V __attribute__ ((bitwidth(291 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<291 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(291 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<292 + 1024 * 1,true> { int V __attribute__ ((bitwidth(292 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<292 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(292 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<293 + 1024 * 1,true> { int V __attribute__ ((bitwidth(293 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<293 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(293 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<294 + 1024 * 1,true> { int V __attribute__ ((bitwidth(294 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<294 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(294 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<295 + 1024 * 1,true> { int V __attribute__ ((bitwidth(295 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<295 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(295 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<296 + 1024 * 1,true> { int V __attribute__ ((bitwidth(296 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<296 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(296 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<297 + 1024 * 1,true> { int V __attribute__ ((bitwidth(297 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<297 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(297 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<298 + 1024 * 1,true> { int V __attribute__ ((bitwidth(298 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<298 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(298 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<299 + 1024 * 1,true> { int V __attribute__ ((bitwidth(299 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<299 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(299 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<300 + 1024 * 1,true> { int V __attribute__ ((bitwidth(300 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<300 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(300 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<301 + 1024 * 1,true> { int V __attribute__ ((bitwidth(301 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<301 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(301 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<302 + 1024 * 1,true> { int V __attribute__ ((bitwidth(302 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<302 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(302 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<303 + 1024 * 1,true> { int V __attribute__ ((bitwidth(303 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<303 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(303 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<304 + 1024 * 1,true> { int V __attribute__ ((bitwidth(304 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<304 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(304 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<305 + 1024 * 1,true> { int V __attribute__ ((bitwidth(305 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<305 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(305 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<306 + 1024 * 1,true> { int V __attribute__ ((bitwidth(306 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<306 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(306 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<307 + 1024 * 1,true> { int V __attribute__ ((bitwidth(307 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<307 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(307 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<308 + 1024 * 1,true> { int V __attribute__ ((bitwidth(308 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<308 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(308 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<309 + 1024 * 1,true> { int V __attribute__ ((bitwidth(309 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<309 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(309 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<310 + 1024 * 1,true> { int V __attribute__ ((bitwidth(310 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<310 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(310 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<311 + 1024 * 1,true> { int V __attribute__ ((bitwidth(311 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<311 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(311 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<312 + 1024 * 1,true> { int V __attribute__ ((bitwidth(312 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<312 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(312 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<313 + 1024 * 1,true> { int V __attribute__ ((bitwidth(313 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<313 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(313 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<314 + 1024 * 1,true> { int V __attribute__ ((bitwidth(314 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<314 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(314 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<315 + 1024 * 1,true> { int V __attribute__ ((bitwidth(315 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<315 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(315 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<316 + 1024 * 1,true> { int V __attribute__ ((bitwidth(316 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<316 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(316 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<317 + 1024 * 1,true> { int V __attribute__ ((bitwidth(317 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<317 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(317 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<318 + 1024 * 1,true> { int V __attribute__ ((bitwidth(318 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<318 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(318 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<319 + 1024 * 1,true> { int V __attribute__ ((bitwidth(319 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<319 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(319 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<320 + 1024 * 1,true> { int V __attribute__ ((bitwidth(320 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<320 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(320 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<321 + 1024 * 1,true> { int V __attribute__ ((bitwidth(321 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<321 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(321 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<322 + 1024 * 1,true> { int V __attribute__ ((bitwidth(322 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<322 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(322 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<323 + 1024 * 1,true> { int V __attribute__ ((bitwidth(323 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<323 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(323 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<324 + 1024 * 1,true> { int V __attribute__ ((bitwidth(324 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<324 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(324 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<325 + 1024 * 1,true> { int V __attribute__ ((bitwidth(325 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<325 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(325 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<326 + 1024 * 1,true> { int V __attribute__ ((bitwidth(326 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<326 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(326 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<327 + 1024 * 1,true> { int V __attribute__ ((bitwidth(327 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<327 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(327 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<328 + 1024 * 1,true> { int V __attribute__ ((bitwidth(328 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<328 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(328 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<329 + 1024 * 1,true> { int V __attribute__ ((bitwidth(329 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<329 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(329 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<330 + 1024 * 1,true> { int V __attribute__ ((bitwidth(330 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<330 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(330 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<331 + 1024 * 1,true> { int V __attribute__ ((bitwidth(331 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<331 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(331 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<332 + 1024 * 1,true> { int V __attribute__ ((bitwidth(332 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<332 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(332 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<333 + 1024 * 1,true> { int V __attribute__ ((bitwidth(333 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<333 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(333 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<334 + 1024 * 1,true> { int V __attribute__ ((bitwidth(334 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<334 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(334 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<335 + 1024 * 1,true> { int V __attribute__ ((bitwidth(335 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<335 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(335 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<336 + 1024 * 1,true> { int V __attribute__ ((bitwidth(336 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<336 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(336 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<337 + 1024 * 1,true> { int V __attribute__ ((bitwidth(337 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<337 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(337 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<338 + 1024 * 1,true> { int V __attribute__ ((bitwidth(338 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<338 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(338 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<339 + 1024 * 1,true> { int V __attribute__ ((bitwidth(339 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<339 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(339 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<340 + 1024 * 1,true> { int V __attribute__ ((bitwidth(340 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<340 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(340 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<341 + 1024 * 1,true> { int V __attribute__ ((bitwidth(341 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<341 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(341 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<342 + 1024 * 1,true> { int V __attribute__ ((bitwidth(342 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<342 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(342 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<343 + 1024 * 1,true> { int V __attribute__ ((bitwidth(343 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<343 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(343 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<344 + 1024 * 1,true> { int V __attribute__ ((bitwidth(344 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<344 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(344 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<345 + 1024 * 1,true> { int V __attribute__ ((bitwidth(345 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<345 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(345 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<346 + 1024 * 1,true> { int V __attribute__ ((bitwidth(346 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<346 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(346 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<347 + 1024 * 1,true> { int V __attribute__ ((bitwidth(347 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<347 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(347 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<348 + 1024 * 1,true> { int V __attribute__ ((bitwidth(348 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<348 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(348 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<349 + 1024 * 1,true> { int V __attribute__ ((bitwidth(349 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<349 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(349 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<350 + 1024 * 1,true> { int V __attribute__ ((bitwidth(350 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<350 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(350 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<351 + 1024 * 1,true> { int V __attribute__ ((bitwidth(351 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<351 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(351 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<352 + 1024 * 1,true> { int V __attribute__ ((bitwidth(352 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<352 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(352 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<353 + 1024 * 1,true> { int V __attribute__ ((bitwidth(353 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<353 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(353 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<354 + 1024 * 1,true> { int V __attribute__ ((bitwidth(354 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<354 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(354 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<355 + 1024 * 1,true> { int V __attribute__ ((bitwidth(355 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<355 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(355 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<356 + 1024 * 1,true> { int V __attribute__ ((bitwidth(356 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<356 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(356 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<357 + 1024 * 1,true> { int V __attribute__ ((bitwidth(357 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<357 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(357 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<358 + 1024 * 1,true> { int V __attribute__ ((bitwidth(358 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<358 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(358 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<359 + 1024 * 1,true> { int V __attribute__ ((bitwidth(359 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<359 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(359 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<360 + 1024 * 1,true> { int V __attribute__ ((bitwidth(360 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<360 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(360 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<361 + 1024 * 1,true> { int V __attribute__ ((bitwidth(361 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<361 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(361 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<362 + 1024 * 1,true> { int V __attribute__ ((bitwidth(362 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<362 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(362 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<363 + 1024 * 1,true> { int V __attribute__ ((bitwidth(363 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<363 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(363 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<364 + 1024 * 1,true> { int V __attribute__ ((bitwidth(364 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<364 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(364 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<365 + 1024 * 1,true> { int V __attribute__ ((bitwidth(365 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<365 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(365 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<366 + 1024 * 1,true> { int V __attribute__ ((bitwidth(366 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<366 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(366 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<367 + 1024 * 1,true> { int V __attribute__ ((bitwidth(367 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<367 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(367 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<368 + 1024 * 1,true> { int V __attribute__ ((bitwidth(368 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<368 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(368 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<369 + 1024 * 1,true> { int V __attribute__ ((bitwidth(369 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<369 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(369 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<370 + 1024 * 1,true> { int V __attribute__ ((bitwidth(370 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<370 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(370 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<371 + 1024 * 1,true> { int V __attribute__ ((bitwidth(371 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<371 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(371 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<372 + 1024 * 1,true> { int V __attribute__ ((bitwidth(372 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<372 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(372 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<373 + 1024 * 1,true> { int V __attribute__ ((bitwidth(373 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<373 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(373 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<374 + 1024 * 1,true> { int V __attribute__ ((bitwidth(374 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<374 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(374 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<375 + 1024 * 1,true> { int V __attribute__ ((bitwidth(375 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<375 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(375 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<376 + 1024 * 1,true> { int V __attribute__ ((bitwidth(376 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<376 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(376 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<377 + 1024 * 1,true> { int V __attribute__ ((bitwidth(377 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<377 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(377 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<378 + 1024 * 1,true> { int V __attribute__ ((bitwidth(378 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<378 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(378 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<379 + 1024 * 1,true> { int V __attribute__ ((bitwidth(379 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<379 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(379 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<380 + 1024 * 1,true> { int V __attribute__ ((bitwidth(380 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<380 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(380 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<381 + 1024 * 1,true> { int V __attribute__ ((bitwidth(381 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<381 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(381 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<382 + 1024 * 1,true> { int V __attribute__ ((bitwidth(382 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<382 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(382 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<383 + 1024 * 1,true> { int V __attribute__ ((bitwidth(383 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<383 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(383 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<384 + 1024 * 1,true> { int V __attribute__ ((bitwidth(384 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<384 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(384 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<385 + 1024 * 1,true> { int V __attribute__ ((bitwidth(385 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<385 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(385 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<386 + 1024 * 1,true> { int V __attribute__ ((bitwidth(386 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<386 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(386 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<387 + 1024 * 1,true> { int V __attribute__ ((bitwidth(387 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<387 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(387 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<388 + 1024 * 1,true> { int V __attribute__ ((bitwidth(388 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<388 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(388 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<389 + 1024 * 1,true> { int V __attribute__ ((bitwidth(389 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<389 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(389 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<390 + 1024 * 1,true> { int V __attribute__ ((bitwidth(390 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<390 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(390 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<391 + 1024 * 1,true> { int V __attribute__ ((bitwidth(391 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<391 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(391 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<392 + 1024 * 1,true> { int V __attribute__ ((bitwidth(392 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<392 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(392 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<393 + 1024 * 1,true> { int V __attribute__ ((bitwidth(393 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<393 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(393 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<394 + 1024 * 1,true> { int V __attribute__ ((bitwidth(394 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<394 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(394 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<395 + 1024 * 1,true> { int V __attribute__ ((bitwidth(395 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<395 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(395 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<396 + 1024 * 1,true> { int V __attribute__ ((bitwidth(396 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<396 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(396 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<397 + 1024 * 1,true> { int V __attribute__ ((bitwidth(397 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<397 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(397 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<398 + 1024 * 1,true> { int V __attribute__ ((bitwidth(398 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<398 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(398 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<399 + 1024 * 1,true> { int V __attribute__ ((bitwidth(399 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<399 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(399 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<400 + 1024 * 1,true> { int V __attribute__ ((bitwidth(400 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<400 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(400 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<401 + 1024 * 1,true> { int V __attribute__ ((bitwidth(401 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<401 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(401 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<402 + 1024 * 1,true> { int V __attribute__ ((bitwidth(402 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<402 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(402 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<403 + 1024 * 1,true> { int V __attribute__ ((bitwidth(403 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<403 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(403 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<404 + 1024 * 1,true> { int V __attribute__ ((bitwidth(404 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<404 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(404 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<405 + 1024 * 1,true> { int V __attribute__ ((bitwidth(405 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<405 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(405 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<406 + 1024 * 1,true> { int V __attribute__ ((bitwidth(406 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<406 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(406 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<407 + 1024 * 1,true> { int V __attribute__ ((bitwidth(407 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<407 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(407 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<408 + 1024 * 1,true> { int V __attribute__ ((bitwidth(408 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<408 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(408 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<409 + 1024 * 1,true> { int V __attribute__ ((bitwidth(409 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<409 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(409 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<410 + 1024 * 1,true> { int V __attribute__ ((bitwidth(410 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<410 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(410 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<411 + 1024 * 1,true> { int V __attribute__ ((bitwidth(411 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<411 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(411 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<412 + 1024 * 1,true> { int V __attribute__ ((bitwidth(412 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<412 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(412 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<413 + 1024 * 1,true> { int V __attribute__ ((bitwidth(413 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<413 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(413 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<414 + 1024 * 1,true> { int V __attribute__ ((bitwidth(414 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<414 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(414 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<415 + 1024 * 1,true> { int V __attribute__ ((bitwidth(415 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<415 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(415 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<416 + 1024 * 1,true> { int V __attribute__ ((bitwidth(416 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<416 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(416 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<417 + 1024 * 1,true> { int V __attribute__ ((bitwidth(417 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<417 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(417 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<418 + 1024 * 1,true> { int V __attribute__ ((bitwidth(418 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<418 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(418 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<419 + 1024 * 1,true> { int V __attribute__ ((bitwidth(419 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<419 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(419 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<420 + 1024 * 1,true> { int V __attribute__ ((bitwidth(420 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<420 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(420 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<421 + 1024 * 1,true> { int V __attribute__ ((bitwidth(421 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<421 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(421 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<422 + 1024 * 1,true> { int V __attribute__ ((bitwidth(422 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<422 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(422 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<423 + 1024 * 1,true> { int V __attribute__ ((bitwidth(423 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<423 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(423 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<424 + 1024 * 1,true> { int V __attribute__ ((bitwidth(424 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<424 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(424 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<425 + 1024 * 1,true> { int V __attribute__ ((bitwidth(425 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<425 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(425 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<426 + 1024 * 1,true> { int V __attribute__ ((bitwidth(426 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<426 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(426 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<427 + 1024 * 1,true> { int V __attribute__ ((bitwidth(427 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<427 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(427 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<428 + 1024 * 1,true> { int V __attribute__ ((bitwidth(428 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<428 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(428 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<429 + 1024 * 1,true> { int V __attribute__ ((bitwidth(429 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<429 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(429 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<430 + 1024 * 1,true> { int V __attribute__ ((bitwidth(430 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<430 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(430 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<431 + 1024 * 1,true> { int V __attribute__ ((bitwidth(431 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<431 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(431 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<432 + 1024 * 1,true> { int V __attribute__ ((bitwidth(432 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<432 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(432 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<433 + 1024 * 1,true> { int V __attribute__ ((bitwidth(433 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<433 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(433 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<434 + 1024 * 1,true> { int V __attribute__ ((bitwidth(434 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<434 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(434 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<435 + 1024 * 1,true> { int V __attribute__ ((bitwidth(435 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<435 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(435 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<436 + 1024 * 1,true> { int V __attribute__ ((bitwidth(436 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<436 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(436 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<437 + 1024 * 1,true> { int V __attribute__ ((bitwidth(437 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<437 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(437 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<438 + 1024 * 1,true> { int V __attribute__ ((bitwidth(438 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<438 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(438 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<439 + 1024 * 1,true> { int V __attribute__ ((bitwidth(439 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<439 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(439 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<440 + 1024 * 1,true> { int V __attribute__ ((bitwidth(440 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<440 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(440 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<441 + 1024 * 1,true> { int V __attribute__ ((bitwidth(441 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<441 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(441 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<442 + 1024 * 1,true> { int V __attribute__ ((bitwidth(442 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<442 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(442 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<443 + 1024 * 1,true> { int V __attribute__ ((bitwidth(443 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<443 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(443 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<444 + 1024 * 1,true> { int V __attribute__ ((bitwidth(444 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<444 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(444 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<445 + 1024 * 1,true> { int V __attribute__ ((bitwidth(445 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<445 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(445 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<446 + 1024 * 1,true> { int V __attribute__ ((bitwidth(446 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<446 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(446 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<447 + 1024 * 1,true> { int V __attribute__ ((bitwidth(447 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<447 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(447 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<448 + 1024 * 1,true> { int V __attribute__ ((bitwidth(448 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<448 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(448 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<449 + 1024 * 1,true> { int V __attribute__ ((bitwidth(449 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<449 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(449 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<450 + 1024 * 1,true> { int V __attribute__ ((bitwidth(450 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<450 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(450 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<451 + 1024 * 1,true> { int V __attribute__ ((bitwidth(451 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<451 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(451 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<452 + 1024 * 1,true> { int V __attribute__ ((bitwidth(452 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<452 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(452 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<453 + 1024 * 1,true> { int V __attribute__ ((bitwidth(453 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<453 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(453 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<454 + 1024 * 1,true> { int V __attribute__ ((bitwidth(454 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<454 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(454 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<455 + 1024 * 1,true> { int V __attribute__ ((bitwidth(455 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<455 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(455 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<456 + 1024 * 1,true> { int V __attribute__ ((bitwidth(456 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<456 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(456 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<457 + 1024 * 1,true> { int V __attribute__ ((bitwidth(457 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<457 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(457 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<458 + 1024 * 1,true> { int V __attribute__ ((bitwidth(458 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<458 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(458 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<459 + 1024 * 1,true> { int V __attribute__ ((bitwidth(459 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<459 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(459 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<460 + 1024 * 1,true> { int V __attribute__ ((bitwidth(460 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<460 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(460 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<461 + 1024 * 1,true> { int V __attribute__ ((bitwidth(461 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<461 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(461 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<462 + 1024 * 1,true> { int V __attribute__ ((bitwidth(462 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<462 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(462 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<463 + 1024 * 1,true> { int V __attribute__ ((bitwidth(463 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<463 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(463 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<464 + 1024 * 1,true> { int V __attribute__ ((bitwidth(464 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<464 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(464 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<465 + 1024 * 1,true> { int V __attribute__ ((bitwidth(465 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<465 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(465 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<466 + 1024 * 1,true> { int V __attribute__ ((bitwidth(466 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<466 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(466 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<467 + 1024 * 1,true> { int V __attribute__ ((bitwidth(467 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<467 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(467 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<468 + 1024 * 1,true> { int V __attribute__ ((bitwidth(468 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<468 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(468 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<469 + 1024 * 1,true> { int V __attribute__ ((bitwidth(469 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<469 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(469 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<470 + 1024 * 1,true> { int V __attribute__ ((bitwidth(470 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<470 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(470 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<471 + 1024 * 1,true> { int V __attribute__ ((bitwidth(471 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<471 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(471 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<472 + 1024 * 1,true> { int V __attribute__ ((bitwidth(472 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<472 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(472 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<473 + 1024 * 1,true> { int V __attribute__ ((bitwidth(473 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<473 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(473 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<474 + 1024 * 1,true> { int V __attribute__ ((bitwidth(474 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<474 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(474 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<475 + 1024 * 1,true> { int V __attribute__ ((bitwidth(475 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<475 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(475 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<476 + 1024 * 1,true> { int V __attribute__ ((bitwidth(476 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<476 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(476 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<477 + 1024 * 1,true> { int V __attribute__ ((bitwidth(477 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<477 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(477 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<478 + 1024 * 1,true> { int V __attribute__ ((bitwidth(478 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<478 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(478 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<479 + 1024 * 1,true> { int V __attribute__ ((bitwidth(479 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<479 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(479 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<480 + 1024 * 1,true> { int V __attribute__ ((bitwidth(480 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<480 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(480 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<481 + 1024 * 1,true> { int V __attribute__ ((bitwidth(481 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<481 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(481 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<482 + 1024 * 1,true> { int V __attribute__ ((bitwidth(482 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<482 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(482 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<483 + 1024 * 1,true> { int V __attribute__ ((bitwidth(483 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<483 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(483 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<484 + 1024 * 1,true> { int V __attribute__ ((bitwidth(484 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<484 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(484 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<485 + 1024 * 1,true> { int V __attribute__ ((bitwidth(485 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<485 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(485 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<486 + 1024 * 1,true> { int V __attribute__ ((bitwidth(486 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<486 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(486 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<487 + 1024 * 1,true> { int V __attribute__ ((bitwidth(487 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<487 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(487 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<488 + 1024 * 1,true> { int V __attribute__ ((bitwidth(488 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<488 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(488 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<489 + 1024 * 1,true> { int V __attribute__ ((bitwidth(489 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<489 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(489 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<490 + 1024 * 1,true> { int V __attribute__ ((bitwidth(490 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<490 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(490 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<491 + 1024 * 1,true> { int V __attribute__ ((bitwidth(491 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<491 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(491 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<492 + 1024 * 1,true> { int V __attribute__ ((bitwidth(492 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<492 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(492 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<493 + 1024 * 1,true> { int V __attribute__ ((bitwidth(493 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<493 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(493 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<494 + 1024 * 1,true> { int V __attribute__ ((bitwidth(494 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<494 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(494 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<495 + 1024 * 1,true> { int V __attribute__ ((bitwidth(495 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<495 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(495 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<496 + 1024 * 1,true> { int V __attribute__ ((bitwidth(496 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<496 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(496 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<497 + 1024 * 1,true> { int V __attribute__ ((bitwidth(497 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<497 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(497 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<498 + 1024 * 1,true> { int V __attribute__ ((bitwidth(498 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<498 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(498 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<499 + 1024 * 1,true> { int V __attribute__ ((bitwidth(499 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<499 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(499 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<500 + 1024 * 1,true> { int V __attribute__ ((bitwidth(500 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<500 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(500 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<501 + 1024 * 1,true> { int V __attribute__ ((bitwidth(501 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<501 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(501 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<502 + 1024 * 1,true> { int V __attribute__ ((bitwidth(502 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<502 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(502 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<503 + 1024 * 1,true> { int V __attribute__ ((bitwidth(503 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<503 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(503 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<504 + 1024 * 1,true> { int V __attribute__ ((bitwidth(504 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<504 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(504 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<505 + 1024 * 1,true> { int V __attribute__ ((bitwidth(505 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<505 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(505 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<506 + 1024 * 1,true> { int V __attribute__ ((bitwidth(506 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<506 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(506 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<507 + 1024 * 1,true> { int V __attribute__ ((bitwidth(507 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<507 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(507 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<508 + 1024 * 1,true> { int V __attribute__ ((bitwidth(508 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<508 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(508 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<509 + 1024 * 1,true> { int V __attribute__ ((bitwidth(509 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<509 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(509 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<510 + 1024 * 1,true> { int V __attribute__ ((bitwidth(510 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<510 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(510 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<511 + 1024 * 1,true> { int V __attribute__ ((bitwidth(511 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<511 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(511 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<512 + 1024 * 1,true> { int V __attribute__ ((bitwidth(512 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<512 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(512 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<513 + 1024 * 1,true> { int V __attribute__ ((bitwidth(513 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<513 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(513 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<514 + 1024 * 1,true> { int V __attribute__ ((bitwidth(514 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<514 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(514 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<515 + 1024 * 1,true> { int V __attribute__ ((bitwidth(515 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<515 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(515 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<516 + 1024 * 1,true> { int V __attribute__ ((bitwidth(516 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<516 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(516 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<517 + 1024 * 1,true> { int V __attribute__ ((bitwidth(517 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<517 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(517 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<518 + 1024 * 1,true> { int V __attribute__ ((bitwidth(518 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<518 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(518 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<519 + 1024 * 1,true> { int V __attribute__ ((bitwidth(519 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<519 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(519 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<520 + 1024 * 1,true> { int V __attribute__ ((bitwidth(520 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<520 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(520 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<521 + 1024 * 1,true> { int V __attribute__ ((bitwidth(521 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<521 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(521 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<522 + 1024 * 1,true> { int V __attribute__ ((bitwidth(522 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<522 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(522 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<523 + 1024 * 1,true> { int V __attribute__ ((bitwidth(523 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<523 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(523 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<524 + 1024 * 1,true> { int V __attribute__ ((bitwidth(524 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<524 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(524 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<525 + 1024 * 1,true> { int V __attribute__ ((bitwidth(525 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<525 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(525 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<526 + 1024 * 1,true> { int V __attribute__ ((bitwidth(526 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<526 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(526 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<527 + 1024 * 1,true> { int V __attribute__ ((bitwidth(527 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<527 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(527 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<528 + 1024 * 1,true> { int V __attribute__ ((bitwidth(528 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<528 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(528 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<529 + 1024 * 1,true> { int V __attribute__ ((bitwidth(529 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<529 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(529 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<530 + 1024 * 1,true> { int V __attribute__ ((bitwidth(530 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<530 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(530 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<531 + 1024 * 1,true> { int V __attribute__ ((bitwidth(531 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<531 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(531 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<532 + 1024 * 1,true> { int V __attribute__ ((bitwidth(532 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<532 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(532 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<533 + 1024 * 1,true> { int V __attribute__ ((bitwidth(533 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<533 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(533 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<534 + 1024 * 1,true> { int V __attribute__ ((bitwidth(534 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<534 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(534 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<535 + 1024 * 1,true> { int V __attribute__ ((bitwidth(535 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<535 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(535 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<536 + 1024 * 1,true> { int V __attribute__ ((bitwidth(536 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<536 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(536 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<537 + 1024 * 1,true> { int V __attribute__ ((bitwidth(537 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<537 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(537 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<538 + 1024 * 1,true> { int V __attribute__ ((bitwidth(538 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<538 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(538 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<539 + 1024 * 1,true> { int V __attribute__ ((bitwidth(539 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<539 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(539 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<540 + 1024 * 1,true> { int V __attribute__ ((bitwidth(540 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<540 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(540 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<541 + 1024 * 1,true> { int V __attribute__ ((bitwidth(541 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<541 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(541 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<542 + 1024 * 1,true> { int V __attribute__ ((bitwidth(542 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<542 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(542 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<543 + 1024 * 1,true> { int V __attribute__ ((bitwidth(543 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<543 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(543 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<544 + 1024 * 1,true> { int V __attribute__ ((bitwidth(544 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<544 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(544 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<545 + 1024 * 1,true> { int V __attribute__ ((bitwidth(545 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<545 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(545 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<546 + 1024 * 1,true> { int V __attribute__ ((bitwidth(546 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<546 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(546 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<547 + 1024 * 1,true> { int V __attribute__ ((bitwidth(547 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<547 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(547 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<548 + 1024 * 1,true> { int V __attribute__ ((bitwidth(548 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<548 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(548 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<549 + 1024 * 1,true> { int V __attribute__ ((bitwidth(549 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<549 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(549 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<550 + 1024 * 1,true> { int V __attribute__ ((bitwidth(550 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<550 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(550 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<551 + 1024 * 1,true> { int V __attribute__ ((bitwidth(551 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<551 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(551 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<552 + 1024 * 1,true> { int V __attribute__ ((bitwidth(552 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<552 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(552 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<553 + 1024 * 1,true> { int V __attribute__ ((bitwidth(553 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<553 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(553 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<554 + 1024 * 1,true> { int V __attribute__ ((bitwidth(554 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<554 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(554 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<555 + 1024 * 1,true> { int V __attribute__ ((bitwidth(555 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<555 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(555 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<556 + 1024 * 1,true> { int V __attribute__ ((bitwidth(556 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<556 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(556 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<557 + 1024 * 1,true> { int V __attribute__ ((bitwidth(557 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<557 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(557 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<558 + 1024 * 1,true> { int V __attribute__ ((bitwidth(558 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<558 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(558 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<559 + 1024 * 1,true> { int V __attribute__ ((bitwidth(559 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<559 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(559 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<560 + 1024 * 1,true> { int V __attribute__ ((bitwidth(560 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<560 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(560 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<561 + 1024 * 1,true> { int V __attribute__ ((bitwidth(561 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<561 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(561 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<562 + 1024 * 1,true> { int V __attribute__ ((bitwidth(562 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<562 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(562 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<563 + 1024 * 1,true> { int V __attribute__ ((bitwidth(563 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<563 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(563 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<564 + 1024 * 1,true> { int V __attribute__ ((bitwidth(564 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<564 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(564 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<565 + 1024 * 1,true> { int V __attribute__ ((bitwidth(565 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<565 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(565 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<566 + 1024 * 1,true> { int V __attribute__ ((bitwidth(566 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<566 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(566 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<567 + 1024 * 1,true> { int V __attribute__ ((bitwidth(567 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<567 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(567 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<568 + 1024 * 1,true> { int V __attribute__ ((bitwidth(568 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<568 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(568 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<569 + 1024 * 1,true> { int V __attribute__ ((bitwidth(569 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<569 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(569 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<570 + 1024 * 1,true> { int V __attribute__ ((bitwidth(570 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<570 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(570 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<571 + 1024 * 1,true> { int V __attribute__ ((bitwidth(571 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<571 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(571 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<572 + 1024 * 1,true> { int V __attribute__ ((bitwidth(572 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<572 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(572 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<573 + 1024 * 1,true> { int V __attribute__ ((bitwidth(573 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<573 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(573 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<574 + 1024 * 1,true> { int V __attribute__ ((bitwidth(574 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<574 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(574 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<575 + 1024 * 1,true> { int V __attribute__ ((bitwidth(575 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<575 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(575 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<576 + 1024 * 1,true> { int V __attribute__ ((bitwidth(576 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<576 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(576 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<577 + 1024 * 1,true> { int V __attribute__ ((bitwidth(577 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<577 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(577 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<578 + 1024 * 1,true> { int V __attribute__ ((bitwidth(578 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<578 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(578 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<579 + 1024 * 1,true> { int V __attribute__ ((bitwidth(579 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<579 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(579 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<580 + 1024 * 1,true> { int V __attribute__ ((bitwidth(580 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<580 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(580 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<581 + 1024 * 1,true> { int V __attribute__ ((bitwidth(581 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<581 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(581 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<582 + 1024 * 1,true> { int V __attribute__ ((bitwidth(582 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<582 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(582 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<583 + 1024 * 1,true> { int V __attribute__ ((bitwidth(583 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<583 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(583 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<584 + 1024 * 1,true> { int V __attribute__ ((bitwidth(584 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<584 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(584 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<585 + 1024 * 1,true> { int V __attribute__ ((bitwidth(585 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<585 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(585 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<586 + 1024 * 1,true> { int V __attribute__ ((bitwidth(586 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<586 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(586 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<587 + 1024 * 1,true> { int V __attribute__ ((bitwidth(587 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<587 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(587 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<588 + 1024 * 1,true> { int V __attribute__ ((bitwidth(588 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<588 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(588 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<589 + 1024 * 1,true> { int V __attribute__ ((bitwidth(589 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<589 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(589 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<590 + 1024 * 1,true> { int V __attribute__ ((bitwidth(590 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<590 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(590 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<591 + 1024 * 1,true> { int V __attribute__ ((bitwidth(591 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<591 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(591 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<592 + 1024 * 1,true> { int V __attribute__ ((bitwidth(592 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<592 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(592 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<593 + 1024 * 1,true> { int V __attribute__ ((bitwidth(593 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<593 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(593 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<594 + 1024 * 1,true> { int V __attribute__ ((bitwidth(594 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<594 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(594 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<595 + 1024 * 1,true> { int V __attribute__ ((bitwidth(595 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<595 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(595 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<596 + 1024 * 1,true> { int V __attribute__ ((bitwidth(596 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<596 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(596 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<597 + 1024 * 1,true> { int V __attribute__ ((bitwidth(597 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<597 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(597 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<598 + 1024 * 1,true> { int V __attribute__ ((bitwidth(598 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<598 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(598 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<599 + 1024 * 1,true> { int V __attribute__ ((bitwidth(599 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<599 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(599 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<600 + 1024 * 1,true> { int V __attribute__ ((bitwidth(600 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<600 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(600 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<601 + 1024 * 1,true> { int V __attribute__ ((bitwidth(601 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<601 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(601 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<602 + 1024 * 1,true> { int V __attribute__ ((bitwidth(602 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<602 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(602 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<603 + 1024 * 1,true> { int V __attribute__ ((bitwidth(603 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<603 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(603 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<604 + 1024 * 1,true> { int V __attribute__ ((bitwidth(604 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<604 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(604 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<605 + 1024 * 1,true> { int V __attribute__ ((bitwidth(605 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<605 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(605 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<606 + 1024 * 1,true> { int V __attribute__ ((bitwidth(606 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<606 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(606 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<607 + 1024 * 1,true> { int V __attribute__ ((bitwidth(607 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<607 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(607 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<608 + 1024 * 1,true> { int V __attribute__ ((bitwidth(608 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<608 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(608 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<609 + 1024 * 1,true> { int V __attribute__ ((bitwidth(609 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<609 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(609 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<610 + 1024 * 1,true> { int V __attribute__ ((bitwidth(610 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<610 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(610 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<611 + 1024 * 1,true> { int V __attribute__ ((bitwidth(611 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<611 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(611 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<612 + 1024 * 1,true> { int V __attribute__ ((bitwidth(612 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<612 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(612 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<613 + 1024 * 1,true> { int V __attribute__ ((bitwidth(613 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<613 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(613 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<614 + 1024 * 1,true> { int V __attribute__ ((bitwidth(614 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<614 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(614 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<615 + 1024 * 1,true> { int V __attribute__ ((bitwidth(615 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<615 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(615 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<616 + 1024 * 1,true> { int V __attribute__ ((bitwidth(616 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<616 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(616 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<617 + 1024 * 1,true> { int V __attribute__ ((bitwidth(617 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<617 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(617 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<618 + 1024 * 1,true> { int V __attribute__ ((bitwidth(618 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<618 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(618 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<619 + 1024 * 1,true> { int V __attribute__ ((bitwidth(619 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<619 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(619 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<620 + 1024 * 1,true> { int V __attribute__ ((bitwidth(620 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<620 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(620 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<621 + 1024 * 1,true> { int V __attribute__ ((bitwidth(621 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<621 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(621 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<622 + 1024 * 1,true> { int V __attribute__ ((bitwidth(622 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<622 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(622 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<623 + 1024 * 1,true> { int V __attribute__ ((bitwidth(623 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<623 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(623 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<624 + 1024 * 1,true> { int V __attribute__ ((bitwidth(624 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<624 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(624 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<625 + 1024 * 1,true> { int V __attribute__ ((bitwidth(625 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<625 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(625 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<626 + 1024 * 1,true> { int V __attribute__ ((bitwidth(626 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<626 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(626 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<627 + 1024 * 1,true> { int V __attribute__ ((bitwidth(627 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<627 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(627 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<628 + 1024 * 1,true> { int V __attribute__ ((bitwidth(628 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<628 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(628 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<629 + 1024 * 1,true> { int V __attribute__ ((bitwidth(629 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<629 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(629 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<630 + 1024 * 1,true> { int V __attribute__ ((bitwidth(630 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<630 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(630 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<631 + 1024 * 1,true> { int V __attribute__ ((bitwidth(631 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<631 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(631 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<632 + 1024 * 1,true> { int V __attribute__ ((bitwidth(632 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<632 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(632 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<633 + 1024 * 1,true> { int V __attribute__ ((bitwidth(633 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<633 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(633 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<634 + 1024 * 1,true> { int V __attribute__ ((bitwidth(634 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<634 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(634 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<635 + 1024 * 1,true> { int V __attribute__ ((bitwidth(635 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<635 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(635 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<636 + 1024 * 1,true> { int V __attribute__ ((bitwidth(636 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<636 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(636 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<637 + 1024 * 1,true> { int V __attribute__ ((bitwidth(637 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<637 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(637 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<638 + 1024 * 1,true> { int V __attribute__ ((bitwidth(638 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<638 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(638 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<639 + 1024 * 1,true> { int V __attribute__ ((bitwidth(639 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<639 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(639 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<640 + 1024 * 1,true> { int V __attribute__ ((bitwidth(640 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<640 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(640 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<641 + 1024 * 1,true> { int V __attribute__ ((bitwidth(641 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<641 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(641 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<642 + 1024 * 1,true> { int V __attribute__ ((bitwidth(642 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<642 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(642 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<643 + 1024 * 1,true> { int V __attribute__ ((bitwidth(643 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<643 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(643 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<644 + 1024 * 1,true> { int V __attribute__ ((bitwidth(644 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<644 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(644 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<645 + 1024 * 1,true> { int V __attribute__ ((bitwidth(645 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<645 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(645 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<646 + 1024 * 1,true> { int V __attribute__ ((bitwidth(646 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<646 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(646 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<647 + 1024 * 1,true> { int V __attribute__ ((bitwidth(647 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<647 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(647 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<648 + 1024 * 1,true> { int V __attribute__ ((bitwidth(648 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<648 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(648 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<649 + 1024 * 1,true> { int V __attribute__ ((bitwidth(649 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<649 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(649 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<650 + 1024 * 1,true> { int V __attribute__ ((bitwidth(650 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<650 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(650 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<651 + 1024 * 1,true> { int V __attribute__ ((bitwidth(651 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<651 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(651 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<652 + 1024 * 1,true> { int V __attribute__ ((bitwidth(652 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<652 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(652 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<653 + 1024 * 1,true> { int V __attribute__ ((bitwidth(653 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<653 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(653 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<654 + 1024 * 1,true> { int V __attribute__ ((bitwidth(654 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<654 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(654 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<655 + 1024 * 1,true> { int V __attribute__ ((bitwidth(655 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<655 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(655 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<656 + 1024 * 1,true> { int V __attribute__ ((bitwidth(656 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<656 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(656 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<657 + 1024 * 1,true> { int V __attribute__ ((bitwidth(657 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<657 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(657 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<658 + 1024 * 1,true> { int V __attribute__ ((bitwidth(658 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<658 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(658 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<659 + 1024 * 1,true> { int V __attribute__ ((bitwidth(659 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<659 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(659 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<660 + 1024 * 1,true> { int V __attribute__ ((bitwidth(660 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<660 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(660 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<661 + 1024 * 1,true> { int V __attribute__ ((bitwidth(661 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<661 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(661 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<662 + 1024 * 1,true> { int V __attribute__ ((bitwidth(662 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<662 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(662 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<663 + 1024 * 1,true> { int V __attribute__ ((bitwidth(663 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<663 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(663 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<664 + 1024 * 1,true> { int V __attribute__ ((bitwidth(664 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<664 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(664 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<665 + 1024 * 1,true> { int V __attribute__ ((bitwidth(665 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<665 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(665 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<666 + 1024 * 1,true> { int V __attribute__ ((bitwidth(666 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<666 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(666 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<667 + 1024 * 1,true> { int V __attribute__ ((bitwidth(667 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<667 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(667 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<668 + 1024 * 1,true> { int V __attribute__ ((bitwidth(668 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<668 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(668 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<669 + 1024 * 1,true> { int V __attribute__ ((bitwidth(669 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<669 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(669 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<670 + 1024 * 1,true> { int V __attribute__ ((bitwidth(670 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<670 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(670 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<671 + 1024 * 1,true> { int V __attribute__ ((bitwidth(671 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<671 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(671 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<672 + 1024 * 1,true> { int V __attribute__ ((bitwidth(672 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<672 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(672 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<673 + 1024 * 1,true> { int V __attribute__ ((bitwidth(673 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<673 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(673 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<674 + 1024 * 1,true> { int V __attribute__ ((bitwidth(674 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<674 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(674 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<675 + 1024 * 1,true> { int V __attribute__ ((bitwidth(675 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<675 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(675 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<676 + 1024 * 1,true> { int V __attribute__ ((bitwidth(676 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<676 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(676 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<677 + 1024 * 1,true> { int V __attribute__ ((bitwidth(677 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<677 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(677 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<678 + 1024 * 1,true> { int V __attribute__ ((bitwidth(678 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<678 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(678 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<679 + 1024 * 1,true> { int V __attribute__ ((bitwidth(679 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<679 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(679 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<680 + 1024 * 1,true> { int V __attribute__ ((bitwidth(680 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<680 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(680 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<681 + 1024 * 1,true> { int V __attribute__ ((bitwidth(681 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<681 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(681 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<682 + 1024 * 1,true> { int V __attribute__ ((bitwidth(682 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<682 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(682 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<683 + 1024 * 1,true> { int V __attribute__ ((bitwidth(683 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<683 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(683 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<684 + 1024 * 1,true> { int V __attribute__ ((bitwidth(684 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<684 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(684 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<685 + 1024 * 1,true> { int V __attribute__ ((bitwidth(685 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<685 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(685 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<686 + 1024 * 1,true> { int V __attribute__ ((bitwidth(686 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<686 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(686 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<687 + 1024 * 1,true> { int V __attribute__ ((bitwidth(687 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<687 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(687 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<688 + 1024 * 1,true> { int V __attribute__ ((bitwidth(688 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<688 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(688 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<689 + 1024 * 1,true> { int V __attribute__ ((bitwidth(689 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<689 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(689 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<690 + 1024 * 1,true> { int V __attribute__ ((bitwidth(690 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<690 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(690 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<691 + 1024 * 1,true> { int V __attribute__ ((bitwidth(691 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<691 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(691 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<692 + 1024 * 1,true> { int V __attribute__ ((bitwidth(692 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<692 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(692 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<693 + 1024 * 1,true> { int V __attribute__ ((bitwidth(693 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<693 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(693 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<694 + 1024 * 1,true> { int V __attribute__ ((bitwidth(694 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<694 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(694 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<695 + 1024 * 1,true> { int V __attribute__ ((bitwidth(695 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<695 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(695 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<696 + 1024 * 1,true> { int V __attribute__ ((bitwidth(696 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<696 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(696 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<697 + 1024 * 1,true> { int V __attribute__ ((bitwidth(697 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<697 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(697 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<698 + 1024 * 1,true> { int V __attribute__ ((bitwidth(698 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<698 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(698 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<699 + 1024 * 1,true> { int V __attribute__ ((bitwidth(699 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<699 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(699 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<700 + 1024 * 1,true> { int V __attribute__ ((bitwidth(700 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<700 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(700 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<701 + 1024 * 1,true> { int V __attribute__ ((bitwidth(701 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<701 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(701 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<702 + 1024 * 1,true> { int V __attribute__ ((bitwidth(702 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<702 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(702 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<703 + 1024 * 1,true> { int V __attribute__ ((bitwidth(703 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<703 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(703 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<704 + 1024 * 1,true> { int V __attribute__ ((bitwidth(704 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<704 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(704 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<705 + 1024 * 1,true> { int V __attribute__ ((bitwidth(705 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<705 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(705 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<706 + 1024 * 1,true> { int V __attribute__ ((bitwidth(706 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<706 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(706 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<707 + 1024 * 1,true> { int V __attribute__ ((bitwidth(707 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<707 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(707 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<708 + 1024 * 1,true> { int V __attribute__ ((bitwidth(708 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<708 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(708 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<709 + 1024 * 1,true> { int V __attribute__ ((bitwidth(709 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<709 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(709 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<710 + 1024 * 1,true> { int V __attribute__ ((bitwidth(710 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<710 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(710 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<711 + 1024 * 1,true> { int V __attribute__ ((bitwidth(711 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<711 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(711 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<712 + 1024 * 1,true> { int V __attribute__ ((bitwidth(712 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<712 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(712 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<713 + 1024 * 1,true> { int V __attribute__ ((bitwidth(713 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<713 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(713 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<714 + 1024 * 1,true> { int V __attribute__ ((bitwidth(714 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<714 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(714 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<715 + 1024 * 1,true> { int V __attribute__ ((bitwidth(715 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<715 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(715 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<716 + 1024 * 1,true> { int V __attribute__ ((bitwidth(716 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<716 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(716 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<717 + 1024 * 1,true> { int V __attribute__ ((bitwidth(717 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<717 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(717 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<718 + 1024 * 1,true> { int V __attribute__ ((bitwidth(718 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<718 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(718 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<719 + 1024 * 1,true> { int V __attribute__ ((bitwidth(719 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<719 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(719 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<720 + 1024 * 1,true> { int V __attribute__ ((bitwidth(720 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<720 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(720 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<721 + 1024 * 1,true> { int V __attribute__ ((bitwidth(721 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<721 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(721 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<722 + 1024 * 1,true> { int V __attribute__ ((bitwidth(722 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<722 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(722 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<723 + 1024 * 1,true> { int V __attribute__ ((bitwidth(723 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<723 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(723 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<724 + 1024 * 1,true> { int V __attribute__ ((bitwidth(724 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<724 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(724 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<725 + 1024 * 1,true> { int V __attribute__ ((bitwidth(725 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<725 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(725 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<726 + 1024 * 1,true> { int V __attribute__ ((bitwidth(726 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<726 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(726 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<727 + 1024 * 1,true> { int V __attribute__ ((bitwidth(727 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<727 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(727 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<728 + 1024 * 1,true> { int V __attribute__ ((bitwidth(728 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<728 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(728 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<729 + 1024 * 1,true> { int V __attribute__ ((bitwidth(729 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<729 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(729 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<730 + 1024 * 1,true> { int V __attribute__ ((bitwidth(730 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<730 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(730 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<731 + 1024 * 1,true> { int V __attribute__ ((bitwidth(731 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<731 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(731 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<732 + 1024 * 1,true> { int V __attribute__ ((bitwidth(732 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<732 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(732 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<733 + 1024 * 1,true> { int V __attribute__ ((bitwidth(733 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<733 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(733 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<734 + 1024 * 1,true> { int V __attribute__ ((bitwidth(734 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<734 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(734 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<735 + 1024 * 1,true> { int V __attribute__ ((bitwidth(735 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<735 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(735 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<736 + 1024 * 1,true> { int V __attribute__ ((bitwidth(736 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<736 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(736 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<737 + 1024 * 1,true> { int V __attribute__ ((bitwidth(737 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<737 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(737 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<738 + 1024 * 1,true> { int V __attribute__ ((bitwidth(738 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<738 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(738 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<739 + 1024 * 1,true> { int V __attribute__ ((bitwidth(739 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<739 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(739 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<740 + 1024 * 1,true> { int V __attribute__ ((bitwidth(740 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<740 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(740 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<741 + 1024 * 1,true> { int V __attribute__ ((bitwidth(741 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<741 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(741 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<742 + 1024 * 1,true> { int V __attribute__ ((bitwidth(742 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<742 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(742 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<743 + 1024 * 1,true> { int V __attribute__ ((bitwidth(743 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<743 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(743 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<744 + 1024 * 1,true> { int V __attribute__ ((bitwidth(744 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<744 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(744 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<745 + 1024 * 1,true> { int V __attribute__ ((bitwidth(745 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<745 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(745 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<746 + 1024 * 1,true> { int V __attribute__ ((bitwidth(746 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<746 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(746 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<747 + 1024 * 1,true> { int V __attribute__ ((bitwidth(747 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<747 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(747 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<748 + 1024 * 1,true> { int V __attribute__ ((bitwidth(748 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<748 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(748 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<749 + 1024 * 1,true> { int V __attribute__ ((bitwidth(749 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<749 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(749 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<750 + 1024 * 1,true> { int V __attribute__ ((bitwidth(750 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<750 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(750 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<751 + 1024 * 1,true> { int V __attribute__ ((bitwidth(751 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<751 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(751 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<752 + 1024 * 1,true> { int V __attribute__ ((bitwidth(752 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<752 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(752 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<753 + 1024 * 1,true> { int V __attribute__ ((bitwidth(753 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<753 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(753 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<754 + 1024 * 1,true> { int V __attribute__ ((bitwidth(754 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<754 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(754 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<755 + 1024 * 1,true> { int V __attribute__ ((bitwidth(755 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<755 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(755 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<756 + 1024 * 1,true> { int V __attribute__ ((bitwidth(756 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<756 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(756 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<757 + 1024 * 1,true> { int V __attribute__ ((bitwidth(757 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<757 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(757 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<758 + 1024 * 1,true> { int V __attribute__ ((bitwidth(758 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<758 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(758 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<759 + 1024 * 1,true> { int V __attribute__ ((bitwidth(759 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<759 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(759 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<760 + 1024 * 1,true> { int V __attribute__ ((bitwidth(760 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<760 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(760 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<761 + 1024 * 1,true> { int V __attribute__ ((bitwidth(761 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<761 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(761 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<762 + 1024 * 1,true> { int V __attribute__ ((bitwidth(762 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<762 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(762 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<763 + 1024 * 1,true> { int V __attribute__ ((bitwidth(763 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<763 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(763 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<764 + 1024 * 1,true> { int V __attribute__ ((bitwidth(764 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<764 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(764 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<765 + 1024 * 1,true> { int V __attribute__ ((bitwidth(765 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<765 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(765 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<766 + 1024 * 1,true> { int V __attribute__ ((bitwidth(766 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<766 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(766 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<767 + 1024 * 1,true> { int V __attribute__ ((bitwidth(767 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<767 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(767 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<768 + 1024 * 1,true> { int V __attribute__ ((bitwidth(768 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<768 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(768 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<769 + 1024 * 1,true> { int V __attribute__ ((bitwidth(769 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<769 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(769 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<770 + 1024 * 1,true> { int V __attribute__ ((bitwidth(770 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<770 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(770 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<771 + 1024 * 1,true> { int V __attribute__ ((bitwidth(771 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<771 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(771 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<772 + 1024 * 1,true> { int V __attribute__ ((bitwidth(772 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<772 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(772 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<773 + 1024 * 1,true> { int V __attribute__ ((bitwidth(773 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<773 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(773 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<774 + 1024 * 1,true> { int V __attribute__ ((bitwidth(774 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<774 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(774 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<775 + 1024 * 1,true> { int V __attribute__ ((bitwidth(775 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<775 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(775 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<776 + 1024 * 1,true> { int V __attribute__ ((bitwidth(776 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<776 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(776 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<777 + 1024 * 1,true> { int V __attribute__ ((bitwidth(777 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<777 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(777 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<778 + 1024 * 1,true> { int V __attribute__ ((bitwidth(778 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<778 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(778 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<779 + 1024 * 1,true> { int V __attribute__ ((bitwidth(779 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<779 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(779 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<780 + 1024 * 1,true> { int V __attribute__ ((bitwidth(780 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<780 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(780 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<781 + 1024 * 1,true> { int V __attribute__ ((bitwidth(781 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<781 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(781 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<782 + 1024 * 1,true> { int V __attribute__ ((bitwidth(782 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<782 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(782 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<783 + 1024 * 1,true> { int V __attribute__ ((bitwidth(783 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<783 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(783 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<784 + 1024 * 1,true> { int V __attribute__ ((bitwidth(784 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<784 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(784 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<785 + 1024 * 1,true> { int V __attribute__ ((bitwidth(785 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<785 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(785 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<786 + 1024 * 1,true> { int V __attribute__ ((bitwidth(786 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<786 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(786 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<787 + 1024 * 1,true> { int V __attribute__ ((bitwidth(787 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<787 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(787 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<788 + 1024 * 1,true> { int V __attribute__ ((bitwidth(788 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<788 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(788 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<789 + 1024 * 1,true> { int V __attribute__ ((bitwidth(789 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<789 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(789 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<790 + 1024 * 1,true> { int V __attribute__ ((bitwidth(790 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<790 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(790 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<791 + 1024 * 1,true> { int V __attribute__ ((bitwidth(791 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<791 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(791 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<792 + 1024 * 1,true> { int V __attribute__ ((bitwidth(792 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<792 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(792 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<793 + 1024 * 1,true> { int V __attribute__ ((bitwidth(793 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<793 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(793 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<794 + 1024 * 1,true> { int V __attribute__ ((bitwidth(794 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<794 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(794 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<795 + 1024 * 1,true> { int V __attribute__ ((bitwidth(795 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<795 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(795 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<796 + 1024 * 1,true> { int V __attribute__ ((bitwidth(796 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<796 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(796 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<797 + 1024 * 1,true> { int V __attribute__ ((bitwidth(797 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<797 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(797 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<798 + 1024 * 1,true> { int V __attribute__ ((bitwidth(798 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<798 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(798 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<799 + 1024 * 1,true> { int V __attribute__ ((bitwidth(799 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<799 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(799 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<800 + 1024 * 1,true> { int V __attribute__ ((bitwidth(800 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<800 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(800 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<801 + 1024 * 1,true> { int V __attribute__ ((bitwidth(801 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<801 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(801 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<802 + 1024 * 1,true> { int V __attribute__ ((bitwidth(802 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<802 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(802 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<803 + 1024 * 1,true> { int V __attribute__ ((bitwidth(803 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<803 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(803 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<804 + 1024 * 1,true> { int V __attribute__ ((bitwidth(804 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<804 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(804 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<805 + 1024 * 1,true> { int V __attribute__ ((bitwidth(805 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<805 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(805 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<806 + 1024 * 1,true> { int V __attribute__ ((bitwidth(806 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<806 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(806 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<807 + 1024 * 1,true> { int V __attribute__ ((bitwidth(807 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<807 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(807 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<808 + 1024 * 1,true> { int V __attribute__ ((bitwidth(808 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<808 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(808 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<809 + 1024 * 1,true> { int V __attribute__ ((bitwidth(809 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<809 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(809 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<810 + 1024 * 1,true> { int V __attribute__ ((bitwidth(810 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<810 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(810 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<811 + 1024 * 1,true> { int V __attribute__ ((bitwidth(811 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<811 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(811 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<812 + 1024 * 1,true> { int V __attribute__ ((bitwidth(812 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<812 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(812 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<813 + 1024 * 1,true> { int V __attribute__ ((bitwidth(813 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<813 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(813 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<814 + 1024 * 1,true> { int V __attribute__ ((bitwidth(814 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<814 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(814 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<815 + 1024 * 1,true> { int V __attribute__ ((bitwidth(815 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<815 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(815 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<816 + 1024 * 1,true> { int V __attribute__ ((bitwidth(816 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<816 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(816 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<817 + 1024 * 1,true> { int V __attribute__ ((bitwidth(817 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<817 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(817 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<818 + 1024 * 1,true> { int V __attribute__ ((bitwidth(818 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<818 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(818 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<819 + 1024 * 1,true> { int V __attribute__ ((bitwidth(819 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<819 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(819 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<820 + 1024 * 1,true> { int V __attribute__ ((bitwidth(820 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<820 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(820 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<821 + 1024 * 1,true> { int V __attribute__ ((bitwidth(821 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<821 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(821 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<822 + 1024 * 1,true> { int V __attribute__ ((bitwidth(822 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<822 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(822 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<823 + 1024 * 1,true> { int V __attribute__ ((bitwidth(823 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<823 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(823 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<824 + 1024 * 1,true> { int V __attribute__ ((bitwidth(824 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<824 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(824 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<825 + 1024 * 1,true> { int V __attribute__ ((bitwidth(825 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<825 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(825 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<826 + 1024 * 1,true> { int V __attribute__ ((bitwidth(826 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<826 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(826 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<827 + 1024 * 1,true> { int V __attribute__ ((bitwidth(827 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<827 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(827 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<828 + 1024 * 1,true> { int V __attribute__ ((bitwidth(828 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<828 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(828 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<829 + 1024 * 1,true> { int V __attribute__ ((bitwidth(829 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<829 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(829 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<830 + 1024 * 1,true> { int V __attribute__ ((bitwidth(830 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<830 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(830 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<831 + 1024 * 1,true> { int V __attribute__ ((bitwidth(831 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<831 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(831 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<832 + 1024 * 1,true> { int V __attribute__ ((bitwidth(832 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<832 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(832 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<833 + 1024 * 1,true> { int V __attribute__ ((bitwidth(833 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<833 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(833 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<834 + 1024 * 1,true> { int V __attribute__ ((bitwidth(834 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<834 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(834 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<835 + 1024 * 1,true> { int V __attribute__ ((bitwidth(835 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<835 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(835 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<836 + 1024 * 1,true> { int V __attribute__ ((bitwidth(836 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<836 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(836 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<837 + 1024 * 1,true> { int V __attribute__ ((bitwidth(837 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<837 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(837 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<838 + 1024 * 1,true> { int V __attribute__ ((bitwidth(838 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<838 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(838 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<839 + 1024 * 1,true> { int V __attribute__ ((bitwidth(839 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<839 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(839 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<840 + 1024 * 1,true> { int V __attribute__ ((bitwidth(840 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<840 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(840 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<841 + 1024 * 1,true> { int V __attribute__ ((bitwidth(841 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<841 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(841 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<842 + 1024 * 1,true> { int V __attribute__ ((bitwidth(842 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<842 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(842 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<843 + 1024 * 1,true> { int V __attribute__ ((bitwidth(843 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<843 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(843 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<844 + 1024 * 1,true> { int V __attribute__ ((bitwidth(844 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<844 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(844 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<845 + 1024 * 1,true> { int V __attribute__ ((bitwidth(845 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<845 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(845 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<846 + 1024 * 1,true> { int V __attribute__ ((bitwidth(846 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<846 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(846 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<847 + 1024 * 1,true> { int V __attribute__ ((bitwidth(847 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<847 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(847 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<848 + 1024 * 1,true> { int V __attribute__ ((bitwidth(848 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<848 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(848 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<849 + 1024 * 1,true> { int V __attribute__ ((bitwidth(849 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<849 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(849 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<850 + 1024 * 1,true> { int V __attribute__ ((bitwidth(850 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<850 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(850 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<851 + 1024 * 1,true> { int V __attribute__ ((bitwidth(851 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<851 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(851 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<852 + 1024 * 1,true> { int V __attribute__ ((bitwidth(852 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<852 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(852 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<853 + 1024 * 1,true> { int V __attribute__ ((bitwidth(853 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<853 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(853 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<854 + 1024 * 1,true> { int V __attribute__ ((bitwidth(854 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<854 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(854 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<855 + 1024 * 1,true> { int V __attribute__ ((bitwidth(855 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<855 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(855 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<856 + 1024 * 1,true> { int V __attribute__ ((bitwidth(856 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<856 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(856 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<857 + 1024 * 1,true> { int V __attribute__ ((bitwidth(857 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<857 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(857 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<858 + 1024 * 1,true> { int V __attribute__ ((bitwidth(858 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<858 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(858 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<859 + 1024 * 1,true> { int V __attribute__ ((bitwidth(859 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<859 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(859 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<860 + 1024 * 1,true> { int V __attribute__ ((bitwidth(860 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<860 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(860 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<861 + 1024 * 1,true> { int V __attribute__ ((bitwidth(861 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<861 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(861 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<862 + 1024 * 1,true> { int V __attribute__ ((bitwidth(862 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<862 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(862 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<863 + 1024 * 1,true> { int V __attribute__ ((bitwidth(863 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<863 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(863 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<864 + 1024 * 1,true> { int V __attribute__ ((bitwidth(864 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<864 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(864 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<865 + 1024 * 1,true> { int V __attribute__ ((bitwidth(865 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<865 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(865 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<866 + 1024 * 1,true> { int V __attribute__ ((bitwidth(866 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<866 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(866 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<867 + 1024 * 1,true> { int V __attribute__ ((bitwidth(867 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<867 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(867 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<868 + 1024 * 1,true> { int V __attribute__ ((bitwidth(868 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<868 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(868 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<869 + 1024 * 1,true> { int V __attribute__ ((bitwidth(869 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<869 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(869 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<870 + 1024 * 1,true> { int V __attribute__ ((bitwidth(870 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<870 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(870 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<871 + 1024 * 1,true> { int V __attribute__ ((bitwidth(871 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<871 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(871 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<872 + 1024 * 1,true> { int V __attribute__ ((bitwidth(872 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<872 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(872 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<873 + 1024 * 1,true> { int V __attribute__ ((bitwidth(873 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<873 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(873 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<874 + 1024 * 1,true> { int V __attribute__ ((bitwidth(874 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<874 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(874 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<875 + 1024 * 1,true> { int V __attribute__ ((bitwidth(875 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<875 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(875 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<876 + 1024 * 1,true> { int V __attribute__ ((bitwidth(876 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<876 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(876 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<877 + 1024 * 1,true> { int V __attribute__ ((bitwidth(877 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<877 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(877 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<878 + 1024 * 1,true> { int V __attribute__ ((bitwidth(878 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<878 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(878 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<879 + 1024 * 1,true> { int V __attribute__ ((bitwidth(879 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<879 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(879 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<880 + 1024 * 1,true> { int V __attribute__ ((bitwidth(880 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<880 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(880 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<881 + 1024 * 1,true> { int V __attribute__ ((bitwidth(881 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<881 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(881 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<882 + 1024 * 1,true> { int V __attribute__ ((bitwidth(882 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<882 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(882 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<883 + 1024 * 1,true> { int V __attribute__ ((bitwidth(883 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<883 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(883 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<884 + 1024 * 1,true> { int V __attribute__ ((bitwidth(884 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<884 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(884 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<885 + 1024 * 1,true> { int V __attribute__ ((bitwidth(885 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<885 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(885 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<886 + 1024 * 1,true> { int V __attribute__ ((bitwidth(886 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<886 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(886 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<887 + 1024 * 1,true> { int V __attribute__ ((bitwidth(887 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<887 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(887 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<888 + 1024 * 1,true> { int V __attribute__ ((bitwidth(888 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<888 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(888 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<889 + 1024 * 1,true> { int V __attribute__ ((bitwidth(889 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<889 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(889 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<890 + 1024 * 1,true> { int V __attribute__ ((bitwidth(890 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<890 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(890 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<891 + 1024 * 1,true> { int V __attribute__ ((bitwidth(891 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<891 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(891 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<892 + 1024 * 1,true> { int V __attribute__ ((bitwidth(892 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<892 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(892 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<893 + 1024 * 1,true> { int V __attribute__ ((bitwidth(893 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<893 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(893 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<894 + 1024 * 1,true> { int V __attribute__ ((bitwidth(894 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<894 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(894 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<895 + 1024 * 1,true> { int V __attribute__ ((bitwidth(895 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<895 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(895 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<896 + 1024 * 1,true> { int V __attribute__ ((bitwidth(896 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<896 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(896 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<897 + 1024 * 1,true> { int V __attribute__ ((bitwidth(897 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<897 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(897 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<898 + 1024 * 1,true> { int V __attribute__ ((bitwidth(898 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<898 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(898 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<899 + 1024 * 1,true> { int V __attribute__ ((bitwidth(899 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<899 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(899 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<900 + 1024 * 1,true> { int V __attribute__ ((bitwidth(900 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<900 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(900 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<901 + 1024 * 1,true> { int V __attribute__ ((bitwidth(901 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<901 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(901 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<902 + 1024 * 1,true> { int V __attribute__ ((bitwidth(902 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<902 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(902 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<903 + 1024 * 1,true> { int V __attribute__ ((bitwidth(903 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<903 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(903 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<904 + 1024 * 1,true> { int V __attribute__ ((bitwidth(904 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<904 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(904 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<905 + 1024 * 1,true> { int V __attribute__ ((bitwidth(905 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<905 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(905 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<906 + 1024 * 1,true> { int V __attribute__ ((bitwidth(906 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<906 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(906 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<907 + 1024 * 1,true> { int V __attribute__ ((bitwidth(907 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<907 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(907 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<908 + 1024 * 1,true> { int V __attribute__ ((bitwidth(908 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<908 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(908 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<909 + 1024 * 1,true> { int V __attribute__ ((bitwidth(909 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<909 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(909 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<910 + 1024 * 1,true> { int V __attribute__ ((bitwidth(910 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<910 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(910 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<911 + 1024 * 1,true> { int V __attribute__ ((bitwidth(911 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<911 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(911 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<912 + 1024 * 1,true> { int V __attribute__ ((bitwidth(912 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<912 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(912 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<913 + 1024 * 1,true> { int V __attribute__ ((bitwidth(913 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<913 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(913 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<914 + 1024 * 1,true> { int V __attribute__ ((bitwidth(914 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<914 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(914 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<915 + 1024 * 1,true> { int V __attribute__ ((bitwidth(915 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<915 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(915 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<916 + 1024 * 1,true> { int V __attribute__ ((bitwidth(916 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<916 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(916 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<917 + 1024 * 1,true> { int V __attribute__ ((bitwidth(917 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<917 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(917 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<918 + 1024 * 1,true> { int V __attribute__ ((bitwidth(918 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<918 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(918 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<919 + 1024 * 1,true> { int V __attribute__ ((bitwidth(919 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<919 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(919 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<920 + 1024 * 1,true> { int V __attribute__ ((bitwidth(920 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<920 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(920 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<921 + 1024 * 1,true> { int V __attribute__ ((bitwidth(921 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<921 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(921 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<922 + 1024 * 1,true> { int V __attribute__ ((bitwidth(922 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<922 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(922 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<923 + 1024 * 1,true> { int V __attribute__ ((bitwidth(923 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<923 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(923 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<924 + 1024 * 1,true> { int V __attribute__ ((bitwidth(924 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<924 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(924 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<925 + 1024 * 1,true> { int V __attribute__ ((bitwidth(925 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<925 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(925 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<926 + 1024 * 1,true> { int V __attribute__ ((bitwidth(926 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<926 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(926 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<927 + 1024 * 1,true> { int V __attribute__ ((bitwidth(927 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<927 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(927 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<928 + 1024 * 1,true> { int V __attribute__ ((bitwidth(928 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<928 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(928 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<929 + 1024 * 1,true> { int V __attribute__ ((bitwidth(929 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<929 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(929 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<930 + 1024 * 1,true> { int V __attribute__ ((bitwidth(930 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<930 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(930 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<931 + 1024 * 1,true> { int V __attribute__ ((bitwidth(931 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<931 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(931 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<932 + 1024 * 1,true> { int V __attribute__ ((bitwidth(932 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<932 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(932 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<933 + 1024 * 1,true> { int V __attribute__ ((bitwidth(933 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<933 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(933 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<934 + 1024 * 1,true> { int V __attribute__ ((bitwidth(934 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<934 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(934 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<935 + 1024 * 1,true> { int V __attribute__ ((bitwidth(935 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<935 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(935 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<936 + 1024 * 1,true> { int V __attribute__ ((bitwidth(936 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<936 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(936 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<937 + 1024 * 1,true> { int V __attribute__ ((bitwidth(937 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<937 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(937 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<938 + 1024 * 1,true> { int V __attribute__ ((bitwidth(938 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<938 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(938 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<939 + 1024 * 1,true> { int V __attribute__ ((bitwidth(939 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<939 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(939 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<940 + 1024 * 1,true> { int V __attribute__ ((bitwidth(940 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<940 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(940 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<941 + 1024 * 1,true> { int V __attribute__ ((bitwidth(941 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<941 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(941 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<942 + 1024 * 1,true> { int V __attribute__ ((bitwidth(942 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<942 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(942 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<943 + 1024 * 1,true> { int V __attribute__ ((bitwidth(943 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<943 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(943 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<944 + 1024 * 1,true> { int V __attribute__ ((bitwidth(944 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<944 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(944 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<945 + 1024 * 1,true> { int V __attribute__ ((bitwidth(945 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<945 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(945 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<946 + 1024 * 1,true> { int V __attribute__ ((bitwidth(946 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<946 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(946 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<947 + 1024 * 1,true> { int V __attribute__ ((bitwidth(947 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<947 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(947 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<948 + 1024 * 1,true> { int V __attribute__ ((bitwidth(948 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<948 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(948 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<949 + 1024 * 1,true> { int V __attribute__ ((bitwidth(949 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<949 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(949 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<950 + 1024 * 1,true> { int V __attribute__ ((bitwidth(950 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<950 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(950 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<951 + 1024 * 1,true> { int V __attribute__ ((bitwidth(951 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<951 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(951 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<952 + 1024 * 1,true> { int V __attribute__ ((bitwidth(952 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<952 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(952 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<953 + 1024 * 1,true> { int V __attribute__ ((bitwidth(953 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<953 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(953 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<954 + 1024 * 1,true> { int V __attribute__ ((bitwidth(954 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<954 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(954 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<955 + 1024 * 1,true> { int V __attribute__ ((bitwidth(955 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<955 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(955 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<956 + 1024 * 1,true> { int V __attribute__ ((bitwidth(956 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<956 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(956 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<957 + 1024 * 1,true> { int V __attribute__ ((bitwidth(957 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<957 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(957 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<958 + 1024 * 1,true> { int V __attribute__ ((bitwidth(958 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<958 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(958 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<959 + 1024 * 1,true> { int V __attribute__ ((bitwidth(959 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<959 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(959 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<960 + 1024 * 1,true> { int V __attribute__ ((bitwidth(960 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<960 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(960 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<961 + 1024 * 1,true> { int V __attribute__ ((bitwidth(961 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<961 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(961 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<962 + 1024 * 1,true> { int V __attribute__ ((bitwidth(962 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<962 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(962 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<963 + 1024 * 1,true> { int V __attribute__ ((bitwidth(963 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<963 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(963 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<964 + 1024 * 1,true> { int V __attribute__ ((bitwidth(964 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<964 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(964 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<965 + 1024 * 1,true> { int V __attribute__ ((bitwidth(965 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<965 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(965 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<966 + 1024 * 1,true> { int V __attribute__ ((bitwidth(966 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<966 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(966 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<967 + 1024 * 1,true> { int V __attribute__ ((bitwidth(967 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<967 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(967 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<968 + 1024 * 1,true> { int V __attribute__ ((bitwidth(968 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<968 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(968 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<969 + 1024 * 1,true> { int V __attribute__ ((bitwidth(969 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<969 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(969 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<970 + 1024 * 1,true> { int V __attribute__ ((bitwidth(970 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<970 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(970 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<971 + 1024 * 1,true> { int V __attribute__ ((bitwidth(971 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<971 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(971 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<972 + 1024 * 1,true> { int V __attribute__ ((bitwidth(972 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<972 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(972 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<973 + 1024 * 1,true> { int V __attribute__ ((bitwidth(973 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<973 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(973 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<974 + 1024 * 1,true> { int V __attribute__ ((bitwidth(974 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<974 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(974 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<975 + 1024 * 1,true> { int V __attribute__ ((bitwidth(975 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<975 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(975 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<976 + 1024 * 1,true> { int V __attribute__ ((bitwidth(976 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<976 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(976 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<977 + 1024 * 1,true> { int V __attribute__ ((bitwidth(977 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<977 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(977 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<978 + 1024 * 1,true> { int V __attribute__ ((bitwidth(978 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<978 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(978 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<979 + 1024 * 1,true> { int V __attribute__ ((bitwidth(979 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<979 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(979 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<980 + 1024 * 1,true> { int V __attribute__ ((bitwidth(980 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<980 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(980 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<981 + 1024 * 1,true> { int V __attribute__ ((bitwidth(981 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<981 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(981 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<982 + 1024 * 1,true> { int V __attribute__ ((bitwidth(982 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<982 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(982 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<983 + 1024 * 1,true> { int V __attribute__ ((bitwidth(983 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<983 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(983 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<984 + 1024 * 1,true> { int V __attribute__ ((bitwidth(984 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<984 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(984 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<985 + 1024 * 1,true> { int V __attribute__ ((bitwidth(985 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<985 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(985 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<986 + 1024 * 1,true> { int V __attribute__ ((bitwidth(986 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<986 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(986 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<987 + 1024 * 1,true> { int V __attribute__ ((bitwidth(987 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<987 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(987 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<988 + 1024 * 1,true> { int V __attribute__ ((bitwidth(988 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<988 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(988 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<989 + 1024 * 1,true> { int V __attribute__ ((bitwidth(989 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<989 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(989 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<990 + 1024 * 1,true> { int V __attribute__ ((bitwidth(990 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<990 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(990 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<991 + 1024 * 1,true> { int V __attribute__ ((bitwidth(991 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<991 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(991 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<992 + 1024 * 1,true> { int V __attribute__ ((bitwidth(992 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<992 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(992 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<993 + 1024 * 1,true> { int V __attribute__ ((bitwidth(993 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<993 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(993 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<994 + 1024 * 1,true> { int V __attribute__ ((bitwidth(994 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<994 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(994 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<995 + 1024 * 1,true> { int V __attribute__ ((bitwidth(995 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<995 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(995 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<996 + 1024 * 1,true> { int V __attribute__ ((bitwidth(996 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<996 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(996 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<997 + 1024 * 1,true> { int V __attribute__ ((bitwidth(997 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<997 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(997 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<998 + 1024 * 1,true> { int V __attribute__ ((bitwidth(998 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<998 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(998 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<999 + 1024 * 1,true> { int V __attribute__ ((bitwidth(999 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<999 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(999 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1000 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1000 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1000 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1000 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1001 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1001 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1001 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1001 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1002 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1002 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1002 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1002 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1003 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1003 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1003 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1003 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1004 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1004 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1004 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1004 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1005 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1005 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1005 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1005 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1006 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1006 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1006 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1006 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1007 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1007 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1007 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1007 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1008 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1008 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1008 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1008 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1009 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1009 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1009 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1009 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1010 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1010 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1010 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1010 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1011 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1011 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1011 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1011 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1012 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1012 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1012 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1012 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1013 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1013 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1013 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1013 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1014 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1014 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1014 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1014 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1015 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1015 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1015 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1015 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1016 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1016 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1016 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1016 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1017 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1017 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1017 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1017 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1018 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1018 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1018 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1018 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1019 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1019 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1019 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1019 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1020 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1020 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1020 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1020 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1021 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1021 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1021 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1021 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1022 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1022 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1022 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1022 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1023 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1023 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1023 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1023 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 1 , false>() { }; };
template<> struct ssdm_int<1024 + 1024 * 1,true> { int V __attribute__ ((bitwidth(1024 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 1 ,true>() { }; }; template<> struct ssdm_int<1024 + 1024 * 1, false> { unsigned int V __attribute__ ((bitwidth(1024 + 1024 * 1))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 1 , false>() { }; };
#pragma line 141 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_dt.def" 1
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<1 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<2 + 1024 * 2,true> { int V __attribute__ ((bitwidth(2 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<2 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(2 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<3 + 1024 * 2,true> { int V __attribute__ ((bitwidth(3 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<3 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(3 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<4 + 1024 * 2,true> { int V __attribute__ ((bitwidth(4 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<4 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(4 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<5 + 1024 * 2,true> { int V __attribute__ ((bitwidth(5 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<5 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(5 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<6 + 1024 * 2,true> { int V __attribute__ ((bitwidth(6 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<6 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(6 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<7 + 1024 * 2,true> { int V __attribute__ ((bitwidth(7 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<7 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(7 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<8 + 1024 * 2,true> { int V __attribute__ ((bitwidth(8 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<8 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(8 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<9 + 1024 * 2,true> { int V __attribute__ ((bitwidth(9 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<9 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(9 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<10 + 1024 * 2,true> { int V __attribute__ ((bitwidth(10 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<10 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(10 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<11 + 1024 * 2,true> { int V __attribute__ ((bitwidth(11 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<11 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(11 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<12 + 1024 * 2,true> { int V __attribute__ ((bitwidth(12 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<12 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(12 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<13 + 1024 * 2,true> { int V __attribute__ ((bitwidth(13 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<13 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(13 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<14 + 1024 * 2,true> { int V __attribute__ ((bitwidth(14 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<14 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(14 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<15 + 1024 * 2,true> { int V __attribute__ ((bitwidth(15 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<15 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(15 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<16 + 1024 * 2,true> { int V __attribute__ ((bitwidth(16 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<16 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(16 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<17 + 1024 * 2,true> { int V __attribute__ ((bitwidth(17 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<17 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(17 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<18 + 1024 * 2,true> { int V __attribute__ ((bitwidth(18 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<18 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(18 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<19 + 1024 * 2,true> { int V __attribute__ ((bitwidth(19 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<19 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(19 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<20 + 1024 * 2,true> { int V __attribute__ ((bitwidth(20 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<20 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(20 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<21 + 1024 * 2,true> { int V __attribute__ ((bitwidth(21 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<21 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(21 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<22 + 1024 * 2,true> { int V __attribute__ ((bitwidth(22 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<22 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(22 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<23 + 1024 * 2,true> { int V __attribute__ ((bitwidth(23 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<23 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(23 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<24 + 1024 * 2,true> { int V __attribute__ ((bitwidth(24 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<24 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(24 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<25 + 1024 * 2,true> { int V __attribute__ ((bitwidth(25 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<25 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(25 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<26 + 1024 * 2,true> { int V __attribute__ ((bitwidth(26 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<26 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(26 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<27 + 1024 * 2,true> { int V __attribute__ ((bitwidth(27 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<27 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(27 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<28 + 1024 * 2,true> { int V __attribute__ ((bitwidth(28 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<28 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(28 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<29 + 1024 * 2,true> { int V __attribute__ ((bitwidth(29 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<29 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(29 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<30 + 1024 * 2,true> { int V __attribute__ ((bitwidth(30 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<30 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(30 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<31 + 1024 * 2,true> { int V __attribute__ ((bitwidth(31 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<31 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(31 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<32 + 1024 * 2,true> { int V __attribute__ ((bitwidth(32 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<32 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(32 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<33 + 1024 * 2,true> { int V __attribute__ ((bitwidth(33 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<33 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(33 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<34 + 1024 * 2,true> { int V __attribute__ ((bitwidth(34 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<34 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(34 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<35 + 1024 * 2,true> { int V __attribute__ ((bitwidth(35 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<35 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(35 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<36 + 1024 * 2,true> { int V __attribute__ ((bitwidth(36 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<36 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(36 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<37 + 1024 * 2,true> { int V __attribute__ ((bitwidth(37 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<37 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(37 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<38 + 1024 * 2,true> { int V __attribute__ ((bitwidth(38 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<38 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(38 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<39 + 1024 * 2,true> { int V __attribute__ ((bitwidth(39 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<39 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(39 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<40 + 1024 * 2,true> { int V __attribute__ ((bitwidth(40 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<40 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(40 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<41 + 1024 * 2,true> { int V __attribute__ ((bitwidth(41 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<41 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(41 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<42 + 1024 * 2,true> { int V __attribute__ ((bitwidth(42 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<42 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(42 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<43 + 1024 * 2,true> { int V __attribute__ ((bitwidth(43 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<43 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(43 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<44 + 1024 * 2,true> { int V __attribute__ ((bitwidth(44 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<44 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(44 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<45 + 1024 * 2,true> { int V __attribute__ ((bitwidth(45 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<45 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(45 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<46 + 1024 * 2,true> { int V __attribute__ ((bitwidth(46 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<46 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(46 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<47 + 1024 * 2,true> { int V __attribute__ ((bitwidth(47 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<47 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(47 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<48 + 1024 * 2,true> { int V __attribute__ ((bitwidth(48 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<48 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(48 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<49 + 1024 * 2,true> { int V __attribute__ ((bitwidth(49 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<49 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(49 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<50 + 1024 * 2,true> { int V __attribute__ ((bitwidth(50 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<50 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(50 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<51 + 1024 * 2,true> { int V __attribute__ ((bitwidth(51 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<51 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(51 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<52 + 1024 * 2,true> { int V __attribute__ ((bitwidth(52 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<52 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(52 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<53 + 1024 * 2,true> { int V __attribute__ ((bitwidth(53 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<53 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(53 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<54 + 1024 * 2,true> { int V __attribute__ ((bitwidth(54 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<54 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(54 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<55 + 1024 * 2,true> { int V __attribute__ ((bitwidth(55 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<55 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(55 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<56 + 1024 * 2,true> { int V __attribute__ ((bitwidth(56 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<56 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(56 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<57 + 1024 * 2,true> { int V __attribute__ ((bitwidth(57 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<57 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(57 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<58 + 1024 * 2,true> { int V __attribute__ ((bitwidth(58 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<58 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(58 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<59 + 1024 * 2,true> { int V __attribute__ ((bitwidth(59 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<59 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(59 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<60 + 1024 * 2,true> { int V __attribute__ ((bitwidth(60 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<60 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(60 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<61 + 1024 * 2,true> { int V __attribute__ ((bitwidth(61 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<61 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(61 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<62 + 1024 * 2,true> { int V __attribute__ ((bitwidth(62 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<62 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(62 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<63 + 1024 * 2,true> { int V __attribute__ ((bitwidth(63 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<63 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(63 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 2 , false>() { }; };
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<64 + 1024 * 2,true> { int V __attribute__ ((bitwidth(64 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<64 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(64 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 2 , false>() { }; };
#pragma empty_line
#pragma empty_line
/*#if AUTOPILOT_VERSION >= 1 */
#pragma empty_line
template<> struct ssdm_int<65 + 1024 * 2,true> { int V __attribute__ ((bitwidth(65 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<65 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(65 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<66 + 1024 * 2,true> { int V __attribute__ ((bitwidth(66 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<66 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(66 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<67 + 1024 * 2,true> { int V __attribute__ ((bitwidth(67 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<67 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(67 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<68 + 1024 * 2,true> { int V __attribute__ ((bitwidth(68 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<68 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(68 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<69 + 1024 * 2,true> { int V __attribute__ ((bitwidth(69 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<69 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(69 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<70 + 1024 * 2,true> { int V __attribute__ ((bitwidth(70 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<70 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(70 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<71 + 1024 * 2,true> { int V __attribute__ ((bitwidth(71 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<71 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(71 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<72 + 1024 * 2,true> { int V __attribute__ ((bitwidth(72 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<72 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(72 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<73 + 1024 * 2,true> { int V __attribute__ ((bitwidth(73 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<73 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(73 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<74 + 1024 * 2,true> { int V __attribute__ ((bitwidth(74 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<74 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(74 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<75 + 1024 * 2,true> { int V __attribute__ ((bitwidth(75 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<75 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(75 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<76 + 1024 * 2,true> { int V __attribute__ ((bitwidth(76 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<76 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(76 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<77 + 1024 * 2,true> { int V __attribute__ ((bitwidth(77 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<77 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(77 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<78 + 1024 * 2,true> { int V __attribute__ ((bitwidth(78 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<78 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(78 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<79 + 1024 * 2,true> { int V __attribute__ ((bitwidth(79 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<79 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(79 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<80 + 1024 * 2,true> { int V __attribute__ ((bitwidth(80 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<80 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(80 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<81 + 1024 * 2,true> { int V __attribute__ ((bitwidth(81 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<81 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(81 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<82 + 1024 * 2,true> { int V __attribute__ ((bitwidth(82 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<82 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(82 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<83 + 1024 * 2,true> { int V __attribute__ ((bitwidth(83 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<83 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(83 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<84 + 1024 * 2,true> { int V __attribute__ ((bitwidth(84 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<84 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(84 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<85 + 1024 * 2,true> { int V __attribute__ ((bitwidth(85 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<85 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(85 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<86 + 1024 * 2,true> { int V __attribute__ ((bitwidth(86 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<86 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(86 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<87 + 1024 * 2,true> { int V __attribute__ ((bitwidth(87 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<87 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(87 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<88 + 1024 * 2,true> { int V __attribute__ ((bitwidth(88 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<88 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(88 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<89 + 1024 * 2,true> { int V __attribute__ ((bitwidth(89 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<89 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(89 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<90 + 1024 * 2,true> { int V __attribute__ ((bitwidth(90 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<90 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(90 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<91 + 1024 * 2,true> { int V __attribute__ ((bitwidth(91 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<91 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(91 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<92 + 1024 * 2,true> { int V __attribute__ ((bitwidth(92 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<92 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(92 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<93 + 1024 * 2,true> { int V __attribute__ ((bitwidth(93 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<93 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(93 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<94 + 1024 * 2,true> { int V __attribute__ ((bitwidth(94 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<94 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(94 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<95 + 1024 * 2,true> { int V __attribute__ ((bitwidth(95 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<95 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(95 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<96 + 1024 * 2,true> { int V __attribute__ ((bitwidth(96 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<96 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(96 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<97 + 1024 * 2,true> { int V __attribute__ ((bitwidth(97 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<97 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(97 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<98 + 1024 * 2,true> { int V __attribute__ ((bitwidth(98 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<98 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(98 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<99 + 1024 * 2,true> { int V __attribute__ ((bitwidth(99 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<99 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(99 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<100 + 1024 * 2,true> { int V __attribute__ ((bitwidth(100 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<100 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(100 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<101 + 1024 * 2,true> { int V __attribute__ ((bitwidth(101 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<101 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(101 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<102 + 1024 * 2,true> { int V __attribute__ ((bitwidth(102 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<102 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(102 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<103 + 1024 * 2,true> { int V __attribute__ ((bitwidth(103 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<103 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(103 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<104 + 1024 * 2,true> { int V __attribute__ ((bitwidth(104 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<104 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(104 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<105 + 1024 * 2,true> { int V __attribute__ ((bitwidth(105 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<105 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(105 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<106 + 1024 * 2,true> { int V __attribute__ ((bitwidth(106 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<106 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(106 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<107 + 1024 * 2,true> { int V __attribute__ ((bitwidth(107 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<107 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(107 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<108 + 1024 * 2,true> { int V __attribute__ ((bitwidth(108 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<108 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(108 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<109 + 1024 * 2,true> { int V __attribute__ ((bitwidth(109 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<109 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(109 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<110 + 1024 * 2,true> { int V __attribute__ ((bitwidth(110 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<110 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(110 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<111 + 1024 * 2,true> { int V __attribute__ ((bitwidth(111 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<111 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(111 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<112 + 1024 * 2,true> { int V __attribute__ ((bitwidth(112 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<112 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(112 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<113 + 1024 * 2,true> { int V __attribute__ ((bitwidth(113 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<113 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(113 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<114 + 1024 * 2,true> { int V __attribute__ ((bitwidth(114 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<114 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(114 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<115 + 1024 * 2,true> { int V __attribute__ ((bitwidth(115 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<115 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(115 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<116 + 1024 * 2,true> { int V __attribute__ ((bitwidth(116 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<116 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(116 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<117 + 1024 * 2,true> { int V __attribute__ ((bitwidth(117 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<117 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(117 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<118 + 1024 * 2,true> { int V __attribute__ ((bitwidth(118 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<118 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(118 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<119 + 1024 * 2,true> { int V __attribute__ ((bitwidth(119 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<119 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(119 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<120 + 1024 * 2,true> { int V __attribute__ ((bitwidth(120 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<120 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(120 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<121 + 1024 * 2,true> { int V __attribute__ ((bitwidth(121 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<121 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(121 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<122 + 1024 * 2,true> { int V __attribute__ ((bitwidth(122 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<122 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(122 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<123 + 1024 * 2,true> { int V __attribute__ ((bitwidth(123 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<123 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(123 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<124 + 1024 * 2,true> { int V __attribute__ ((bitwidth(124 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<124 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(124 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<125 + 1024 * 2,true> { int V __attribute__ ((bitwidth(125 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<125 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(125 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<126 + 1024 * 2,true> { int V __attribute__ ((bitwidth(126 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<126 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(126 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<127 + 1024 * 2,true> { int V __attribute__ ((bitwidth(127 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<127 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(127 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<128 + 1024 * 2,true> { int V __attribute__ ((bitwidth(128 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<128 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(128 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 2 , false>() { }; };
#pragma empty_line
/*#endif*/
#pragma empty_line
#pragma empty_line
/*#ifdef EXTENDED_GCC*/
#pragma empty_line
template<> struct ssdm_int<129 + 1024 * 2,true> { int V __attribute__ ((bitwidth(129 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<129 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(129 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<130 + 1024 * 2,true> { int V __attribute__ ((bitwidth(130 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<130 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(130 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<131 + 1024 * 2,true> { int V __attribute__ ((bitwidth(131 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<131 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(131 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<132 + 1024 * 2,true> { int V __attribute__ ((bitwidth(132 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<132 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(132 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<133 + 1024 * 2,true> { int V __attribute__ ((bitwidth(133 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<133 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(133 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<134 + 1024 * 2,true> { int V __attribute__ ((bitwidth(134 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<134 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(134 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<135 + 1024 * 2,true> { int V __attribute__ ((bitwidth(135 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<135 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(135 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<136 + 1024 * 2,true> { int V __attribute__ ((bitwidth(136 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<136 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(136 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<137 + 1024 * 2,true> { int V __attribute__ ((bitwidth(137 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<137 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(137 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<138 + 1024 * 2,true> { int V __attribute__ ((bitwidth(138 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<138 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(138 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<139 + 1024 * 2,true> { int V __attribute__ ((bitwidth(139 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<139 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(139 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<140 + 1024 * 2,true> { int V __attribute__ ((bitwidth(140 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<140 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(140 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<141 + 1024 * 2,true> { int V __attribute__ ((bitwidth(141 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<141 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(141 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<142 + 1024 * 2,true> { int V __attribute__ ((bitwidth(142 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<142 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(142 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<143 + 1024 * 2,true> { int V __attribute__ ((bitwidth(143 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<143 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(143 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<144 + 1024 * 2,true> { int V __attribute__ ((bitwidth(144 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<144 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(144 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<145 + 1024 * 2,true> { int V __attribute__ ((bitwidth(145 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<145 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(145 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<146 + 1024 * 2,true> { int V __attribute__ ((bitwidth(146 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<146 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(146 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<147 + 1024 * 2,true> { int V __attribute__ ((bitwidth(147 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<147 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(147 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<148 + 1024 * 2,true> { int V __attribute__ ((bitwidth(148 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<148 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(148 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<149 + 1024 * 2,true> { int V __attribute__ ((bitwidth(149 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<149 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(149 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<150 + 1024 * 2,true> { int V __attribute__ ((bitwidth(150 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<150 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(150 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<151 + 1024 * 2,true> { int V __attribute__ ((bitwidth(151 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<151 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(151 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<152 + 1024 * 2,true> { int V __attribute__ ((bitwidth(152 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<152 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(152 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<153 + 1024 * 2,true> { int V __attribute__ ((bitwidth(153 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<153 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(153 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<154 + 1024 * 2,true> { int V __attribute__ ((bitwidth(154 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<154 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(154 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<155 + 1024 * 2,true> { int V __attribute__ ((bitwidth(155 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<155 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(155 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<156 + 1024 * 2,true> { int V __attribute__ ((bitwidth(156 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<156 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(156 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<157 + 1024 * 2,true> { int V __attribute__ ((bitwidth(157 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<157 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(157 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<158 + 1024 * 2,true> { int V __attribute__ ((bitwidth(158 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<158 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(158 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<159 + 1024 * 2,true> { int V __attribute__ ((bitwidth(159 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<159 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(159 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<160 + 1024 * 2,true> { int V __attribute__ ((bitwidth(160 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<160 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(160 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<161 + 1024 * 2,true> { int V __attribute__ ((bitwidth(161 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<161 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(161 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<162 + 1024 * 2,true> { int V __attribute__ ((bitwidth(162 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<162 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(162 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<163 + 1024 * 2,true> { int V __attribute__ ((bitwidth(163 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<163 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(163 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<164 + 1024 * 2,true> { int V __attribute__ ((bitwidth(164 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<164 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(164 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<165 + 1024 * 2,true> { int V __attribute__ ((bitwidth(165 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<165 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(165 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<166 + 1024 * 2,true> { int V __attribute__ ((bitwidth(166 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<166 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(166 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<167 + 1024 * 2,true> { int V __attribute__ ((bitwidth(167 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<167 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(167 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<168 + 1024 * 2,true> { int V __attribute__ ((bitwidth(168 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<168 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(168 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<169 + 1024 * 2,true> { int V __attribute__ ((bitwidth(169 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<169 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(169 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<170 + 1024 * 2,true> { int V __attribute__ ((bitwidth(170 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<170 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(170 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<171 + 1024 * 2,true> { int V __attribute__ ((bitwidth(171 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<171 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(171 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<172 + 1024 * 2,true> { int V __attribute__ ((bitwidth(172 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<172 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(172 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<173 + 1024 * 2,true> { int V __attribute__ ((bitwidth(173 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<173 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(173 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<174 + 1024 * 2,true> { int V __attribute__ ((bitwidth(174 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<174 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(174 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<175 + 1024 * 2,true> { int V __attribute__ ((bitwidth(175 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<175 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(175 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<176 + 1024 * 2,true> { int V __attribute__ ((bitwidth(176 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<176 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(176 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<177 + 1024 * 2,true> { int V __attribute__ ((bitwidth(177 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<177 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(177 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<178 + 1024 * 2,true> { int V __attribute__ ((bitwidth(178 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<178 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(178 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<179 + 1024 * 2,true> { int V __attribute__ ((bitwidth(179 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<179 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(179 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<180 + 1024 * 2,true> { int V __attribute__ ((bitwidth(180 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<180 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(180 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<181 + 1024 * 2,true> { int V __attribute__ ((bitwidth(181 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<181 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(181 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<182 + 1024 * 2,true> { int V __attribute__ ((bitwidth(182 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<182 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(182 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<183 + 1024 * 2,true> { int V __attribute__ ((bitwidth(183 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<183 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(183 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<184 + 1024 * 2,true> { int V __attribute__ ((bitwidth(184 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<184 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(184 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<185 + 1024 * 2,true> { int V __attribute__ ((bitwidth(185 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<185 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(185 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<186 + 1024 * 2,true> { int V __attribute__ ((bitwidth(186 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<186 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(186 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<187 + 1024 * 2,true> { int V __attribute__ ((bitwidth(187 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<187 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(187 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<188 + 1024 * 2,true> { int V __attribute__ ((bitwidth(188 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<188 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(188 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<189 + 1024 * 2,true> { int V __attribute__ ((bitwidth(189 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<189 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(189 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<190 + 1024 * 2,true> { int V __attribute__ ((bitwidth(190 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<190 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(190 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<191 + 1024 * 2,true> { int V __attribute__ ((bitwidth(191 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<191 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(191 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<192 + 1024 * 2,true> { int V __attribute__ ((bitwidth(192 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<192 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(192 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<193 + 1024 * 2,true> { int V __attribute__ ((bitwidth(193 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<193 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(193 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<194 + 1024 * 2,true> { int V __attribute__ ((bitwidth(194 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<194 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(194 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<195 + 1024 * 2,true> { int V __attribute__ ((bitwidth(195 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<195 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(195 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<196 + 1024 * 2,true> { int V __attribute__ ((bitwidth(196 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<196 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(196 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<197 + 1024 * 2,true> { int V __attribute__ ((bitwidth(197 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<197 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(197 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<198 + 1024 * 2,true> { int V __attribute__ ((bitwidth(198 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<198 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(198 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<199 + 1024 * 2,true> { int V __attribute__ ((bitwidth(199 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<199 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(199 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<200 + 1024 * 2,true> { int V __attribute__ ((bitwidth(200 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<200 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(200 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<201 + 1024 * 2,true> { int V __attribute__ ((bitwidth(201 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<201 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(201 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<202 + 1024 * 2,true> { int V __attribute__ ((bitwidth(202 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<202 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(202 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<203 + 1024 * 2,true> { int V __attribute__ ((bitwidth(203 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<203 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(203 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<204 + 1024 * 2,true> { int V __attribute__ ((bitwidth(204 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<204 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(204 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<205 + 1024 * 2,true> { int V __attribute__ ((bitwidth(205 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<205 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(205 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<206 + 1024 * 2,true> { int V __attribute__ ((bitwidth(206 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<206 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(206 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<207 + 1024 * 2,true> { int V __attribute__ ((bitwidth(207 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<207 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(207 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<208 + 1024 * 2,true> { int V __attribute__ ((bitwidth(208 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<208 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(208 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<209 + 1024 * 2,true> { int V __attribute__ ((bitwidth(209 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<209 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(209 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<210 + 1024 * 2,true> { int V __attribute__ ((bitwidth(210 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<210 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(210 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<211 + 1024 * 2,true> { int V __attribute__ ((bitwidth(211 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<211 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(211 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<212 + 1024 * 2,true> { int V __attribute__ ((bitwidth(212 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<212 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(212 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<213 + 1024 * 2,true> { int V __attribute__ ((bitwidth(213 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<213 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(213 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<214 + 1024 * 2,true> { int V __attribute__ ((bitwidth(214 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<214 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(214 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<215 + 1024 * 2,true> { int V __attribute__ ((bitwidth(215 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<215 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(215 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<216 + 1024 * 2,true> { int V __attribute__ ((bitwidth(216 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<216 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(216 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<217 + 1024 * 2,true> { int V __attribute__ ((bitwidth(217 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<217 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(217 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<218 + 1024 * 2,true> { int V __attribute__ ((bitwidth(218 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<218 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(218 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<219 + 1024 * 2,true> { int V __attribute__ ((bitwidth(219 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<219 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(219 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<220 + 1024 * 2,true> { int V __attribute__ ((bitwidth(220 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<220 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(220 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<221 + 1024 * 2,true> { int V __attribute__ ((bitwidth(221 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<221 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(221 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<222 + 1024 * 2,true> { int V __attribute__ ((bitwidth(222 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<222 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(222 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<223 + 1024 * 2,true> { int V __attribute__ ((bitwidth(223 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<223 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(223 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<224 + 1024 * 2,true> { int V __attribute__ ((bitwidth(224 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<224 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(224 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<225 + 1024 * 2,true> { int V __attribute__ ((bitwidth(225 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<225 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(225 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<226 + 1024 * 2,true> { int V __attribute__ ((bitwidth(226 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<226 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(226 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<227 + 1024 * 2,true> { int V __attribute__ ((bitwidth(227 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<227 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(227 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<228 + 1024 * 2,true> { int V __attribute__ ((bitwidth(228 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<228 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(228 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<229 + 1024 * 2,true> { int V __attribute__ ((bitwidth(229 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<229 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(229 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<230 + 1024 * 2,true> { int V __attribute__ ((bitwidth(230 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<230 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(230 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<231 + 1024 * 2,true> { int V __attribute__ ((bitwidth(231 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<231 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(231 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<232 + 1024 * 2,true> { int V __attribute__ ((bitwidth(232 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<232 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(232 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<233 + 1024 * 2,true> { int V __attribute__ ((bitwidth(233 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<233 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(233 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<234 + 1024 * 2,true> { int V __attribute__ ((bitwidth(234 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<234 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(234 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<235 + 1024 * 2,true> { int V __attribute__ ((bitwidth(235 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<235 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(235 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<236 + 1024 * 2,true> { int V __attribute__ ((bitwidth(236 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<236 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(236 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<237 + 1024 * 2,true> { int V __attribute__ ((bitwidth(237 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<237 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(237 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<238 + 1024 * 2,true> { int V __attribute__ ((bitwidth(238 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<238 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(238 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<239 + 1024 * 2,true> { int V __attribute__ ((bitwidth(239 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<239 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(239 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<240 + 1024 * 2,true> { int V __attribute__ ((bitwidth(240 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<240 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(240 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<241 + 1024 * 2,true> { int V __attribute__ ((bitwidth(241 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<241 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(241 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<242 + 1024 * 2,true> { int V __attribute__ ((bitwidth(242 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<242 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(242 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<243 + 1024 * 2,true> { int V __attribute__ ((bitwidth(243 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<243 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(243 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<244 + 1024 * 2,true> { int V __attribute__ ((bitwidth(244 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<244 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(244 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<245 + 1024 * 2,true> { int V __attribute__ ((bitwidth(245 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<245 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(245 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<246 + 1024 * 2,true> { int V __attribute__ ((bitwidth(246 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<246 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(246 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<247 + 1024 * 2,true> { int V __attribute__ ((bitwidth(247 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<247 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(247 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<248 + 1024 * 2,true> { int V __attribute__ ((bitwidth(248 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<248 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(248 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<249 + 1024 * 2,true> { int V __attribute__ ((bitwidth(249 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<249 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(249 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<250 + 1024 * 2,true> { int V __attribute__ ((bitwidth(250 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<250 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(250 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<251 + 1024 * 2,true> { int V __attribute__ ((bitwidth(251 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<251 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(251 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<252 + 1024 * 2,true> { int V __attribute__ ((bitwidth(252 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<252 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(252 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<253 + 1024 * 2,true> { int V __attribute__ ((bitwidth(253 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<253 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(253 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<254 + 1024 * 2,true> { int V __attribute__ ((bitwidth(254 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<254 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(254 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<255 + 1024 * 2,true> { int V __attribute__ ((bitwidth(255 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<255 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(255 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<256 + 1024 * 2,true> { int V __attribute__ ((bitwidth(256 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<256 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(256 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<257 + 1024 * 2,true> { int V __attribute__ ((bitwidth(257 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<257 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(257 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<258 + 1024 * 2,true> { int V __attribute__ ((bitwidth(258 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<258 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(258 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<259 + 1024 * 2,true> { int V __attribute__ ((bitwidth(259 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<259 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(259 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<260 + 1024 * 2,true> { int V __attribute__ ((bitwidth(260 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<260 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(260 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<261 + 1024 * 2,true> { int V __attribute__ ((bitwidth(261 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<261 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(261 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<262 + 1024 * 2,true> { int V __attribute__ ((bitwidth(262 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<262 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(262 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<263 + 1024 * 2,true> { int V __attribute__ ((bitwidth(263 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<263 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(263 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<264 + 1024 * 2,true> { int V __attribute__ ((bitwidth(264 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<264 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(264 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<265 + 1024 * 2,true> { int V __attribute__ ((bitwidth(265 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<265 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(265 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<266 + 1024 * 2,true> { int V __attribute__ ((bitwidth(266 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<266 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(266 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<267 + 1024 * 2,true> { int V __attribute__ ((bitwidth(267 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<267 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(267 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<268 + 1024 * 2,true> { int V __attribute__ ((bitwidth(268 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<268 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(268 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<269 + 1024 * 2,true> { int V __attribute__ ((bitwidth(269 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<269 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(269 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<270 + 1024 * 2,true> { int V __attribute__ ((bitwidth(270 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<270 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(270 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<271 + 1024 * 2,true> { int V __attribute__ ((bitwidth(271 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<271 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(271 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<272 + 1024 * 2,true> { int V __attribute__ ((bitwidth(272 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<272 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(272 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<273 + 1024 * 2,true> { int V __attribute__ ((bitwidth(273 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<273 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(273 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<274 + 1024 * 2,true> { int V __attribute__ ((bitwidth(274 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<274 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(274 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<275 + 1024 * 2,true> { int V __attribute__ ((bitwidth(275 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<275 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(275 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<276 + 1024 * 2,true> { int V __attribute__ ((bitwidth(276 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<276 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(276 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<277 + 1024 * 2,true> { int V __attribute__ ((bitwidth(277 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<277 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(277 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<278 + 1024 * 2,true> { int V __attribute__ ((bitwidth(278 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<278 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(278 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<279 + 1024 * 2,true> { int V __attribute__ ((bitwidth(279 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<279 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(279 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<280 + 1024 * 2,true> { int V __attribute__ ((bitwidth(280 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<280 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(280 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<281 + 1024 * 2,true> { int V __attribute__ ((bitwidth(281 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<281 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(281 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<282 + 1024 * 2,true> { int V __attribute__ ((bitwidth(282 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<282 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(282 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<283 + 1024 * 2,true> { int V __attribute__ ((bitwidth(283 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<283 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(283 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<284 + 1024 * 2,true> { int V __attribute__ ((bitwidth(284 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<284 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(284 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<285 + 1024 * 2,true> { int V __attribute__ ((bitwidth(285 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<285 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(285 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<286 + 1024 * 2,true> { int V __attribute__ ((bitwidth(286 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<286 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(286 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<287 + 1024 * 2,true> { int V __attribute__ ((bitwidth(287 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<287 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(287 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<288 + 1024 * 2,true> { int V __attribute__ ((bitwidth(288 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<288 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(288 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<289 + 1024 * 2,true> { int V __attribute__ ((bitwidth(289 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<289 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(289 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<290 + 1024 * 2,true> { int V __attribute__ ((bitwidth(290 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<290 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(290 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<291 + 1024 * 2,true> { int V __attribute__ ((bitwidth(291 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<291 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(291 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<292 + 1024 * 2,true> { int V __attribute__ ((bitwidth(292 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<292 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(292 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<293 + 1024 * 2,true> { int V __attribute__ ((bitwidth(293 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<293 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(293 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<294 + 1024 * 2,true> { int V __attribute__ ((bitwidth(294 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<294 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(294 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<295 + 1024 * 2,true> { int V __attribute__ ((bitwidth(295 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<295 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(295 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<296 + 1024 * 2,true> { int V __attribute__ ((bitwidth(296 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<296 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(296 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<297 + 1024 * 2,true> { int V __attribute__ ((bitwidth(297 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<297 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(297 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<298 + 1024 * 2,true> { int V __attribute__ ((bitwidth(298 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<298 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(298 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<299 + 1024 * 2,true> { int V __attribute__ ((bitwidth(299 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<299 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(299 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<300 + 1024 * 2,true> { int V __attribute__ ((bitwidth(300 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<300 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(300 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<301 + 1024 * 2,true> { int V __attribute__ ((bitwidth(301 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<301 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(301 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<302 + 1024 * 2,true> { int V __attribute__ ((bitwidth(302 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<302 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(302 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<303 + 1024 * 2,true> { int V __attribute__ ((bitwidth(303 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<303 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(303 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<304 + 1024 * 2,true> { int V __attribute__ ((bitwidth(304 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<304 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(304 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<305 + 1024 * 2,true> { int V __attribute__ ((bitwidth(305 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<305 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(305 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<306 + 1024 * 2,true> { int V __attribute__ ((bitwidth(306 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<306 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(306 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<307 + 1024 * 2,true> { int V __attribute__ ((bitwidth(307 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<307 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(307 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<308 + 1024 * 2,true> { int V __attribute__ ((bitwidth(308 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<308 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(308 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<309 + 1024 * 2,true> { int V __attribute__ ((bitwidth(309 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<309 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(309 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<310 + 1024 * 2,true> { int V __attribute__ ((bitwidth(310 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<310 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(310 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<311 + 1024 * 2,true> { int V __attribute__ ((bitwidth(311 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<311 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(311 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<312 + 1024 * 2,true> { int V __attribute__ ((bitwidth(312 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<312 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(312 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<313 + 1024 * 2,true> { int V __attribute__ ((bitwidth(313 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<313 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(313 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<314 + 1024 * 2,true> { int V __attribute__ ((bitwidth(314 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<314 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(314 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<315 + 1024 * 2,true> { int V __attribute__ ((bitwidth(315 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<315 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(315 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<316 + 1024 * 2,true> { int V __attribute__ ((bitwidth(316 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<316 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(316 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<317 + 1024 * 2,true> { int V __attribute__ ((bitwidth(317 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<317 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(317 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<318 + 1024 * 2,true> { int V __attribute__ ((bitwidth(318 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<318 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(318 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<319 + 1024 * 2,true> { int V __attribute__ ((bitwidth(319 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<319 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(319 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<320 + 1024 * 2,true> { int V __attribute__ ((bitwidth(320 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<320 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(320 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<321 + 1024 * 2,true> { int V __attribute__ ((bitwidth(321 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<321 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(321 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<322 + 1024 * 2,true> { int V __attribute__ ((bitwidth(322 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<322 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(322 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<323 + 1024 * 2,true> { int V __attribute__ ((bitwidth(323 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<323 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(323 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<324 + 1024 * 2,true> { int V __attribute__ ((bitwidth(324 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<324 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(324 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<325 + 1024 * 2,true> { int V __attribute__ ((bitwidth(325 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<325 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(325 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<326 + 1024 * 2,true> { int V __attribute__ ((bitwidth(326 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<326 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(326 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<327 + 1024 * 2,true> { int V __attribute__ ((bitwidth(327 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<327 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(327 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<328 + 1024 * 2,true> { int V __attribute__ ((bitwidth(328 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<328 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(328 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<329 + 1024 * 2,true> { int V __attribute__ ((bitwidth(329 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<329 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(329 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<330 + 1024 * 2,true> { int V __attribute__ ((bitwidth(330 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<330 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(330 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<331 + 1024 * 2,true> { int V __attribute__ ((bitwidth(331 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<331 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(331 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<332 + 1024 * 2,true> { int V __attribute__ ((bitwidth(332 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<332 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(332 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<333 + 1024 * 2,true> { int V __attribute__ ((bitwidth(333 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<333 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(333 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<334 + 1024 * 2,true> { int V __attribute__ ((bitwidth(334 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<334 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(334 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<335 + 1024 * 2,true> { int V __attribute__ ((bitwidth(335 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<335 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(335 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<336 + 1024 * 2,true> { int V __attribute__ ((bitwidth(336 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<336 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(336 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<337 + 1024 * 2,true> { int V __attribute__ ((bitwidth(337 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<337 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(337 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<338 + 1024 * 2,true> { int V __attribute__ ((bitwidth(338 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<338 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(338 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<339 + 1024 * 2,true> { int V __attribute__ ((bitwidth(339 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<339 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(339 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<340 + 1024 * 2,true> { int V __attribute__ ((bitwidth(340 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<340 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(340 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<341 + 1024 * 2,true> { int V __attribute__ ((bitwidth(341 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<341 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(341 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<342 + 1024 * 2,true> { int V __attribute__ ((bitwidth(342 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<342 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(342 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<343 + 1024 * 2,true> { int V __attribute__ ((bitwidth(343 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<343 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(343 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<344 + 1024 * 2,true> { int V __attribute__ ((bitwidth(344 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<344 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(344 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<345 + 1024 * 2,true> { int V __attribute__ ((bitwidth(345 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<345 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(345 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<346 + 1024 * 2,true> { int V __attribute__ ((bitwidth(346 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<346 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(346 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<347 + 1024 * 2,true> { int V __attribute__ ((bitwidth(347 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<347 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(347 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<348 + 1024 * 2,true> { int V __attribute__ ((bitwidth(348 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<348 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(348 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<349 + 1024 * 2,true> { int V __attribute__ ((bitwidth(349 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<349 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(349 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<350 + 1024 * 2,true> { int V __attribute__ ((bitwidth(350 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<350 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(350 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<351 + 1024 * 2,true> { int V __attribute__ ((bitwidth(351 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<351 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(351 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<352 + 1024 * 2,true> { int V __attribute__ ((bitwidth(352 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<352 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(352 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<353 + 1024 * 2,true> { int V __attribute__ ((bitwidth(353 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<353 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(353 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<354 + 1024 * 2,true> { int V __attribute__ ((bitwidth(354 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<354 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(354 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<355 + 1024 * 2,true> { int V __attribute__ ((bitwidth(355 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<355 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(355 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<356 + 1024 * 2,true> { int V __attribute__ ((bitwidth(356 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<356 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(356 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<357 + 1024 * 2,true> { int V __attribute__ ((bitwidth(357 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<357 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(357 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<358 + 1024 * 2,true> { int V __attribute__ ((bitwidth(358 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<358 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(358 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<359 + 1024 * 2,true> { int V __attribute__ ((bitwidth(359 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<359 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(359 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<360 + 1024 * 2,true> { int V __attribute__ ((bitwidth(360 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<360 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(360 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<361 + 1024 * 2,true> { int V __attribute__ ((bitwidth(361 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<361 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(361 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<362 + 1024 * 2,true> { int V __attribute__ ((bitwidth(362 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<362 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(362 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<363 + 1024 * 2,true> { int V __attribute__ ((bitwidth(363 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<363 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(363 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<364 + 1024 * 2,true> { int V __attribute__ ((bitwidth(364 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<364 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(364 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<365 + 1024 * 2,true> { int V __attribute__ ((bitwidth(365 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<365 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(365 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<366 + 1024 * 2,true> { int V __attribute__ ((bitwidth(366 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<366 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(366 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<367 + 1024 * 2,true> { int V __attribute__ ((bitwidth(367 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<367 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(367 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<368 + 1024 * 2,true> { int V __attribute__ ((bitwidth(368 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<368 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(368 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<369 + 1024 * 2,true> { int V __attribute__ ((bitwidth(369 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<369 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(369 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<370 + 1024 * 2,true> { int V __attribute__ ((bitwidth(370 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<370 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(370 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<371 + 1024 * 2,true> { int V __attribute__ ((bitwidth(371 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<371 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(371 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<372 + 1024 * 2,true> { int V __attribute__ ((bitwidth(372 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<372 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(372 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<373 + 1024 * 2,true> { int V __attribute__ ((bitwidth(373 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<373 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(373 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<374 + 1024 * 2,true> { int V __attribute__ ((bitwidth(374 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<374 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(374 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<375 + 1024 * 2,true> { int V __attribute__ ((bitwidth(375 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<375 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(375 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<376 + 1024 * 2,true> { int V __attribute__ ((bitwidth(376 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<376 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(376 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<377 + 1024 * 2,true> { int V __attribute__ ((bitwidth(377 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<377 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(377 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<378 + 1024 * 2,true> { int V __attribute__ ((bitwidth(378 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<378 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(378 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<379 + 1024 * 2,true> { int V __attribute__ ((bitwidth(379 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<379 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(379 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<380 + 1024 * 2,true> { int V __attribute__ ((bitwidth(380 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<380 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(380 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<381 + 1024 * 2,true> { int V __attribute__ ((bitwidth(381 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<381 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(381 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<382 + 1024 * 2,true> { int V __attribute__ ((bitwidth(382 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<382 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(382 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<383 + 1024 * 2,true> { int V __attribute__ ((bitwidth(383 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<383 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(383 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<384 + 1024 * 2,true> { int V __attribute__ ((bitwidth(384 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<384 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(384 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<385 + 1024 * 2,true> { int V __attribute__ ((bitwidth(385 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<385 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(385 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<386 + 1024 * 2,true> { int V __attribute__ ((bitwidth(386 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<386 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(386 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<387 + 1024 * 2,true> { int V __attribute__ ((bitwidth(387 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<387 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(387 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<388 + 1024 * 2,true> { int V __attribute__ ((bitwidth(388 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<388 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(388 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<389 + 1024 * 2,true> { int V __attribute__ ((bitwidth(389 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<389 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(389 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<390 + 1024 * 2,true> { int V __attribute__ ((bitwidth(390 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<390 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(390 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<391 + 1024 * 2,true> { int V __attribute__ ((bitwidth(391 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<391 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(391 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<392 + 1024 * 2,true> { int V __attribute__ ((bitwidth(392 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<392 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(392 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<393 + 1024 * 2,true> { int V __attribute__ ((bitwidth(393 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<393 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(393 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<394 + 1024 * 2,true> { int V __attribute__ ((bitwidth(394 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<394 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(394 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<395 + 1024 * 2,true> { int V __attribute__ ((bitwidth(395 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<395 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(395 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<396 + 1024 * 2,true> { int V __attribute__ ((bitwidth(396 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<396 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(396 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<397 + 1024 * 2,true> { int V __attribute__ ((bitwidth(397 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<397 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(397 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<398 + 1024 * 2,true> { int V __attribute__ ((bitwidth(398 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<398 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(398 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<399 + 1024 * 2,true> { int V __attribute__ ((bitwidth(399 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<399 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(399 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<400 + 1024 * 2,true> { int V __attribute__ ((bitwidth(400 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<400 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(400 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<401 + 1024 * 2,true> { int V __attribute__ ((bitwidth(401 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<401 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(401 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<402 + 1024 * 2,true> { int V __attribute__ ((bitwidth(402 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<402 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(402 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<403 + 1024 * 2,true> { int V __attribute__ ((bitwidth(403 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<403 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(403 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<404 + 1024 * 2,true> { int V __attribute__ ((bitwidth(404 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<404 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(404 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<405 + 1024 * 2,true> { int V __attribute__ ((bitwidth(405 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<405 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(405 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<406 + 1024 * 2,true> { int V __attribute__ ((bitwidth(406 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<406 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(406 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<407 + 1024 * 2,true> { int V __attribute__ ((bitwidth(407 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<407 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(407 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<408 + 1024 * 2,true> { int V __attribute__ ((bitwidth(408 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<408 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(408 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<409 + 1024 * 2,true> { int V __attribute__ ((bitwidth(409 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<409 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(409 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<410 + 1024 * 2,true> { int V __attribute__ ((bitwidth(410 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<410 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(410 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<411 + 1024 * 2,true> { int V __attribute__ ((bitwidth(411 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<411 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(411 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<412 + 1024 * 2,true> { int V __attribute__ ((bitwidth(412 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<412 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(412 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<413 + 1024 * 2,true> { int V __attribute__ ((bitwidth(413 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<413 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(413 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<414 + 1024 * 2,true> { int V __attribute__ ((bitwidth(414 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<414 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(414 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<415 + 1024 * 2,true> { int V __attribute__ ((bitwidth(415 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<415 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(415 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<416 + 1024 * 2,true> { int V __attribute__ ((bitwidth(416 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<416 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(416 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<417 + 1024 * 2,true> { int V __attribute__ ((bitwidth(417 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<417 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(417 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<418 + 1024 * 2,true> { int V __attribute__ ((bitwidth(418 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<418 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(418 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<419 + 1024 * 2,true> { int V __attribute__ ((bitwidth(419 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<419 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(419 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<420 + 1024 * 2,true> { int V __attribute__ ((bitwidth(420 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<420 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(420 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<421 + 1024 * 2,true> { int V __attribute__ ((bitwidth(421 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<421 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(421 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<422 + 1024 * 2,true> { int V __attribute__ ((bitwidth(422 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<422 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(422 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<423 + 1024 * 2,true> { int V __attribute__ ((bitwidth(423 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<423 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(423 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<424 + 1024 * 2,true> { int V __attribute__ ((bitwidth(424 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<424 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(424 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<425 + 1024 * 2,true> { int V __attribute__ ((bitwidth(425 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<425 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(425 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<426 + 1024 * 2,true> { int V __attribute__ ((bitwidth(426 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<426 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(426 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<427 + 1024 * 2,true> { int V __attribute__ ((bitwidth(427 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<427 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(427 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<428 + 1024 * 2,true> { int V __attribute__ ((bitwidth(428 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<428 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(428 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<429 + 1024 * 2,true> { int V __attribute__ ((bitwidth(429 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<429 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(429 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<430 + 1024 * 2,true> { int V __attribute__ ((bitwidth(430 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<430 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(430 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<431 + 1024 * 2,true> { int V __attribute__ ((bitwidth(431 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<431 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(431 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<432 + 1024 * 2,true> { int V __attribute__ ((bitwidth(432 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<432 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(432 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<433 + 1024 * 2,true> { int V __attribute__ ((bitwidth(433 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<433 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(433 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<434 + 1024 * 2,true> { int V __attribute__ ((bitwidth(434 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<434 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(434 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<435 + 1024 * 2,true> { int V __attribute__ ((bitwidth(435 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<435 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(435 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<436 + 1024 * 2,true> { int V __attribute__ ((bitwidth(436 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<436 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(436 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<437 + 1024 * 2,true> { int V __attribute__ ((bitwidth(437 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<437 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(437 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<438 + 1024 * 2,true> { int V __attribute__ ((bitwidth(438 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<438 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(438 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<439 + 1024 * 2,true> { int V __attribute__ ((bitwidth(439 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<439 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(439 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<440 + 1024 * 2,true> { int V __attribute__ ((bitwidth(440 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<440 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(440 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<441 + 1024 * 2,true> { int V __attribute__ ((bitwidth(441 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<441 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(441 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<442 + 1024 * 2,true> { int V __attribute__ ((bitwidth(442 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<442 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(442 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<443 + 1024 * 2,true> { int V __attribute__ ((bitwidth(443 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<443 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(443 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<444 + 1024 * 2,true> { int V __attribute__ ((bitwidth(444 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<444 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(444 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<445 + 1024 * 2,true> { int V __attribute__ ((bitwidth(445 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<445 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(445 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<446 + 1024 * 2,true> { int V __attribute__ ((bitwidth(446 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<446 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(446 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<447 + 1024 * 2,true> { int V __attribute__ ((bitwidth(447 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<447 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(447 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<448 + 1024 * 2,true> { int V __attribute__ ((bitwidth(448 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<448 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(448 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<449 + 1024 * 2,true> { int V __attribute__ ((bitwidth(449 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<449 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(449 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<450 + 1024 * 2,true> { int V __attribute__ ((bitwidth(450 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<450 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(450 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<451 + 1024 * 2,true> { int V __attribute__ ((bitwidth(451 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<451 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(451 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<452 + 1024 * 2,true> { int V __attribute__ ((bitwidth(452 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<452 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(452 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<453 + 1024 * 2,true> { int V __attribute__ ((bitwidth(453 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<453 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(453 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<454 + 1024 * 2,true> { int V __attribute__ ((bitwidth(454 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<454 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(454 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<455 + 1024 * 2,true> { int V __attribute__ ((bitwidth(455 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<455 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(455 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<456 + 1024 * 2,true> { int V __attribute__ ((bitwidth(456 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<456 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(456 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<457 + 1024 * 2,true> { int V __attribute__ ((bitwidth(457 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<457 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(457 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<458 + 1024 * 2,true> { int V __attribute__ ((bitwidth(458 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<458 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(458 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<459 + 1024 * 2,true> { int V __attribute__ ((bitwidth(459 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<459 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(459 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<460 + 1024 * 2,true> { int V __attribute__ ((bitwidth(460 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<460 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(460 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<461 + 1024 * 2,true> { int V __attribute__ ((bitwidth(461 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<461 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(461 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<462 + 1024 * 2,true> { int V __attribute__ ((bitwidth(462 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<462 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(462 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<463 + 1024 * 2,true> { int V __attribute__ ((bitwidth(463 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<463 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(463 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<464 + 1024 * 2,true> { int V __attribute__ ((bitwidth(464 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<464 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(464 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<465 + 1024 * 2,true> { int V __attribute__ ((bitwidth(465 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<465 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(465 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<466 + 1024 * 2,true> { int V __attribute__ ((bitwidth(466 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<466 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(466 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<467 + 1024 * 2,true> { int V __attribute__ ((bitwidth(467 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<467 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(467 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<468 + 1024 * 2,true> { int V __attribute__ ((bitwidth(468 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<468 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(468 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<469 + 1024 * 2,true> { int V __attribute__ ((bitwidth(469 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<469 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(469 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<470 + 1024 * 2,true> { int V __attribute__ ((bitwidth(470 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<470 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(470 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<471 + 1024 * 2,true> { int V __attribute__ ((bitwidth(471 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<471 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(471 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<472 + 1024 * 2,true> { int V __attribute__ ((bitwidth(472 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<472 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(472 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<473 + 1024 * 2,true> { int V __attribute__ ((bitwidth(473 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<473 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(473 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<474 + 1024 * 2,true> { int V __attribute__ ((bitwidth(474 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<474 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(474 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<475 + 1024 * 2,true> { int V __attribute__ ((bitwidth(475 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<475 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(475 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<476 + 1024 * 2,true> { int V __attribute__ ((bitwidth(476 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<476 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(476 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<477 + 1024 * 2,true> { int V __attribute__ ((bitwidth(477 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<477 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(477 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<478 + 1024 * 2,true> { int V __attribute__ ((bitwidth(478 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<478 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(478 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<479 + 1024 * 2,true> { int V __attribute__ ((bitwidth(479 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<479 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(479 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<480 + 1024 * 2,true> { int V __attribute__ ((bitwidth(480 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<480 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(480 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<481 + 1024 * 2,true> { int V __attribute__ ((bitwidth(481 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<481 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(481 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<482 + 1024 * 2,true> { int V __attribute__ ((bitwidth(482 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<482 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(482 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<483 + 1024 * 2,true> { int V __attribute__ ((bitwidth(483 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<483 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(483 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<484 + 1024 * 2,true> { int V __attribute__ ((bitwidth(484 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<484 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(484 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<485 + 1024 * 2,true> { int V __attribute__ ((bitwidth(485 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<485 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(485 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<486 + 1024 * 2,true> { int V __attribute__ ((bitwidth(486 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<486 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(486 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<487 + 1024 * 2,true> { int V __attribute__ ((bitwidth(487 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<487 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(487 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<488 + 1024 * 2,true> { int V __attribute__ ((bitwidth(488 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<488 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(488 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<489 + 1024 * 2,true> { int V __attribute__ ((bitwidth(489 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<489 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(489 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<490 + 1024 * 2,true> { int V __attribute__ ((bitwidth(490 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<490 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(490 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<491 + 1024 * 2,true> { int V __attribute__ ((bitwidth(491 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<491 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(491 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<492 + 1024 * 2,true> { int V __attribute__ ((bitwidth(492 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<492 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(492 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<493 + 1024 * 2,true> { int V __attribute__ ((bitwidth(493 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<493 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(493 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<494 + 1024 * 2,true> { int V __attribute__ ((bitwidth(494 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<494 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(494 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<495 + 1024 * 2,true> { int V __attribute__ ((bitwidth(495 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<495 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(495 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<496 + 1024 * 2,true> { int V __attribute__ ((bitwidth(496 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<496 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(496 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<497 + 1024 * 2,true> { int V __attribute__ ((bitwidth(497 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<497 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(497 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<498 + 1024 * 2,true> { int V __attribute__ ((bitwidth(498 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<498 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(498 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<499 + 1024 * 2,true> { int V __attribute__ ((bitwidth(499 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<499 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(499 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<500 + 1024 * 2,true> { int V __attribute__ ((bitwidth(500 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<500 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(500 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<501 + 1024 * 2,true> { int V __attribute__ ((bitwidth(501 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<501 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(501 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<502 + 1024 * 2,true> { int V __attribute__ ((bitwidth(502 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<502 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(502 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<503 + 1024 * 2,true> { int V __attribute__ ((bitwidth(503 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<503 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(503 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<504 + 1024 * 2,true> { int V __attribute__ ((bitwidth(504 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<504 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(504 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<505 + 1024 * 2,true> { int V __attribute__ ((bitwidth(505 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<505 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(505 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<506 + 1024 * 2,true> { int V __attribute__ ((bitwidth(506 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<506 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(506 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<507 + 1024 * 2,true> { int V __attribute__ ((bitwidth(507 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<507 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(507 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<508 + 1024 * 2,true> { int V __attribute__ ((bitwidth(508 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<508 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(508 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<509 + 1024 * 2,true> { int V __attribute__ ((bitwidth(509 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<509 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(509 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<510 + 1024 * 2,true> { int V __attribute__ ((bitwidth(510 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<510 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(510 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<511 + 1024 * 2,true> { int V __attribute__ ((bitwidth(511 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<511 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(511 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<512 + 1024 * 2,true> { int V __attribute__ ((bitwidth(512 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<512 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(512 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<513 + 1024 * 2,true> { int V __attribute__ ((bitwidth(513 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<513 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(513 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<514 + 1024 * 2,true> { int V __attribute__ ((bitwidth(514 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<514 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(514 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<515 + 1024 * 2,true> { int V __attribute__ ((bitwidth(515 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<515 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(515 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<516 + 1024 * 2,true> { int V __attribute__ ((bitwidth(516 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<516 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(516 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<517 + 1024 * 2,true> { int V __attribute__ ((bitwidth(517 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<517 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(517 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<518 + 1024 * 2,true> { int V __attribute__ ((bitwidth(518 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<518 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(518 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<519 + 1024 * 2,true> { int V __attribute__ ((bitwidth(519 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<519 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(519 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<520 + 1024 * 2,true> { int V __attribute__ ((bitwidth(520 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<520 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(520 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<521 + 1024 * 2,true> { int V __attribute__ ((bitwidth(521 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<521 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(521 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<522 + 1024 * 2,true> { int V __attribute__ ((bitwidth(522 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<522 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(522 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<523 + 1024 * 2,true> { int V __attribute__ ((bitwidth(523 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<523 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(523 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<524 + 1024 * 2,true> { int V __attribute__ ((bitwidth(524 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<524 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(524 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<525 + 1024 * 2,true> { int V __attribute__ ((bitwidth(525 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<525 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(525 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<526 + 1024 * 2,true> { int V __attribute__ ((bitwidth(526 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<526 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(526 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<527 + 1024 * 2,true> { int V __attribute__ ((bitwidth(527 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<527 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(527 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<528 + 1024 * 2,true> { int V __attribute__ ((bitwidth(528 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<528 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(528 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<529 + 1024 * 2,true> { int V __attribute__ ((bitwidth(529 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<529 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(529 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<530 + 1024 * 2,true> { int V __attribute__ ((bitwidth(530 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<530 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(530 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<531 + 1024 * 2,true> { int V __attribute__ ((bitwidth(531 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<531 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(531 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<532 + 1024 * 2,true> { int V __attribute__ ((bitwidth(532 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<532 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(532 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<533 + 1024 * 2,true> { int V __attribute__ ((bitwidth(533 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<533 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(533 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<534 + 1024 * 2,true> { int V __attribute__ ((bitwidth(534 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<534 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(534 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<535 + 1024 * 2,true> { int V __attribute__ ((bitwidth(535 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<535 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(535 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<536 + 1024 * 2,true> { int V __attribute__ ((bitwidth(536 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<536 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(536 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<537 + 1024 * 2,true> { int V __attribute__ ((bitwidth(537 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<537 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(537 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<538 + 1024 * 2,true> { int V __attribute__ ((bitwidth(538 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<538 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(538 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<539 + 1024 * 2,true> { int V __attribute__ ((bitwidth(539 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<539 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(539 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<540 + 1024 * 2,true> { int V __attribute__ ((bitwidth(540 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<540 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(540 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<541 + 1024 * 2,true> { int V __attribute__ ((bitwidth(541 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<541 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(541 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<542 + 1024 * 2,true> { int V __attribute__ ((bitwidth(542 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<542 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(542 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<543 + 1024 * 2,true> { int V __attribute__ ((bitwidth(543 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<543 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(543 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<544 + 1024 * 2,true> { int V __attribute__ ((bitwidth(544 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<544 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(544 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<545 + 1024 * 2,true> { int V __attribute__ ((bitwidth(545 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<545 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(545 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<546 + 1024 * 2,true> { int V __attribute__ ((bitwidth(546 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<546 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(546 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<547 + 1024 * 2,true> { int V __attribute__ ((bitwidth(547 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<547 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(547 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<548 + 1024 * 2,true> { int V __attribute__ ((bitwidth(548 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<548 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(548 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<549 + 1024 * 2,true> { int V __attribute__ ((bitwidth(549 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<549 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(549 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<550 + 1024 * 2,true> { int V __attribute__ ((bitwidth(550 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<550 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(550 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<551 + 1024 * 2,true> { int V __attribute__ ((bitwidth(551 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<551 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(551 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<552 + 1024 * 2,true> { int V __attribute__ ((bitwidth(552 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<552 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(552 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<553 + 1024 * 2,true> { int V __attribute__ ((bitwidth(553 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<553 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(553 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<554 + 1024 * 2,true> { int V __attribute__ ((bitwidth(554 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<554 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(554 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<555 + 1024 * 2,true> { int V __attribute__ ((bitwidth(555 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<555 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(555 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<556 + 1024 * 2,true> { int V __attribute__ ((bitwidth(556 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<556 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(556 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<557 + 1024 * 2,true> { int V __attribute__ ((bitwidth(557 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<557 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(557 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<558 + 1024 * 2,true> { int V __attribute__ ((bitwidth(558 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<558 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(558 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<559 + 1024 * 2,true> { int V __attribute__ ((bitwidth(559 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<559 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(559 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<560 + 1024 * 2,true> { int V __attribute__ ((bitwidth(560 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<560 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(560 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<561 + 1024 * 2,true> { int V __attribute__ ((bitwidth(561 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<561 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(561 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<562 + 1024 * 2,true> { int V __attribute__ ((bitwidth(562 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<562 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(562 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<563 + 1024 * 2,true> { int V __attribute__ ((bitwidth(563 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<563 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(563 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<564 + 1024 * 2,true> { int V __attribute__ ((bitwidth(564 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<564 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(564 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<565 + 1024 * 2,true> { int V __attribute__ ((bitwidth(565 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<565 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(565 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<566 + 1024 * 2,true> { int V __attribute__ ((bitwidth(566 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<566 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(566 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<567 + 1024 * 2,true> { int V __attribute__ ((bitwidth(567 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<567 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(567 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<568 + 1024 * 2,true> { int V __attribute__ ((bitwidth(568 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<568 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(568 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<569 + 1024 * 2,true> { int V __attribute__ ((bitwidth(569 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<569 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(569 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<570 + 1024 * 2,true> { int V __attribute__ ((bitwidth(570 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<570 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(570 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<571 + 1024 * 2,true> { int V __attribute__ ((bitwidth(571 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<571 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(571 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<572 + 1024 * 2,true> { int V __attribute__ ((bitwidth(572 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<572 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(572 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<573 + 1024 * 2,true> { int V __attribute__ ((bitwidth(573 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<573 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(573 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<574 + 1024 * 2,true> { int V __attribute__ ((bitwidth(574 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<574 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(574 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<575 + 1024 * 2,true> { int V __attribute__ ((bitwidth(575 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<575 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(575 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<576 + 1024 * 2,true> { int V __attribute__ ((bitwidth(576 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<576 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(576 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<577 + 1024 * 2,true> { int V __attribute__ ((bitwidth(577 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<577 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(577 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<578 + 1024 * 2,true> { int V __attribute__ ((bitwidth(578 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<578 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(578 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<579 + 1024 * 2,true> { int V __attribute__ ((bitwidth(579 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<579 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(579 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<580 + 1024 * 2,true> { int V __attribute__ ((bitwidth(580 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<580 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(580 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<581 + 1024 * 2,true> { int V __attribute__ ((bitwidth(581 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<581 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(581 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<582 + 1024 * 2,true> { int V __attribute__ ((bitwidth(582 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<582 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(582 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<583 + 1024 * 2,true> { int V __attribute__ ((bitwidth(583 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<583 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(583 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<584 + 1024 * 2,true> { int V __attribute__ ((bitwidth(584 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<584 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(584 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<585 + 1024 * 2,true> { int V __attribute__ ((bitwidth(585 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<585 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(585 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<586 + 1024 * 2,true> { int V __attribute__ ((bitwidth(586 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<586 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(586 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<587 + 1024 * 2,true> { int V __attribute__ ((bitwidth(587 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<587 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(587 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<588 + 1024 * 2,true> { int V __attribute__ ((bitwidth(588 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<588 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(588 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<589 + 1024 * 2,true> { int V __attribute__ ((bitwidth(589 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<589 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(589 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<590 + 1024 * 2,true> { int V __attribute__ ((bitwidth(590 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<590 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(590 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<591 + 1024 * 2,true> { int V __attribute__ ((bitwidth(591 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<591 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(591 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<592 + 1024 * 2,true> { int V __attribute__ ((bitwidth(592 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<592 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(592 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<593 + 1024 * 2,true> { int V __attribute__ ((bitwidth(593 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<593 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(593 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<594 + 1024 * 2,true> { int V __attribute__ ((bitwidth(594 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<594 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(594 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<595 + 1024 * 2,true> { int V __attribute__ ((bitwidth(595 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<595 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(595 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<596 + 1024 * 2,true> { int V __attribute__ ((bitwidth(596 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<596 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(596 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<597 + 1024 * 2,true> { int V __attribute__ ((bitwidth(597 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<597 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(597 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<598 + 1024 * 2,true> { int V __attribute__ ((bitwidth(598 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<598 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(598 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<599 + 1024 * 2,true> { int V __attribute__ ((bitwidth(599 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<599 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(599 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<600 + 1024 * 2,true> { int V __attribute__ ((bitwidth(600 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<600 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(600 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<601 + 1024 * 2,true> { int V __attribute__ ((bitwidth(601 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<601 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(601 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<602 + 1024 * 2,true> { int V __attribute__ ((bitwidth(602 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<602 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(602 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<603 + 1024 * 2,true> { int V __attribute__ ((bitwidth(603 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<603 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(603 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<604 + 1024 * 2,true> { int V __attribute__ ((bitwidth(604 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<604 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(604 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<605 + 1024 * 2,true> { int V __attribute__ ((bitwidth(605 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<605 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(605 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<606 + 1024 * 2,true> { int V __attribute__ ((bitwidth(606 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<606 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(606 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<607 + 1024 * 2,true> { int V __attribute__ ((bitwidth(607 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<607 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(607 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<608 + 1024 * 2,true> { int V __attribute__ ((bitwidth(608 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<608 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(608 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<609 + 1024 * 2,true> { int V __attribute__ ((bitwidth(609 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<609 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(609 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<610 + 1024 * 2,true> { int V __attribute__ ((bitwidth(610 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<610 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(610 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<611 + 1024 * 2,true> { int V __attribute__ ((bitwidth(611 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<611 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(611 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<612 + 1024 * 2,true> { int V __attribute__ ((bitwidth(612 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<612 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(612 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<613 + 1024 * 2,true> { int V __attribute__ ((bitwidth(613 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<613 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(613 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<614 + 1024 * 2,true> { int V __attribute__ ((bitwidth(614 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<614 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(614 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<615 + 1024 * 2,true> { int V __attribute__ ((bitwidth(615 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<615 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(615 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<616 + 1024 * 2,true> { int V __attribute__ ((bitwidth(616 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<616 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(616 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<617 + 1024 * 2,true> { int V __attribute__ ((bitwidth(617 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<617 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(617 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<618 + 1024 * 2,true> { int V __attribute__ ((bitwidth(618 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<618 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(618 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<619 + 1024 * 2,true> { int V __attribute__ ((bitwidth(619 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<619 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(619 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<620 + 1024 * 2,true> { int V __attribute__ ((bitwidth(620 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<620 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(620 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<621 + 1024 * 2,true> { int V __attribute__ ((bitwidth(621 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<621 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(621 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<622 + 1024 * 2,true> { int V __attribute__ ((bitwidth(622 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<622 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(622 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<623 + 1024 * 2,true> { int V __attribute__ ((bitwidth(623 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<623 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(623 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<624 + 1024 * 2,true> { int V __attribute__ ((bitwidth(624 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<624 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(624 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<625 + 1024 * 2,true> { int V __attribute__ ((bitwidth(625 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<625 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(625 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<626 + 1024 * 2,true> { int V __attribute__ ((bitwidth(626 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<626 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(626 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<627 + 1024 * 2,true> { int V __attribute__ ((bitwidth(627 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<627 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(627 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<628 + 1024 * 2,true> { int V __attribute__ ((bitwidth(628 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<628 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(628 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<629 + 1024 * 2,true> { int V __attribute__ ((bitwidth(629 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<629 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(629 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<630 + 1024 * 2,true> { int V __attribute__ ((bitwidth(630 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<630 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(630 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<631 + 1024 * 2,true> { int V __attribute__ ((bitwidth(631 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<631 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(631 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<632 + 1024 * 2,true> { int V __attribute__ ((bitwidth(632 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<632 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(632 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<633 + 1024 * 2,true> { int V __attribute__ ((bitwidth(633 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<633 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(633 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<634 + 1024 * 2,true> { int V __attribute__ ((bitwidth(634 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<634 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(634 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<635 + 1024 * 2,true> { int V __attribute__ ((bitwidth(635 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<635 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(635 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<636 + 1024 * 2,true> { int V __attribute__ ((bitwidth(636 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<636 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(636 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<637 + 1024 * 2,true> { int V __attribute__ ((bitwidth(637 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<637 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(637 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<638 + 1024 * 2,true> { int V __attribute__ ((bitwidth(638 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<638 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(638 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<639 + 1024 * 2,true> { int V __attribute__ ((bitwidth(639 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<639 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(639 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<640 + 1024 * 2,true> { int V __attribute__ ((bitwidth(640 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<640 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(640 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<641 + 1024 * 2,true> { int V __attribute__ ((bitwidth(641 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<641 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(641 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<642 + 1024 * 2,true> { int V __attribute__ ((bitwidth(642 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<642 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(642 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<643 + 1024 * 2,true> { int V __attribute__ ((bitwidth(643 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<643 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(643 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<644 + 1024 * 2,true> { int V __attribute__ ((bitwidth(644 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<644 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(644 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<645 + 1024 * 2,true> { int V __attribute__ ((bitwidth(645 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<645 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(645 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<646 + 1024 * 2,true> { int V __attribute__ ((bitwidth(646 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<646 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(646 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<647 + 1024 * 2,true> { int V __attribute__ ((bitwidth(647 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<647 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(647 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<648 + 1024 * 2,true> { int V __attribute__ ((bitwidth(648 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<648 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(648 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<649 + 1024 * 2,true> { int V __attribute__ ((bitwidth(649 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<649 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(649 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<650 + 1024 * 2,true> { int V __attribute__ ((bitwidth(650 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<650 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(650 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<651 + 1024 * 2,true> { int V __attribute__ ((bitwidth(651 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<651 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(651 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<652 + 1024 * 2,true> { int V __attribute__ ((bitwidth(652 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<652 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(652 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<653 + 1024 * 2,true> { int V __attribute__ ((bitwidth(653 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<653 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(653 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<654 + 1024 * 2,true> { int V __attribute__ ((bitwidth(654 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<654 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(654 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<655 + 1024 * 2,true> { int V __attribute__ ((bitwidth(655 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<655 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(655 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<656 + 1024 * 2,true> { int V __attribute__ ((bitwidth(656 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<656 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(656 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<657 + 1024 * 2,true> { int V __attribute__ ((bitwidth(657 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<657 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(657 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<658 + 1024 * 2,true> { int V __attribute__ ((bitwidth(658 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<658 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(658 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<659 + 1024 * 2,true> { int V __attribute__ ((bitwidth(659 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<659 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(659 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<660 + 1024 * 2,true> { int V __attribute__ ((bitwidth(660 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<660 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(660 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<661 + 1024 * 2,true> { int V __attribute__ ((bitwidth(661 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<661 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(661 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<662 + 1024 * 2,true> { int V __attribute__ ((bitwidth(662 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<662 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(662 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<663 + 1024 * 2,true> { int V __attribute__ ((bitwidth(663 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<663 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(663 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<664 + 1024 * 2,true> { int V __attribute__ ((bitwidth(664 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<664 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(664 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<665 + 1024 * 2,true> { int V __attribute__ ((bitwidth(665 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<665 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(665 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<666 + 1024 * 2,true> { int V __attribute__ ((bitwidth(666 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<666 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(666 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<667 + 1024 * 2,true> { int V __attribute__ ((bitwidth(667 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<667 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(667 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<668 + 1024 * 2,true> { int V __attribute__ ((bitwidth(668 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<668 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(668 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<669 + 1024 * 2,true> { int V __attribute__ ((bitwidth(669 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<669 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(669 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<670 + 1024 * 2,true> { int V __attribute__ ((bitwidth(670 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<670 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(670 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<671 + 1024 * 2,true> { int V __attribute__ ((bitwidth(671 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<671 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(671 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<672 + 1024 * 2,true> { int V __attribute__ ((bitwidth(672 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<672 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(672 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<673 + 1024 * 2,true> { int V __attribute__ ((bitwidth(673 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<673 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(673 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<674 + 1024 * 2,true> { int V __attribute__ ((bitwidth(674 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<674 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(674 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<675 + 1024 * 2,true> { int V __attribute__ ((bitwidth(675 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<675 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(675 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<676 + 1024 * 2,true> { int V __attribute__ ((bitwidth(676 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<676 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(676 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<677 + 1024 * 2,true> { int V __attribute__ ((bitwidth(677 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<677 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(677 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<678 + 1024 * 2,true> { int V __attribute__ ((bitwidth(678 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<678 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(678 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<679 + 1024 * 2,true> { int V __attribute__ ((bitwidth(679 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<679 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(679 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<680 + 1024 * 2,true> { int V __attribute__ ((bitwidth(680 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<680 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(680 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<681 + 1024 * 2,true> { int V __attribute__ ((bitwidth(681 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<681 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(681 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<682 + 1024 * 2,true> { int V __attribute__ ((bitwidth(682 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<682 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(682 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<683 + 1024 * 2,true> { int V __attribute__ ((bitwidth(683 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<683 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(683 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<684 + 1024 * 2,true> { int V __attribute__ ((bitwidth(684 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<684 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(684 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<685 + 1024 * 2,true> { int V __attribute__ ((bitwidth(685 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<685 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(685 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<686 + 1024 * 2,true> { int V __attribute__ ((bitwidth(686 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<686 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(686 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<687 + 1024 * 2,true> { int V __attribute__ ((bitwidth(687 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<687 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(687 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<688 + 1024 * 2,true> { int V __attribute__ ((bitwidth(688 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<688 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(688 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<689 + 1024 * 2,true> { int V __attribute__ ((bitwidth(689 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<689 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(689 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<690 + 1024 * 2,true> { int V __attribute__ ((bitwidth(690 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<690 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(690 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<691 + 1024 * 2,true> { int V __attribute__ ((bitwidth(691 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<691 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(691 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<692 + 1024 * 2,true> { int V __attribute__ ((bitwidth(692 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<692 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(692 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<693 + 1024 * 2,true> { int V __attribute__ ((bitwidth(693 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<693 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(693 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<694 + 1024 * 2,true> { int V __attribute__ ((bitwidth(694 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<694 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(694 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<695 + 1024 * 2,true> { int V __attribute__ ((bitwidth(695 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<695 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(695 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<696 + 1024 * 2,true> { int V __attribute__ ((bitwidth(696 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<696 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(696 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<697 + 1024 * 2,true> { int V __attribute__ ((bitwidth(697 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<697 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(697 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<698 + 1024 * 2,true> { int V __attribute__ ((bitwidth(698 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<698 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(698 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<699 + 1024 * 2,true> { int V __attribute__ ((bitwidth(699 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<699 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(699 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<700 + 1024 * 2,true> { int V __attribute__ ((bitwidth(700 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<700 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(700 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<701 + 1024 * 2,true> { int V __attribute__ ((bitwidth(701 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<701 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(701 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<702 + 1024 * 2,true> { int V __attribute__ ((bitwidth(702 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<702 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(702 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<703 + 1024 * 2,true> { int V __attribute__ ((bitwidth(703 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<703 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(703 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<704 + 1024 * 2,true> { int V __attribute__ ((bitwidth(704 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<704 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(704 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<705 + 1024 * 2,true> { int V __attribute__ ((bitwidth(705 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<705 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(705 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<706 + 1024 * 2,true> { int V __attribute__ ((bitwidth(706 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<706 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(706 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<707 + 1024 * 2,true> { int V __attribute__ ((bitwidth(707 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<707 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(707 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<708 + 1024 * 2,true> { int V __attribute__ ((bitwidth(708 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<708 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(708 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<709 + 1024 * 2,true> { int V __attribute__ ((bitwidth(709 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<709 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(709 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<710 + 1024 * 2,true> { int V __attribute__ ((bitwidth(710 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<710 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(710 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<711 + 1024 * 2,true> { int V __attribute__ ((bitwidth(711 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<711 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(711 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<712 + 1024 * 2,true> { int V __attribute__ ((bitwidth(712 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<712 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(712 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<713 + 1024 * 2,true> { int V __attribute__ ((bitwidth(713 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<713 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(713 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<714 + 1024 * 2,true> { int V __attribute__ ((bitwidth(714 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<714 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(714 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<715 + 1024 * 2,true> { int V __attribute__ ((bitwidth(715 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<715 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(715 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<716 + 1024 * 2,true> { int V __attribute__ ((bitwidth(716 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<716 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(716 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<717 + 1024 * 2,true> { int V __attribute__ ((bitwidth(717 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<717 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(717 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<718 + 1024 * 2,true> { int V __attribute__ ((bitwidth(718 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<718 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(718 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<719 + 1024 * 2,true> { int V __attribute__ ((bitwidth(719 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<719 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(719 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<720 + 1024 * 2,true> { int V __attribute__ ((bitwidth(720 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<720 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(720 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<721 + 1024 * 2,true> { int V __attribute__ ((bitwidth(721 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<721 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(721 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<722 + 1024 * 2,true> { int V __attribute__ ((bitwidth(722 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<722 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(722 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<723 + 1024 * 2,true> { int V __attribute__ ((bitwidth(723 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<723 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(723 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<724 + 1024 * 2,true> { int V __attribute__ ((bitwidth(724 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<724 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(724 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<725 + 1024 * 2,true> { int V __attribute__ ((bitwidth(725 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<725 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(725 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<726 + 1024 * 2,true> { int V __attribute__ ((bitwidth(726 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<726 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(726 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<727 + 1024 * 2,true> { int V __attribute__ ((bitwidth(727 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<727 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(727 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<728 + 1024 * 2,true> { int V __attribute__ ((bitwidth(728 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<728 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(728 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<729 + 1024 * 2,true> { int V __attribute__ ((bitwidth(729 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<729 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(729 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<730 + 1024 * 2,true> { int V __attribute__ ((bitwidth(730 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<730 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(730 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<731 + 1024 * 2,true> { int V __attribute__ ((bitwidth(731 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<731 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(731 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<732 + 1024 * 2,true> { int V __attribute__ ((bitwidth(732 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<732 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(732 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<733 + 1024 * 2,true> { int V __attribute__ ((bitwidth(733 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<733 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(733 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<734 + 1024 * 2,true> { int V __attribute__ ((bitwidth(734 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<734 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(734 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<735 + 1024 * 2,true> { int V __attribute__ ((bitwidth(735 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<735 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(735 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<736 + 1024 * 2,true> { int V __attribute__ ((bitwidth(736 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<736 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(736 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<737 + 1024 * 2,true> { int V __attribute__ ((bitwidth(737 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<737 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(737 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<738 + 1024 * 2,true> { int V __attribute__ ((bitwidth(738 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<738 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(738 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<739 + 1024 * 2,true> { int V __attribute__ ((bitwidth(739 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<739 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(739 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<740 + 1024 * 2,true> { int V __attribute__ ((bitwidth(740 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<740 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(740 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<741 + 1024 * 2,true> { int V __attribute__ ((bitwidth(741 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<741 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(741 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<742 + 1024 * 2,true> { int V __attribute__ ((bitwidth(742 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<742 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(742 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<743 + 1024 * 2,true> { int V __attribute__ ((bitwidth(743 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<743 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(743 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<744 + 1024 * 2,true> { int V __attribute__ ((bitwidth(744 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<744 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(744 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<745 + 1024 * 2,true> { int V __attribute__ ((bitwidth(745 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<745 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(745 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<746 + 1024 * 2,true> { int V __attribute__ ((bitwidth(746 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<746 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(746 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<747 + 1024 * 2,true> { int V __attribute__ ((bitwidth(747 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<747 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(747 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<748 + 1024 * 2,true> { int V __attribute__ ((bitwidth(748 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<748 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(748 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<749 + 1024 * 2,true> { int V __attribute__ ((bitwidth(749 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<749 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(749 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<750 + 1024 * 2,true> { int V __attribute__ ((bitwidth(750 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<750 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(750 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<751 + 1024 * 2,true> { int V __attribute__ ((bitwidth(751 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<751 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(751 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<752 + 1024 * 2,true> { int V __attribute__ ((bitwidth(752 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<752 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(752 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<753 + 1024 * 2,true> { int V __attribute__ ((bitwidth(753 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<753 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(753 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<754 + 1024 * 2,true> { int V __attribute__ ((bitwidth(754 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<754 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(754 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<755 + 1024 * 2,true> { int V __attribute__ ((bitwidth(755 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<755 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(755 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<756 + 1024 * 2,true> { int V __attribute__ ((bitwidth(756 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<756 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(756 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<757 + 1024 * 2,true> { int V __attribute__ ((bitwidth(757 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<757 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(757 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<758 + 1024 * 2,true> { int V __attribute__ ((bitwidth(758 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<758 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(758 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<759 + 1024 * 2,true> { int V __attribute__ ((bitwidth(759 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<759 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(759 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<760 + 1024 * 2,true> { int V __attribute__ ((bitwidth(760 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<760 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(760 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<761 + 1024 * 2,true> { int V __attribute__ ((bitwidth(761 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<761 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(761 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<762 + 1024 * 2,true> { int V __attribute__ ((bitwidth(762 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<762 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(762 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<763 + 1024 * 2,true> { int V __attribute__ ((bitwidth(763 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<763 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(763 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<764 + 1024 * 2,true> { int V __attribute__ ((bitwidth(764 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<764 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(764 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<765 + 1024 * 2,true> { int V __attribute__ ((bitwidth(765 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<765 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(765 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<766 + 1024 * 2,true> { int V __attribute__ ((bitwidth(766 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<766 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(766 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<767 + 1024 * 2,true> { int V __attribute__ ((bitwidth(767 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<767 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(767 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<768 + 1024 * 2,true> { int V __attribute__ ((bitwidth(768 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<768 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(768 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<769 + 1024 * 2,true> { int V __attribute__ ((bitwidth(769 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<769 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(769 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<770 + 1024 * 2,true> { int V __attribute__ ((bitwidth(770 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<770 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(770 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<771 + 1024 * 2,true> { int V __attribute__ ((bitwidth(771 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<771 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(771 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<772 + 1024 * 2,true> { int V __attribute__ ((bitwidth(772 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<772 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(772 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<773 + 1024 * 2,true> { int V __attribute__ ((bitwidth(773 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<773 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(773 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<774 + 1024 * 2,true> { int V __attribute__ ((bitwidth(774 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<774 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(774 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<775 + 1024 * 2,true> { int V __attribute__ ((bitwidth(775 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<775 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(775 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<776 + 1024 * 2,true> { int V __attribute__ ((bitwidth(776 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<776 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(776 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<777 + 1024 * 2,true> { int V __attribute__ ((bitwidth(777 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<777 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(777 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<778 + 1024 * 2,true> { int V __attribute__ ((bitwidth(778 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<778 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(778 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<779 + 1024 * 2,true> { int V __attribute__ ((bitwidth(779 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<779 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(779 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<780 + 1024 * 2,true> { int V __attribute__ ((bitwidth(780 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<780 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(780 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<781 + 1024 * 2,true> { int V __attribute__ ((bitwidth(781 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<781 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(781 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<782 + 1024 * 2,true> { int V __attribute__ ((bitwidth(782 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<782 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(782 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<783 + 1024 * 2,true> { int V __attribute__ ((bitwidth(783 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<783 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(783 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<784 + 1024 * 2,true> { int V __attribute__ ((bitwidth(784 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<784 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(784 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<785 + 1024 * 2,true> { int V __attribute__ ((bitwidth(785 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<785 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(785 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<786 + 1024 * 2,true> { int V __attribute__ ((bitwidth(786 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<786 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(786 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<787 + 1024 * 2,true> { int V __attribute__ ((bitwidth(787 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<787 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(787 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<788 + 1024 * 2,true> { int V __attribute__ ((bitwidth(788 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<788 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(788 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<789 + 1024 * 2,true> { int V __attribute__ ((bitwidth(789 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<789 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(789 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<790 + 1024 * 2,true> { int V __attribute__ ((bitwidth(790 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<790 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(790 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<791 + 1024 * 2,true> { int V __attribute__ ((bitwidth(791 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<791 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(791 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<792 + 1024 * 2,true> { int V __attribute__ ((bitwidth(792 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<792 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(792 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<793 + 1024 * 2,true> { int V __attribute__ ((bitwidth(793 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<793 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(793 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<794 + 1024 * 2,true> { int V __attribute__ ((bitwidth(794 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<794 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(794 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<795 + 1024 * 2,true> { int V __attribute__ ((bitwidth(795 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<795 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(795 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<796 + 1024 * 2,true> { int V __attribute__ ((bitwidth(796 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<796 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(796 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<797 + 1024 * 2,true> { int V __attribute__ ((bitwidth(797 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<797 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(797 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<798 + 1024 * 2,true> { int V __attribute__ ((bitwidth(798 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<798 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(798 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<799 + 1024 * 2,true> { int V __attribute__ ((bitwidth(799 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<799 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(799 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<800 + 1024 * 2,true> { int V __attribute__ ((bitwidth(800 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<800 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(800 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<801 + 1024 * 2,true> { int V __attribute__ ((bitwidth(801 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<801 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(801 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<802 + 1024 * 2,true> { int V __attribute__ ((bitwidth(802 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<802 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(802 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<803 + 1024 * 2,true> { int V __attribute__ ((bitwidth(803 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<803 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(803 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<804 + 1024 * 2,true> { int V __attribute__ ((bitwidth(804 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<804 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(804 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<805 + 1024 * 2,true> { int V __attribute__ ((bitwidth(805 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<805 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(805 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<806 + 1024 * 2,true> { int V __attribute__ ((bitwidth(806 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<806 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(806 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<807 + 1024 * 2,true> { int V __attribute__ ((bitwidth(807 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<807 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(807 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<808 + 1024 * 2,true> { int V __attribute__ ((bitwidth(808 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<808 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(808 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<809 + 1024 * 2,true> { int V __attribute__ ((bitwidth(809 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<809 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(809 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<810 + 1024 * 2,true> { int V __attribute__ ((bitwidth(810 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<810 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(810 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<811 + 1024 * 2,true> { int V __attribute__ ((bitwidth(811 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<811 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(811 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<812 + 1024 * 2,true> { int V __attribute__ ((bitwidth(812 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<812 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(812 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<813 + 1024 * 2,true> { int V __attribute__ ((bitwidth(813 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<813 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(813 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<814 + 1024 * 2,true> { int V __attribute__ ((bitwidth(814 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<814 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(814 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<815 + 1024 * 2,true> { int V __attribute__ ((bitwidth(815 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<815 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(815 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<816 + 1024 * 2,true> { int V __attribute__ ((bitwidth(816 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<816 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(816 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<817 + 1024 * 2,true> { int V __attribute__ ((bitwidth(817 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<817 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(817 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<818 + 1024 * 2,true> { int V __attribute__ ((bitwidth(818 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<818 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(818 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<819 + 1024 * 2,true> { int V __attribute__ ((bitwidth(819 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<819 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(819 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<820 + 1024 * 2,true> { int V __attribute__ ((bitwidth(820 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<820 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(820 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<821 + 1024 * 2,true> { int V __attribute__ ((bitwidth(821 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<821 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(821 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<822 + 1024 * 2,true> { int V __attribute__ ((bitwidth(822 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<822 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(822 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<823 + 1024 * 2,true> { int V __attribute__ ((bitwidth(823 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<823 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(823 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<824 + 1024 * 2,true> { int V __attribute__ ((bitwidth(824 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<824 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(824 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<825 + 1024 * 2,true> { int V __attribute__ ((bitwidth(825 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<825 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(825 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<826 + 1024 * 2,true> { int V __attribute__ ((bitwidth(826 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<826 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(826 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<827 + 1024 * 2,true> { int V __attribute__ ((bitwidth(827 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<827 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(827 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<828 + 1024 * 2,true> { int V __attribute__ ((bitwidth(828 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<828 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(828 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<829 + 1024 * 2,true> { int V __attribute__ ((bitwidth(829 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<829 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(829 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<830 + 1024 * 2,true> { int V __attribute__ ((bitwidth(830 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<830 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(830 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<831 + 1024 * 2,true> { int V __attribute__ ((bitwidth(831 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<831 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(831 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<832 + 1024 * 2,true> { int V __attribute__ ((bitwidth(832 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<832 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(832 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<833 + 1024 * 2,true> { int V __attribute__ ((bitwidth(833 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<833 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(833 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<834 + 1024 * 2,true> { int V __attribute__ ((bitwidth(834 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<834 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(834 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<835 + 1024 * 2,true> { int V __attribute__ ((bitwidth(835 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<835 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(835 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<836 + 1024 * 2,true> { int V __attribute__ ((bitwidth(836 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<836 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(836 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<837 + 1024 * 2,true> { int V __attribute__ ((bitwidth(837 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<837 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(837 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<838 + 1024 * 2,true> { int V __attribute__ ((bitwidth(838 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<838 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(838 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<839 + 1024 * 2,true> { int V __attribute__ ((bitwidth(839 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<839 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(839 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<840 + 1024 * 2,true> { int V __attribute__ ((bitwidth(840 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<840 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(840 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<841 + 1024 * 2,true> { int V __attribute__ ((bitwidth(841 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<841 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(841 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<842 + 1024 * 2,true> { int V __attribute__ ((bitwidth(842 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<842 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(842 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<843 + 1024 * 2,true> { int V __attribute__ ((bitwidth(843 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<843 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(843 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<844 + 1024 * 2,true> { int V __attribute__ ((bitwidth(844 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<844 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(844 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<845 + 1024 * 2,true> { int V __attribute__ ((bitwidth(845 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<845 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(845 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<846 + 1024 * 2,true> { int V __attribute__ ((bitwidth(846 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<846 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(846 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<847 + 1024 * 2,true> { int V __attribute__ ((bitwidth(847 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<847 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(847 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<848 + 1024 * 2,true> { int V __attribute__ ((bitwidth(848 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<848 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(848 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<849 + 1024 * 2,true> { int V __attribute__ ((bitwidth(849 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<849 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(849 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<850 + 1024 * 2,true> { int V __attribute__ ((bitwidth(850 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<850 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(850 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<851 + 1024 * 2,true> { int V __attribute__ ((bitwidth(851 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<851 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(851 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<852 + 1024 * 2,true> { int V __attribute__ ((bitwidth(852 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<852 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(852 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<853 + 1024 * 2,true> { int V __attribute__ ((bitwidth(853 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<853 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(853 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<854 + 1024 * 2,true> { int V __attribute__ ((bitwidth(854 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<854 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(854 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<855 + 1024 * 2,true> { int V __attribute__ ((bitwidth(855 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<855 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(855 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<856 + 1024 * 2,true> { int V __attribute__ ((bitwidth(856 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<856 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(856 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<857 + 1024 * 2,true> { int V __attribute__ ((bitwidth(857 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<857 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(857 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<858 + 1024 * 2,true> { int V __attribute__ ((bitwidth(858 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<858 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(858 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<859 + 1024 * 2,true> { int V __attribute__ ((bitwidth(859 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<859 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(859 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<860 + 1024 * 2,true> { int V __attribute__ ((bitwidth(860 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<860 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(860 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<861 + 1024 * 2,true> { int V __attribute__ ((bitwidth(861 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<861 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(861 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<862 + 1024 * 2,true> { int V __attribute__ ((bitwidth(862 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<862 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(862 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<863 + 1024 * 2,true> { int V __attribute__ ((bitwidth(863 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<863 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(863 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<864 + 1024 * 2,true> { int V __attribute__ ((bitwidth(864 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<864 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(864 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<865 + 1024 * 2,true> { int V __attribute__ ((bitwidth(865 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<865 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(865 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<866 + 1024 * 2,true> { int V __attribute__ ((bitwidth(866 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<866 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(866 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<867 + 1024 * 2,true> { int V __attribute__ ((bitwidth(867 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<867 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(867 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<868 + 1024 * 2,true> { int V __attribute__ ((bitwidth(868 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<868 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(868 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<869 + 1024 * 2,true> { int V __attribute__ ((bitwidth(869 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<869 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(869 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<870 + 1024 * 2,true> { int V __attribute__ ((bitwidth(870 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<870 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(870 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<871 + 1024 * 2,true> { int V __attribute__ ((bitwidth(871 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<871 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(871 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<872 + 1024 * 2,true> { int V __attribute__ ((bitwidth(872 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<872 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(872 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<873 + 1024 * 2,true> { int V __attribute__ ((bitwidth(873 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<873 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(873 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<874 + 1024 * 2,true> { int V __attribute__ ((bitwidth(874 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<874 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(874 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<875 + 1024 * 2,true> { int V __attribute__ ((bitwidth(875 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<875 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(875 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<876 + 1024 * 2,true> { int V __attribute__ ((bitwidth(876 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<876 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(876 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<877 + 1024 * 2,true> { int V __attribute__ ((bitwidth(877 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<877 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(877 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<878 + 1024 * 2,true> { int V __attribute__ ((bitwidth(878 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<878 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(878 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<879 + 1024 * 2,true> { int V __attribute__ ((bitwidth(879 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<879 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(879 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<880 + 1024 * 2,true> { int V __attribute__ ((bitwidth(880 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<880 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(880 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<881 + 1024 * 2,true> { int V __attribute__ ((bitwidth(881 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<881 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(881 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<882 + 1024 * 2,true> { int V __attribute__ ((bitwidth(882 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<882 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(882 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<883 + 1024 * 2,true> { int V __attribute__ ((bitwidth(883 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<883 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(883 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<884 + 1024 * 2,true> { int V __attribute__ ((bitwidth(884 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<884 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(884 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<885 + 1024 * 2,true> { int V __attribute__ ((bitwidth(885 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<885 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(885 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<886 + 1024 * 2,true> { int V __attribute__ ((bitwidth(886 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<886 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(886 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<887 + 1024 * 2,true> { int V __attribute__ ((bitwidth(887 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<887 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(887 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<888 + 1024 * 2,true> { int V __attribute__ ((bitwidth(888 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<888 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(888 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<889 + 1024 * 2,true> { int V __attribute__ ((bitwidth(889 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<889 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(889 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<890 + 1024 * 2,true> { int V __attribute__ ((bitwidth(890 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<890 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(890 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<891 + 1024 * 2,true> { int V __attribute__ ((bitwidth(891 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<891 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(891 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<892 + 1024 * 2,true> { int V __attribute__ ((bitwidth(892 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<892 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(892 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<893 + 1024 * 2,true> { int V __attribute__ ((bitwidth(893 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<893 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(893 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<894 + 1024 * 2,true> { int V __attribute__ ((bitwidth(894 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<894 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(894 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<895 + 1024 * 2,true> { int V __attribute__ ((bitwidth(895 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<895 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(895 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<896 + 1024 * 2,true> { int V __attribute__ ((bitwidth(896 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<896 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(896 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<897 + 1024 * 2,true> { int V __attribute__ ((bitwidth(897 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<897 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(897 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<898 + 1024 * 2,true> { int V __attribute__ ((bitwidth(898 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<898 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(898 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<899 + 1024 * 2,true> { int V __attribute__ ((bitwidth(899 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<899 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(899 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<900 + 1024 * 2,true> { int V __attribute__ ((bitwidth(900 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<900 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(900 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<901 + 1024 * 2,true> { int V __attribute__ ((bitwidth(901 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<901 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(901 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<902 + 1024 * 2,true> { int V __attribute__ ((bitwidth(902 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<902 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(902 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<903 + 1024 * 2,true> { int V __attribute__ ((bitwidth(903 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<903 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(903 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<904 + 1024 * 2,true> { int V __attribute__ ((bitwidth(904 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<904 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(904 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<905 + 1024 * 2,true> { int V __attribute__ ((bitwidth(905 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<905 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(905 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<906 + 1024 * 2,true> { int V __attribute__ ((bitwidth(906 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<906 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(906 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<907 + 1024 * 2,true> { int V __attribute__ ((bitwidth(907 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<907 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(907 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<908 + 1024 * 2,true> { int V __attribute__ ((bitwidth(908 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<908 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(908 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<909 + 1024 * 2,true> { int V __attribute__ ((bitwidth(909 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<909 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(909 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<910 + 1024 * 2,true> { int V __attribute__ ((bitwidth(910 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<910 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(910 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<911 + 1024 * 2,true> { int V __attribute__ ((bitwidth(911 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<911 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(911 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<912 + 1024 * 2,true> { int V __attribute__ ((bitwidth(912 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<912 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(912 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<913 + 1024 * 2,true> { int V __attribute__ ((bitwidth(913 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<913 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(913 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<914 + 1024 * 2,true> { int V __attribute__ ((bitwidth(914 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<914 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(914 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<915 + 1024 * 2,true> { int V __attribute__ ((bitwidth(915 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<915 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(915 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<916 + 1024 * 2,true> { int V __attribute__ ((bitwidth(916 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<916 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(916 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<917 + 1024 * 2,true> { int V __attribute__ ((bitwidth(917 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<917 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(917 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<918 + 1024 * 2,true> { int V __attribute__ ((bitwidth(918 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<918 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(918 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<919 + 1024 * 2,true> { int V __attribute__ ((bitwidth(919 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<919 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(919 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<920 + 1024 * 2,true> { int V __attribute__ ((bitwidth(920 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<920 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(920 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<921 + 1024 * 2,true> { int V __attribute__ ((bitwidth(921 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<921 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(921 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<922 + 1024 * 2,true> { int V __attribute__ ((bitwidth(922 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<922 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(922 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<923 + 1024 * 2,true> { int V __attribute__ ((bitwidth(923 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<923 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(923 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<924 + 1024 * 2,true> { int V __attribute__ ((bitwidth(924 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<924 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(924 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<925 + 1024 * 2,true> { int V __attribute__ ((bitwidth(925 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<925 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(925 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<926 + 1024 * 2,true> { int V __attribute__ ((bitwidth(926 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<926 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(926 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<927 + 1024 * 2,true> { int V __attribute__ ((bitwidth(927 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<927 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(927 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<928 + 1024 * 2,true> { int V __attribute__ ((bitwidth(928 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<928 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(928 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<929 + 1024 * 2,true> { int V __attribute__ ((bitwidth(929 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<929 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(929 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<930 + 1024 * 2,true> { int V __attribute__ ((bitwidth(930 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<930 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(930 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<931 + 1024 * 2,true> { int V __attribute__ ((bitwidth(931 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<931 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(931 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<932 + 1024 * 2,true> { int V __attribute__ ((bitwidth(932 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<932 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(932 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<933 + 1024 * 2,true> { int V __attribute__ ((bitwidth(933 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<933 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(933 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<934 + 1024 * 2,true> { int V __attribute__ ((bitwidth(934 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<934 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(934 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<935 + 1024 * 2,true> { int V __attribute__ ((bitwidth(935 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<935 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(935 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<936 + 1024 * 2,true> { int V __attribute__ ((bitwidth(936 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<936 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(936 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<937 + 1024 * 2,true> { int V __attribute__ ((bitwidth(937 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<937 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(937 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<938 + 1024 * 2,true> { int V __attribute__ ((bitwidth(938 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<938 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(938 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<939 + 1024 * 2,true> { int V __attribute__ ((bitwidth(939 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<939 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(939 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<940 + 1024 * 2,true> { int V __attribute__ ((bitwidth(940 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<940 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(940 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<941 + 1024 * 2,true> { int V __attribute__ ((bitwidth(941 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<941 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(941 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<942 + 1024 * 2,true> { int V __attribute__ ((bitwidth(942 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<942 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(942 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<943 + 1024 * 2,true> { int V __attribute__ ((bitwidth(943 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<943 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(943 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<944 + 1024 * 2,true> { int V __attribute__ ((bitwidth(944 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<944 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(944 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<945 + 1024 * 2,true> { int V __attribute__ ((bitwidth(945 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<945 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(945 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<946 + 1024 * 2,true> { int V __attribute__ ((bitwidth(946 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<946 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(946 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<947 + 1024 * 2,true> { int V __attribute__ ((bitwidth(947 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<947 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(947 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<948 + 1024 * 2,true> { int V __attribute__ ((bitwidth(948 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<948 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(948 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<949 + 1024 * 2,true> { int V __attribute__ ((bitwidth(949 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<949 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(949 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<950 + 1024 * 2,true> { int V __attribute__ ((bitwidth(950 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<950 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(950 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<951 + 1024 * 2,true> { int V __attribute__ ((bitwidth(951 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<951 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(951 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<952 + 1024 * 2,true> { int V __attribute__ ((bitwidth(952 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<952 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(952 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<953 + 1024 * 2,true> { int V __attribute__ ((bitwidth(953 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<953 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(953 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<954 + 1024 * 2,true> { int V __attribute__ ((bitwidth(954 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<954 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(954 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<955 + 1024 * 2,true> { int V __attribute__ ((bitwidth(955 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<955 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(955 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<956 + 1024 * 2,true> { int V __attribute__ ((bitwidth(956 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<956 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(956 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<957 + 1024 * 2,true> { int V __attribute__ ((bitwidth(957 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<957 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(957 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<958 + 1024 * 2,true> { int V __attribute__ ((bitwidth(958 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<958 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(958 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<959 + 1024 * 2,true> { int V __attribute__ ((bitwidth(959 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<959 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(959 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<960 + 1024 * 2,true> { int V __attribute__ ((bitwidth(960 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<960 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(960 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<961 + 1024 * 2,true> { int V __attribute__ ((bitwidth(961 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<961 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(961 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<962 + 1024 * 2,true> { int V __attribute__ ((bitwidth(962 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<962 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(962 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<963 + 1024 * 2,true> { int V __attribute__ ((bitwidth(963 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<963 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(963 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<964 + 1024 * 2,true> { int V __attribute__ ((bitwidth(964 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<964 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(964 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<965 + 1024 * 2,true> { int V __attribute__ ((bitwidth(965 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<965 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(965 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<966 + 1024 * 2,true> { int V __attribute__ ((bitwidth(966 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<966 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(966 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<967 + 1024 * 2,true> { int V __attribute__ ((bitwidth(967 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<967 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(967 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<968 + 1024 * 2,true> { int V __attribute__ ((bitwidth(968 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<968 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(968 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<969 + 1024 * 2,true> { int V __attribute__ ((bitwidth(969 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<969 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(969 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<970 + 1024 * 2,true> { int V __attribute__ ((bitwidth(970 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<970 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(970 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<971 + 1024 * 2,true> { int V __attribute__ ((bitwidth(971 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<971 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(971 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<972 + 1024 * 2,true> { int V __attribute__ ((bitwidth(972 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<972 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(972 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<973 + 1024 * 2,true> { int V __attribute__ ((bitwidth(973 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<973 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(973 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<974 + 1024 * 2,true> { int V __attribute__ ((bitwidth(974 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<974 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(974 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<975 + 1024 * 2,true> { int V __attribute__ ((bitwidth(975 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<975 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(975 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<976 + 1024 * 2,true> { int V __attribute__ ((bitwidth(976 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<976 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(976 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<977 + 1024 * 2,true> { int V __attribute__ ((bitwidth(977 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<977 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(977 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<978 + 1024 * 2,true> { int V __attribute__ ((bitwidth(978 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<978 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(978 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<979 + 1024 * 2,true> { int V __attribute__ ((bitwidth(979 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<979 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(979 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<980 + 1024 * 2,true> { int V __attribute__ ((bitwidth(980 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<980 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(980 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<981 + 1024 * 2,true> { int V __attribute__ ((bitwidth(981 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<981 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(981 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<982 + 1024 * 2,true> { int V __attribute__ ((bitwidth(982 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<982 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(982 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<983 + 1024 * 2,true> { int V __attribute__ ((bitwidth(983 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<983 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(983 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<984 + 1024 * 2,true> { int V __attribute__ ((bitwidth(984 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<984 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(984 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<985 + 1024 * 2,true> { int V __attribute__ ((bitwidth(985 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<985 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(985 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<986 + 1024 * 2,true> { int V __attribute__ ((bitwidth(986 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<986 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(986 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<987 + 1024 * 2,true> { int V __attribute__ ((bitwidth(987 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<987 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(987 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<988 + 1024 * 2,true> { int V __attribute__ ((bitwidth(988 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<988 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(988 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<989 + 1024 * 2,true> { int V __attribute__ ((bitwidth(989 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<989 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(989 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<990 + 1024 * 2,true> { int V __attribute__ ((bitwidth(990 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<990 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(990 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<991 + 1024 * 2,true> { int V __attribute__ ((bitwidth(991 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<991 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(991 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<992 + 1024 * 2,true> { int V __attribute__ ((bitwidth(992 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<992 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(992 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<993 + 1024 * 2,true> { int V __attribute__ ((bitwidth(993 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<993 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(993 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<994 + 1024 * 2,true> { int V __attribute__ ((bitwidth(994 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<994 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(994 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<995 + 1024 * 2,true> { int V __attribute__ ((bitwidth(995 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<995 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(995 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<996 + 1024 * 2,true> { int V __attribute__ ((bitwidth(996 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<996 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(996 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<997 + 1024 * 2,true> { int V __attribute__ ((bitwidth(997 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<997 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(997 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<998 + 1024 * 2,true> { int V __attribute__ ((bitwidth(998 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<998 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(998 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<999 + 1024 * 2,true> { int V __attribute__ ((bitwidth(999 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<999 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(999 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1000 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1000 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1000 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1000 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1001 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1001 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1001 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1001 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1002 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1002 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1002 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1002 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1003 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1003 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1003 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1003 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1004 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1004 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1004 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1004 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1005 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1005 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1005 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1005 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1006 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1006 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1006 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1006 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1007 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1007 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1007 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1007 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1008 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1008 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1008 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1008 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1009 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1009 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1009 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1009 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1010 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1010 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1010 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1010 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1011 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1011 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1011 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1011 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1012 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1012 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1012 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1012 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1013 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1013 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1013 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1013 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1014 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1014 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1014 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1014 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1015 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1015 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1015 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1015 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1016 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1016 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1016 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1016 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1017 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1017 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1017 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1017 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1018 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1018 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1018 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1018 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1019 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1019 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1019 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1019 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1020 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1020 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1020 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1020 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1021 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1021 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1021 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1021 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1022 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1022 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1022 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1022 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1023 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1023 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1023 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1023 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 2 , false>() { }; };
template<> struct ssdm_int<1024 + 1024 * 2,true> { int V __attribute__ ((bitwidth(1024 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 2 ,true>() { }; }; template<> struct ssdm_int<1024 + 1024 * 2, false> { unsigned int V __attribute__ ((bitwidth(1024 + 1024 * 2))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 2 , false>() { }; };
#pragma line 149 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_dt.def" 1
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<1 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<2 + 1024 * 3,true> { int V __attribute__ ((bitwidth(2 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<2 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(2 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<3 + 1024 * 3,true> { int V __attribute__ ((bitwidth(3 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<3 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(3 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<4 + 1024 * 3,true> { int V __attribute__ ((bitwidth(4 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<4 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(4 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<5 + 1024 * 3,true> { int V __attribute__ ((bitwidth(5 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<5 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(5 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<6 + 1024 * 3,true> { int V __attribute__ ((bitwidth(6 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<6 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(6 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<7 + 1024 * 3,true> { int V __attribute__ ((bitwidth(7 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<7 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(7 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<8 + 1024 * 3,true> { int V __attribute__ ((bitwidth(8 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<8 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(8 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<9 + 1024 * 3,true> { int V __attribute__ ((bitwidth(9 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<9 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(9 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<10 + 1024 * 3,true> { int V __attribute__ ((bitwidth(10 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<10 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(10 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<11 + 1024 * 3,true> { int V __attribute__ ((bitwidth(11 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<11 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(11 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<12 + 1024 * 3,true> { int V __attribute__ ((bitwidth(12 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<12 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(12 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<13 + 1024 * 3,true> { int V __attribute__ ((bitwidth(13 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<13 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(13 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<14 + 1024 * 3,true> { int V __attribute__ ((bitwidth(14 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<14 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(14 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<15 + 1024 * 3,true> { int V __attribute__ ((bitwidth(15 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<15 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(15 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<16 + 1024 * 3,true> { int V __attribute__ ((bitwidth(16 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<16 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(16 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<17 + 1024 * 3,true> { int V __attribute__ ((bitwidth(17 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<17 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(17 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<18 + 1024 * 3,true> { int V __attribute__ ((bitwidth(18 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<18 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(18 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<19 + 1024 * 3,true> { int V __attribute__ ((bitwidth(19 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<19 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(19 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<20 + 1024 * 3,true> { int V __attribute__ ((bitwidth(20 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<20 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(20 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<21 + 1024 * 3,true> { int V __attribute__ ((bitwidth(21 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<21 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(21 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<22 + 1024 * 3,true> { int V __attribute__ ((bitwidth(22 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<22 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(22 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<23 + 1024 * 3,true> { int V __attribute__ ((bitwidth(23 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<23 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(23 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<24 + 1024 * 3,true> { int V __attribute__ ((bitwidth(24 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<24 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(24 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<25 + 1024 * 3,true> { int V __attribute__ ((bitwidth(25 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<25 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(25 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<26 + 1024 * 3,true> { int V __attribute__ ((bitwidth(26 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<26 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(26 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<27 + 1024 * 3,true> { int V __attribute__ ((bitwidth(27 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<27 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(27 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<28 + 1024 * 3,true> { int V __attribute__ ((bitwidth(28 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<28 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(28 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<29 + 1024 * 3,true> { int V __attribute__ ((bitwidth(29 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<29 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(29 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<30 + 1024 * 3,true> { int V __attribute__ ((bitwidth(30 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<30 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(30 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<31 + 1024 * 3,true> { int V __attribute__ ((bitwidth(31 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<31 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(31 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<32 + 1024 * 3,true> { int V __attribute__ ((bitwidth(32 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<32 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(32 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<33 + 1024 * 3,true> { int V __attribute__ ((bitwidth(33 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<33 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(33 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<34 + 1024 * 3,true> { int V __attribute__ ((bitwidth(34 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<34 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(34 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<35 + 1024 * 3,true> { int V __attribute__ ((bitwidth(35 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<35 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(35 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<36 + 1024 * 3,true> { int V __attribute__ ((bitwidth(36 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<36 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(36 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<37 + 1024 * 3,true> { int V __attribute__ ((bitwidth(37 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<37 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(37 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<38 + 1024 * 3,true> { int V __attribute__ ((bitwidth(38 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<38 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(38 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<39 + 1024 * 3,true> { int V __attribute__ ((bitwidth(39 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<39 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(39 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<40 + 1024 * 3,true> { int V __attribute__ ((bitwidth(40 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<40 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(40 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<41 + 1024 * 3,true> { int V __attribute__ ((bitwidth(41 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<41 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(41 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<42 + 1024 * 3,true> { int V __attribute__ ((bitwidth(42 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<42 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(42 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<43 + 1024 * 3,true> { int V __attribute__ ((bitwidth(43 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<43 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(43 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<44 + 1024 * 3,true> { int V __attribute__ ((bitwidth(44 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<44 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(44 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<45 + 1024 * 3,true> { int V __attribute__ ((bitwidth(45 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<45 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(45 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<46 + 1024 * 3,true> { int V __attribute__ ((bitwidth(46 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<46 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(46 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<47 + 1024 * 3,true> { int V __attribute__ ((bitwidth(47 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<47 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(47 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<48 + 1024 * 3,true> { int V __attribute__ ((bitwidth(48 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<48 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(48 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<49 + 1024 * 3,true> { int V __attribute__ ((bitwidth(49 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<49 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(49 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<50 + 1024 * 3,true> { int V __attribute__ ((bitwidth(50 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<50 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(50 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<51 + 1024 * 3,true> { int V __attribute__ ((bitwidth(51 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<51 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(51 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<52 + 1024 * 3,true> { int V __attribute__ ((bitwidth(52 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<52 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(52 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<53 + 1024 * 3,true> { int V __attribute__ ((bitwidth(53 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<53 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(53 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<54 + 1024 * 3,true> { int V __attribute__ ((bitwidth(54 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<54 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(54 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<55 + 1024 * 3,true> { int V __attribute__ ((bitwidth(55 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<55 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(55 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<56 + 1024 * 3,true> { int V __attribute__ ((bitwidth(56 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<56 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(56 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<57 + 1024 * 3,true> { int V __attribute__ ((bitwidth(57 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<57 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(57 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<58 + 1024 * 3,true> { int V __attribute__ ((bitwidth(58 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<58 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(58 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<59 + 1024 * 3,true> { int V __attribute__ ((bitwidth(59 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<59 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(59 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<60 + 1024 * 3,true> { int V __attribute__ ((bitwidth(60 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<60 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(60 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<61 + 1024 * 3,true> { int V __attribute__ ((bitwidth(61 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<61 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(61 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<62 + 1024 * 3,true> { int V __attribute__ ((bitwidth(62 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<62 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(62 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<63 + 1024 * 3,true> { int V __attribute__ ((bitwidth(63 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<63 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(63 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 3 , false>() { }; };
#pragma empty_line
#pragma empty_line
template<> struct ssdm_int<64 + 1024 * 3,true> { int V __attribute__ ((bitwidth(64 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<64 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(64 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 3 , false>() { }; };
#pragma empty_line
#pragma empty_line
/*#if AUTOPILOT_VERSION >= 1 */
#pragma empty_line
template<> struct ssdm_int<65 + 1024 * 3,true> { int V __attribute__ ((bitwidth(65 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<65 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(65 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<66 + 1024 * 3,true> { int V __attribute__ ((bitwidth(66 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<66 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(66 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<67 + 1024 * 3,true> { int V __attribute__ ((bitwidth(67 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<67 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(67 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<68 + 1024 * 3,true> { int V __attribute__ ((bitwidth(68 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<68 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(68 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<69 + 1024 * 3,true> { int V __attribute__ ((bitwidth(69 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<69 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(69 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<70 + 1024 * 3,true> { int V __attribute__ ((bitwidth(70 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<70 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(70 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<71 + 1024 * 3,true> { int V __attribute__ ((bitwidth(71 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<71 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(71 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<72 + 1024 * 3,true> { int V __attribute__ ((bitwidth(72 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<72 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(72 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<73 + 1024 * 3,true> { int V __attribute__ ((bitwidth(73 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<73 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(73 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<74 + 1024 * 3,true> { int V __attribute__ ((bitwidth(74 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<74 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(74 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<75 + 1024 * 3,true> { int V __attribute__ ((bitwidth(75 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<75 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(75 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<76 + 1024 * 3,true> { int V __attribute__ ((bitwidth(76 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<76 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(76 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<77 + 1024 * 3,true> { int V __attribute__ ((bitwidth(77 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<77 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(77 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<78 + 1024 * 3,true> { int V __attribute__ ((bitwidth(78 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<78 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(78 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<79 + 1024 * 3,true> { int V __attribute__ ((bitwidth(79 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<79 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(79 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<80 + 1024 * 3,true> { int V __attribute__ ((bitwidth(80 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<80 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(80 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<81 + 1024 * 3,true> { int V __attribute__ ((bitwidth(81 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<81 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(81 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<82 + 1024 * 3,true> { int V __attribute__ ((bitwidth(82 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<82 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(82 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<83 + 1024 * 3,true> { int V __attribute__ ((bitwidth(83 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<83 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(83 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<84 + 1024 * 3,true> { int V __attribute__ ((bitwidth(84 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<84 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(84 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<85 + 1024 * 3,true> { int V __attribute__ ((bitwidth(85 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<85 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(85 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<86 + 1024 * 3,true> { int V __attribute__ ((bitwidth(86 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<86 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(86 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<87 + 1024 * 3,true> { int V __attribute__ ((bitwidth(87 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<87 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(87 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<88 + 1024 * 3,true> { int V __attribute__ ((bitwidth(88 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<88 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(88 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<89 + 1024 * 3,true> { int V __attribute__ ((bitwidth(89 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<89 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(89 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<90 + 1024 * 3,true> { int V __attribute__ ((bitwidth(90 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<90 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(90 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<91 + 1024 * 3,true> { int V __attribute__ ((bitwidth(91 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<91 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(91 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<92 + 1024 * 3,true> { int V __attribute__ ((bitwidth(92 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<92 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(92 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<93 + 1024 * 3,true> { int V __attribute__ ((bitwidth(93 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<93 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(93 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<94 + 1024 * 3,true> { int V __attribute__ ((bitwidth(94 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<94 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(94 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<95 + 1024 * 3,true> { int V __attribute__ ((bitwidth(95 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<95 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(95 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<96 + 1024 * 3,true> { int V __attribute__ ((bitwidth(96 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<96 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(96 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<97 + 1024 * 3,true> { int V __attribute__ ((bitwidth(97 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<97 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(97 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<98 + 1024 * 3,true> { int V __attribute__ ((bitwidth(98 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<98 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(98 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<99 + 1024 * 3,true> { int V __attribute__ ((bitwidth(99 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<99 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(99 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<100 + 1024 * 3,true> { int V __attribute__ ((bitwidth(100 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<100 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(100 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<101 + 1024 * 3,true> { int V __attribute__ ((bitwidth(101 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<101 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(101 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<102 + 1024 * 3,true> { int V __attribute__ ((bitwidth(102 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<102 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(102 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<103 + 1024 * 3,true> { int V __attribute__ ((bitwidth(103 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<103 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(103 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<104 + 1024 * 3,true> { int V __attribute__ ((bitwidth(104 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<104 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(104 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<105 + 1024 * 3,true> { int V __attribute__ ((bitwidth(105 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<105 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(105 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<106 + 1024 * 3,true> { int V __attribute__ ((bitwidth(106 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<106 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(106 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<107 + 1024 * 3,true> { int V __attribute__ ((bitwidth(107 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<107 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(107 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<108 + 1024 * 3,true> { int V __attribute__ ((bitwidth(108 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<108 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(108 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<109 + 1024 * 3,true> { int V __attribute__ ((bitwidth(109 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<109 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(109 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<110 + 1024 * 3,true> { int V __attribute__ ((bitwidth(110 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<110 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(110 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<111 + 1024 * 3,true> { int V __attribute__ ((bitwidth(111 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<111 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(111 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<112 + 1024 * 3,true> { int V __attribute__ ((bitwidth(112 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<112 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(112 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<113 + 1024 * 3,true> { int V __attribute__ ((bitwidth(113 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<113 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(113 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<114 + 1024 * 3,true> { int V __attribute__ ((bitwidth(114 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<114 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(114 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<115 + 1024 * 3,true> { int V __attribute__ ((bitwidth(115 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<115 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(115 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<116 + 1024 * 3,true> { int V __attribute__ ((bitwidth(116 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<116 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(116 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<117 + 1024 * 3,true> { int V __attribute__ ((bitwidth(117 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<117 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(117 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<118 + 1024 * 3,true> { int V __attribute__ ((bitwidth(118 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<118 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(118 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<119 + 1024 * 3,true> { int V __attribute__ ((bitwidth(119 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<119 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(119 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<120 + 1024 * 3,true> { int V __attribute__ ((bitwidth(120 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<120 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(120 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<121 + 1024 * 3,true> { int V __attribute__ ((bitwidth(121 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<121 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(121 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<122 + 1024 * 3,true> { int V __attribute__ ((bitwidth(122 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<122 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(122 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<123 + 1024 * 3,true> { int V __attribute__ ((bitwidth(123 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<123 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(123 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<124 + 1024 * 3,true> { int V __attribute__ ((bitwidth(124 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<124 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(124 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<125 + 1024 * 3,true> { int V __attribute__ ((bitwidth(125 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<125 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(125 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<126 + 1024 * 3,true> { int V __attribute__ ((bitwidth(126 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<126 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(126 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<127 + 1024 * 3,true> { int V __attribute__ ((bitwidth(127 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<127 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(127 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<128 + 1024 * 3,true> { int V __attribute__ ((bitwidth(128 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<128 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(128 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 3 , false>() { }; };
#pragma empty_line
/*#endif*/
#pragma empty_line
#pragma empty_line
/*#ifdef EXTENDED_GCC*/
#pragma empty_line
template<> struct ssdm_int<129 + 1024 * 3,true> { int V __attribute__ ((bitwidth(129 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<129 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(129 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<130 + 1024 * 3,true> { int V __attribute__ ((bitwidth(130 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<130 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(130 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<131 + 1024 * 3,true> { int V __attribute__ ((bitwidth(131 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<131 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(131 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<132 + 1024 * 3,true> { int V __attribute__ ((bitwidth(132 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<132 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(132 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<133 + 1024 * 3,true> { int V __attribute__ ((bitwidth(133 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<133 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(133 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<134 + 1024 * 3,true> { int V __attribute__ ((bitwidth(134 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<134 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(134 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<135 + 1024 * 3,true> { int V __attribute__ ((bitwidth(135 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<135 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(135 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<136 + 1024 * 3,true> { int V __attribute__ ((bitwidth(136 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<136 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(136 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<137 + 1024 * 3,true> { int V __attribute__ ((bitwidth(137 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<137 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(137 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<138 + 1024 * 3,true> { int V __attribute__ ((bitwidth(138 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<138 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(138 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<139 + 1024 * 3,true> { int V __attribute__ ((bitwidth(139 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<139 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(139 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<140 + 1024 * 3,true> { int V __attribute__ ((bitwidth(140 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<140 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(140 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<141 + 1024 * 3,true> { int V __attribute__ ((bitwidth(141 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<141 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(141 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<142 + 1024 * 3,true> { int V __attribute__ ((bitwidth(142 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<142 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(142 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<143 + 1024 * 3,true> { int V __attribute__ ((bitwidth(143 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<143 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(143 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<144 + 1024 * 3,true> { int V __attribute__ ((bitwidth(144 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<144 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(144 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<145 + 1024 * 3,true> { int V __attribute__ ((bitwidth(145 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<145 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(145 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<146 + 1024 * 3,true> { int V __attribute__ ((bitwidth(146 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<146 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(146 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<147 + 1024 * 3,true> { int V __attribute__ ((bitwidth(147 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<147 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(147 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<148 + 1024 * 3,true> { int V __attribute__ ((bitwidth(148 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<148 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(148 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<149 + 1024 * 3,true> { int V __attribute__ ((bitwidth(149 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<149 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(149 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<150 + 1024 * 3,true> { int V __attribute__ ((bitwidth(150 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<150 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(150 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<151 + 1024 * 3,true> { int V __attribute__ ((bitwidth(151 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<151 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(151 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<152 + 1024 * 3,true> { int V __attribute__ ((bitwidth(152 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<152 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(152 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<153 + 1024 * 3,true> { int V __attribute__ ((bitwidth(153 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<153 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(153 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<154 + 1024 * 3,true> { int V __attribute__ ((bitwidth(154 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<154 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(154 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<155 + 1024 * 3,true> { int V __attribute__ ((bitwidth(155 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<155 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(155 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<156 + 1024 * 3,true> { int V __attribute__ ((bitwidth(156 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<156 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(156 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<157 + 1024 * 3,true> { int V __attribute__ ((bitwidth(157 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<157 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(157 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<158 + 1024 * 3,true> { int V __attribute__ ((bitwidth(158 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<158 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(158 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<159 + 1024 * 3,true> { int V __attribute__ ((bitwidth(159 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<159 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(159 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<160 + 1024 * 3,true> { int V __attribute__ ((bitwidth(160 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<160 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(160 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<161 + 1024 * 3,true> { int V __attribute__ ((bitwidth(161 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<161 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(161 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<162 + 1024 * 3,true> { int V __attribute__ ((bitwidth(162 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<162 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(162 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<163 + 1024 * 3,true> { int V __attribute__ ((bitwidth(163 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<163 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(163 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<164 + 1024 * 3,true> { int V __attribute__ ((bitwidth(164 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<164 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(164 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<165 + 1024 * 3,true> { int V __attribute__ ((bitwidth(165 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<165 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(165 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<166 + 1024 * 3,true> { int V __attribute__ ((bitwidth(166 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<166 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(166 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<167 + 1024 * 3,true> { int V __attribute__ ((bitwidth(167 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<167 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(167 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<168 + 1024 * 3,true> { int V __attribute__ ((bitwidth(168 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<168 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(168 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<169 + 1024 * 3,true> { int V __attribute__ ((bitwidth(169 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<169 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(169 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<170 + 1024 * 3,true> { int V __attribute__ ((bitwidth(170 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<170 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(170 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<171 + 1024 * 3,true> { int V __attribute__ ((bitwidth(171 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<171 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(171 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<172 + 1024 * 3,true> { int V __attribute__ ((bitwidth(172 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<172 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(172 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<173 + 1024 * 3,true> { int V __attribute__ ((bitwidth(173 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<173 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(173 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<174 + 1024 * 3,true> { int V __attribute__ ((bitwidth(174 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<174 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(174 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<175 + 1024 * 3,true> { int V __attribute__ ((bitwidth(175 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<175 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(175 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<176 + 1024 * 3,true> { int V __attribute__ ((bitwidth(176 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<176 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(176 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<177 + 1024 * 3,true> { int V __attribute__ ((bitwidth(177 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<177 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(177 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<178 + 1024 * 3,true> { int V __attribute__ ((bitwidth(178 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<178 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(178 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<179 + 1024 * 3,true> { int V __attribute__ ((bitwidth(179 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<179 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(179 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<180 + 1024 * 3,true> { int V __attribute__ ((bitwidth(180 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<180 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(180 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<181 + 1024 * 3,true> { int V __attribute__ ((bitwidth(181 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<181 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(181 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<182 + 1024 * 3,true> { int V __attribute__ ((bitwidth(182 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<182 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(182 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<183 + 1024 * 3,true> { int V __attribute__ ((bitwidth(183 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<183 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(183 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<184 + 1024 * 3,true> { int V __attribute__ ((bitwidth(184 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<184 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(184 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<185 + 1024 * 3,true> { int V __attribute__ ((bitwidth(185 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<185 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(185 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<186 + 1024 * 3,true> { int V __attribute__ ((bitwidth(186 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<186 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(186 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<187 + 1024 * 3,true> { int V __attribute__ ((bitwidth(187 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<187 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(187 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<188 + 1024 * 3,true> { int V __attribute__ ((bitwidth(188 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<188 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(188 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<189 + 1024 * 3,true> { int V __attribute__ ((bitwidth(189 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<189 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(189 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<190 + 1024 * 3,true> { int V __attribute__ ((bitwidth(190 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<190 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(190 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<191 + 1024 * 3,true> { int V __attribute__ ((bitwidth(191 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<191 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(191 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<192 + 1024 * 3,true> { int V __attribute__ ((bitwidth(192 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<192 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(192 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<193 + 1024 * 3,true> { int V __attribute__ ((bitwidth(193 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<193 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(193 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<194 + 1024 * 3,true> { int V __attribute__ ((bitwidth(194 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<194 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(194 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<195 + 1024 * 3,true> { int V __attribute__ ((bitwidth(195 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<195 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(195 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<196 + 1024 * 3,true> { int V __attribute__ ((bitwidth(196 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<196 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(196 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<197 + 1024 * 3,true> { int V __attribute__ ((bitwidth(197 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<197 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(197 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<198 + 1024 * 3,true> { int V __attribute__ ((bitwidth(198 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<198 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(198 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<199 + 1024 * 3,true> { int V __attribute__ ((bitwidth(199 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<199 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(199 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<200 + 1024 * 3,true> { int V __attribute__ ((bitwidth(200 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<200 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(200 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<201 + 1024 * 3,true> { int V __attribute__ ((bitwidth(201 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<201 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(201 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<202 + 1024 * 3,true> { int V __attribute__ ((bitwidth(202 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<202 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(202 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<203 + 1024 * 3,true> { int V __attribute__ ((bitwidth(203 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<203 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(203 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<204 + 1024 * 3,true> { int V __attribute__ ((bitwidth(204 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<204 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(204 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<205 + 1024 * 3,true> { int V __attribute__ ((bitwidth(205 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<205 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(205 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<206 + 1024 * 3,true> { int V __attribute__ ((bitwidth(206 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<206 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(206 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<207 + 1024 * 3,true> { int V __attribute__ ((bitwidth(207 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<207 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(207 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<208 + 1024 * 3,true> { int V __attribute__ ((bitwidth(208 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<208 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(208 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<209 + 1024 * 3,true> { int V __attribute__ ((bitwidth(209 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<209 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(209 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<210 + 1024 * 3,true> { int V __attribute__ ((bitwidth(210 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<210 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(210 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<211 + 1024 * 3,true> { int V __attribute__ ((bitwidth(211 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<211 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(211 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<212 + 1024 * 3,true> { int V __attribute__ ((bitwidth(212 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<212 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(212 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<213 + 1024 * 3,true> { int V __attribute__ ((bitwidth(213 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<213 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(213 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<214 + 1024 * 3,true> { int V __attribute__ ((bitwidth(214 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<214 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(214 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<215 + 1024 * 3,true> { int V __attribute__ ((bitwidth(215 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<215 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(215 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<216 + 1024 * 3,true> { int V __attribute__ ((bitwidth(216 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<216 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(216 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<217 + 1024 * 3,true> { int V __attribute__ ((bitwidth(217 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<217 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(217 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<218 + 1024 * 3,true> { int V __attribute__ ((bitwidth(218 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<218 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(218 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<219 + 1024 * 3,true> { int V __attribute__ ((bitwidth(219 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<219 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(219 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<220 + 1024 * 3,true> { int V __attribute__ ((bitwidth(220 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<220 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(220 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<221 + 1024 * 3,true> { int V __attribute__ ((bitwidth(221 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<221 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(221 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<222 + 1024 * 3,true> { int V __attribute__ ((bitwidth(222 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<222 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(222 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<223 + 1024 * 3,true> { int V __attribute__ ((bitwidth(223 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<223 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(223 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<224 + 1024 * 3,true> { int V __attribute__ ((bitwidth(224 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<224 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(224 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<225 + 1024 * 3,true> { int V __attribute__ ((bitwidth(225 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<225 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(225 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<226 + 1024 * 3,true> { int V __attribute__ ((bitwidth(226 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<226 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(226 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<227 + 1024 * 3,true> { int V __attribute__ ((bitwidth(227 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<227 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(227 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<228 + 1024 * 3,true> { int V __attribute__ ((bitwidth(228 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<228 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(228 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<229 + 1024 * 3,true> { int V __attribute__ ((bitwidth(229 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<229 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(229 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<230 + 1024 * 3,true> { int V __attribute__ ((bitwidth(230 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<230 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(230 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<231 + 1024 * 3,true> { int V __attribute__ ((bitwidth(231 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<231 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(231 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<232 + 1024 * 3,true> { int V __attribute__ ((bitwidth(232 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<232 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(232 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<233 + 1024 * 3,true> { int V __attribute__ ((bitwidth(233 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<233 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(233 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<234 + 1024 * 3,true> { int V __attribute__ ((bitwidth(234 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<234 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(234 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<235 + 1024 * 3,true> { int V __attribute__ ((bitwidth(235 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<235 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(235 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<236 + 1024 * 3,true> { int V __attribute__ ((bitwidth(236 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<236 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(236 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<237 + 1024 * 3,true> { int V __attribute__ ((bitwidth(237 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<237 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(237 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<238 + 1024 * 3,true> { int V __attribute__ ((bitwidth(238 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<238 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(238 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<239 + 1024 * 3,true> { int V __attribute__ ((bitwidth(239 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<239 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(239 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<240 + 1024 * 3,true> { int V __attribute__ ((bitwidth(240 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<240 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(240 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<241 + 1024 * 3,true> { int V __attribute__ ((bitwidth(241 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<241 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(241 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<242 + 1024 * 3,true> { int V __attribute__ ((bitwidth(242 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<242 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(242 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<243 + 1024 * 3,true> { int V __attribute__ ((bitwidth(243 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<243 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(243 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<244 + 1024 * 3,true> { int V __attribute__ ((bitwidth(244 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<244 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(244 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<245 + 1024 * 3,true> { int V __attribute__ ((bitwidth(245 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<245 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(245 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<246 + 1024 * 3,true> { int V __attribute__ ((bitwidth(246 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<246 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(246 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<247 + 1024 * 3,true> { int V __attribute__ ((bitwidth(247 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<247 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(247 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<248 + 1024 * 3,true> { int V __attribute__ ((bitwidth(248 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<248 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(248 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<249 + 1024 * 3,true> { int V __attribute__ ((bitwidth(249 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<249 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(249 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<250 + 1024 * 3,true> { int V __attribute__ ((bitwidth(250 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<250 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(250 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<251 + 1024 * 3,true> { int V __attribute__ ((bitwidth(251 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<251 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(251 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<252 + 1024 * 3,true> { int V __attribute__ ((bitwidth(252 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<252 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(252 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<253 + 1024 * 3,true> { int V __attribute__ ((bitwidth(253 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<253 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(253 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<254 + 1024 * 3,true> { int V __attribute__ ((bitwidth(254 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<254 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(254 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<255 + 1024 * 3,true> { int V __attribute__ ((bitwidth(255 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<255 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(255 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<256 + 1024 * 3,true> { int V __attribute__ ((bitwidth(256 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<256 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(256 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<257 + 1024 * 3,true> { int V __attribute__ ((bitwidth(257 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<257 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(257 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<258 + 1024 * 3,true> { int V __attribute__ ((bitwidth(258 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<258 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(258 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<259 + 1024 * 3,true> { int V __attribute__ ((bitwidth(259 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<259 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(259 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<260 + 1024 * 3,true> { int V __attribute__ ((bitwidth(260 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<260 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(260 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<261 + 1024 * 3,true> { int V __attribute__ ((bitwidth(261 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<261 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(261 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<262 + 1024 * 3,true> { int V __attribute__ ((bitwidth(262 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<262 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(262 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<263 + 1024 * 3,true> { int V __attribute__ ((bitwidth(263 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<263 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(263 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<264 + 1024 * 3,true> { int V __attribute__ ((bitwidth(264 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<264 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(264 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<265 + 1024 * 3,true> { int V __attribute__ ((bitwidth(265 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<265 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(265 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<266 + 1024 * 3,true> { int V __attribute__ ((bitwidth(266 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<266 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(266 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<267 + 1024 * 3,true> { int V __attribute__ ((bitwidth(267 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<267 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(267 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<268 + 1024 * 3,true> { int V __attribute__ ((bitwidth(268 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<268 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(268 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<269 + 1024 * 3,true> { int V __attribute__ ((bitwidth(269 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<269 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(269 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<270 + 1024 * 3,true> { int V __attribute__ ((bitwidth(270 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<270 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(270 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<271 + 1024 * 3,true> { int V __attribute__ ((bitwidth(271 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<271 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(271 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<272 + 1024 * 3,true> { int V __attribute__ ((bitwidth(272 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<272 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(272 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<273 + 1024 * 3,true> { int V __attribute__ ((bitwidth(273 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<273 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(273 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<274 + 1024 * 3,true> { int V __attribute__ ((bitwidth(274 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<274 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(274 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<275 + 1024 * 3,true> { int V __attribute__ ((bitwidth(275 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<275 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(275 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<276 + 1024 * 3,true> { int V __attribute__ ((bitwidth(276 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<276 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(276 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<277 + 1024 * 3,true> { int V __attribute__ ((bitwidth(277 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<277 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(277 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<278 + 1024 * 3,true> { int V __attribute__ ((bitwidth(278 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<278 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(278 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<279 + 1024 * 3,true> { int V __attribute__ ((bitwidth(279 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<279 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(279 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<280 + 1024 * 3,true> { int V __attribute__ ((bitwidth(280 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<280 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(280 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<281 + 1024 * 3,true> { int V __attribute__ ((bitwidth(281 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<281 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(281 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<282 + 1024 * 3,true> { int V __attribute__ ((bitwidth(282 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<282 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(282 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<283 + 1024 * 3,true> { int V __attribute__ ((bitwidth(283 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<283 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(283 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<284 + 1024 * 3,true> { int V __attribute__ ((bitwidth(284 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<284 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(284 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<285 + 1024 * 3,true> { int V __attribute__ ((bitwidth(285 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<285 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(285 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<286 + 1024 * 3,true> { int V __attribute__ ((bitwidth(286 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<286 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(286 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<287 + 1024 * 3,true> { int V __attribute__ ((bitwidth(287 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<287 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(287 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<288 + 1024 * 3,true> { int V __attribute__ ((bitwidth(288 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<288 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(288 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<289 + 1024 * 3,true> { int V __attribute__ ((bitwidth(289 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<289 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(289 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<290 + 1024 * 3,true> { int V __attribute__ ((bitwidth(290 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<290 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(290 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<291 + 1024 * 3,true> { int V __attribute__ ((bitwidth(291 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<291 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(291 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<292 + 1024 * 3,true> { int V __attribute__ ((bitwidth(292 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<292 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(292 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<293 + 1024 * 3,true> { int V __attribute__ ((bitwidth(293 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<293 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(293 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<294 + 1024 * 3,true> { int V __attribute__ ((bitwidth(294 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<294 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(294 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<295 + 1024 * 3,true> { int V __attribute__ ((bitwidth(295 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<295 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(295 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<296 + 1024 * 3,true> { int V __attribute__ ((bitwidth(296 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<296 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(296 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<297 + 1024 * 3,true> { int V __attribute__ ((bitwidth(297 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<297 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(297 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<298 + 1024 * 3,true> { int V __attribute__ ((bitwidth(298 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<298 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(298 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<299 + 1024 * 3,true> { int V __attribute__ ((bitwidth(299 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<299 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(299 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<300 + 1024 * 3,true> { int V __attribute__ ((bitwidth(300 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<300 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(300 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<301 + 1024 * 3,true> { int V __attribute__ ((bitwidth(301 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<301 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(301 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<302 + 1024 * 3,true> { int V __attribute__ ((bitwidth(302 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<302 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(302 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<303 + 1024 * 3,true> { int V __attribute__ ((bitwidth(303 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<303 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(303 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<304 + 1024 * 3,true> { int V __attribute__ ((bitwidth(304 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<304 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(304 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<305 + 1024 * 3,true> { int V __attribute__ ((bitwidth(305 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<305 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(305 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<306 + 1024 * 3,true> { int V __attribute__ ((bitwidth(306 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<306 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(306 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<307 + 1024 * 3,true> { int V __attribute__ ((bitwidth(307 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<307 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(307 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<308 + 1024 * 3,true> { int V __attribute__ ((bitwidth(308 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<308 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(308 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<309 + 1024 * 3,true> { int V __attribute__ ((bitwidth(309 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<309 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(309 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<310 + 1024 * 3,true> { int V __attribute__ ((bitwidth(310 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<310 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(310 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<311 + 1024 * 3,true> { int V __attribute__ ((bitwidth(311 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<311 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(311 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<312 + 1024 * 3,true> { int V __attribute__ ((bitwidth(312 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<312 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(312 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<313 + 1024 * 3,true> { int V __attribute__ ((bitwidth(313 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<313 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(313 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<314 + 1024 * 3,true> { int V __attribute__ ((bitwidth(314 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<314 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(314 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<315 + 1024 * 3,true> { int V __attribute__ ((bitwidth(315 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<315 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(315 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<316 + 1024 * 3,true> { int V __attribute__ ((bitwidth(316 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<316 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(316 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<317 + 1024 * 3,true> { int V __attribute__ ((bitwidth(317 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<317 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(317 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<318 + 1024 * 3,true> { int V __attribute__ ((bitwidth(318 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<318 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(318 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<319 + 1024 * 3,true> { int V __attribute__ ((bitwidth(319 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<319 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(319 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<320 + 1024 * 3,true> { int V __attribute__ ((bitwidth(320 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<320 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(320 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<321 + 1024 * 3,true> { int V __attribute__ ((bitwidth(321 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<321 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(321 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<322 + 1024 * 3,true> { int V __attribute__ ((bitwidth(322 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<322 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(322 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<323 + 1024 * 3,true> { int V __attribute__ ((bitwidth(323 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<323 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(323 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<324 + 1024 * 3,true> { int V __attribute__ ((bitwidth(324 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<324 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(324 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<325 + 1024 * 3,true> { int V __attribute__ ((bitwidth(325 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<325 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(325 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<326 + 1024 * 3,true> { int V __attribute__ ((bitwidth(326 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<326 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(326 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<327 + 1024 * 3,true> { int V __attribute__ ((bitwidth(327 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<327 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(327 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<328 + 1024 * 3,true> { int V __attribute__ ((bitwidth(328 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<328 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(328 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<329 + 1024 * 3,true> { int V __attribute__ ((bitwidth(329 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<329 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(329 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<330 + 1024 * 3,true> { int V __attribute__ ((bitwidth(330 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<330 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(330 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<331 + 1024 * 3,true> { int V __attribute__ ((bitwidth(331 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<331 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(331 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<332 + 1024 * 3,true> { int V __attribute__ ((bitwidth(332 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<332 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(332 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<333 + 1024 * 3,true> { int V __attribute__ ((bitwidth(333 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<333 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(333 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<334 + 1024 * 3,true> { int V __attribute__ ((bitwidth(334 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<334 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(334 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<335 + 1024 * 3,true> { int V __attribute__ ((bitwidth(335 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<335 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(335 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<336 + 1024 * 3,true> { int V __attribute__ ((bitwidth(336 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<336 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(336 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<337 + 1024 * 3,true> { int V __attribute__ ((bitwidth(337 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<337 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(337 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<338 + 1024 * 3,true> { int V __attribute__ ((bitwidth(338 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<338 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(338 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<339 + 1024 * 3,true> { int V __attribute__ ((bitwidth(339 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<339 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(339 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<340 + 1024 * 3,true> { int V __attribute__ ((bitwidth(340 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<340 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(340 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<341 + 1024 * 3,true> { int V __attribute__ ((bitwidth(341 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<341 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(341 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<342 + 1024 * 3,true> { int V __attribute__ ((bitwidth(342 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<342 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(342 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<343 + 1024 * 3,true> { int V __attribute__ ((bitwidth(343 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<343 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(343 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<344 + 1024 * 3,true> { int V __attribute__ ((bitwidth(344 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<344 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(344 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<345 + 1024 * 3,true> { int V __attribute__ ((bitwidth(345 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<345 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(345 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<346 + 1024 * 3,true> { int V __attribute__ ((bitwidth(346 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<346 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(346 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<347 + 1024 * 3,true> { int V __attribute__ ((bitwidth(347 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<347 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(347 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<348 + 1024 * 3,true> { int V __attribute__ ((bitwidth(348 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<348 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(348 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<349 + 1024 * 3,true> { int V __attribute__ ((bitwidth(349 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<349 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(349 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<350 + 1024 * 3,true> { int V __attribute__ ((bitwidth(350 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<350 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(350 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<351 + 1024 * 3,true> { int V __attribute__ ((bitwidth(351 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<351 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(351 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<352 + 1024 * 3,true> { int V __attribute__ ((bitwidth(352 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<352 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(352 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<353 + 1024 * 3,true> { int V __attribute__ ((bitwidth(353 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<353 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(353 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<354 + 1024 * 3,true> { int V __attribute__ ((bitwidth(354 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<354 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(354 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<355 + 1024 * 3,true> { int V __attribute__ ((bitwidth(355 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<355 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(355 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<356 + 1024 * 3,true> { int V __attribute__ ((bitwidth(356 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<356 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(356 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<357 + 1024 * 3,true> { int V __attribute__ ((bitwidth(357 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<357 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(357 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<358 + 1024 * 3,true> { int V __attribute__ ((bitwidth(358 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<358 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(358 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<359 + 1024 * 3,true> { int V __attribute__ ((bitwidth(359 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<359 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(359 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<360 + 1024 * 3,true> { int V __attribute__ ((bitwidth(360 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<360 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(360 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<361 + 1024 * 3,true> { int V __attribute__ ((bitwidth(361 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<361 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(361 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<362 + 1024 * 3,true> { int V __attribute__ ((bitwidth(362 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<362 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(362 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<363 + 1024 * 3,true> { int V __attribute__ ((bitwidth(363 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<363 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(363 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<364 + 1024 * 3,true> { int V __attribute__ ((bitwidth(364 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<364 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(364 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<365 + 1024 * 3,true> { int V __attribute__ ((bitwidth(365 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<365 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(365 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<366 + 1024 * 3,true> { int V __attribute__ ((bitwidth(366 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<366 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(366 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<367 + 1024 * 3,true> { int V __attribute__ ((bitwidth(367 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<367 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(367 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<368 + 1024 * 3,true> { int V __attribute__ ((bitwidth(368 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<368 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(368 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<369 + 1024 * 3,true> { int V __attribute__ ((bitwidth(369 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<369 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(369 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<370 + 1024 * 3,true> { int V __attribute__ ((bitwidth(370 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<370 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(370 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<371 + 1024 * 3,true> { int V __attribute__ ((bitwidth(371 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<371 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(371 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<372 + 1024 * 3,true> { int V __attribute__ ((bitwidth(372 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<372 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(372 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<373 + 1024 * 3,true> { int V __attribute__ ((bitwidth(373 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<373 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(373 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<374 + 1024 * 3,true> { int V __attribute__ ((bitwidth(374 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<374 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(374 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<375 + 1024 * 3,true> { int V __attribute__ ((bitwidth(375 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<375 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(375 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<376 + 1024 * 3,true> { int V __attribute__ ((bitwidth(376 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<376 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(376 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<377 + 1024 * 3,true> { int V __attribute__ ((bitwidth(377 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<377 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(377 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<378 + 1024 * 3,true> { int V __attribute__ ((bitwidth(378 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<378 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(378 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<379 + 1024 * 3,true> { int V __attribute__ ((bitwidth(379 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<379 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(379 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<380 + 1024 * 3,true> { int V __attribute__ ((bitwidth(380 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<380 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(380 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<381 + 1024 * 3,true> { int V __attribute__ ((bitwidth(381 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<381 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(381 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<382 + 1024 * 3,true> { int V __attribute__ ((bitwidth(382 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<382 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(382 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<383 + 1024 * 3,true> { int V __attribute__ ((bitwidth(383 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<383 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(383 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<384 + 1024 * 3,true> { int V __attribute__ ((bitwidth(384 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<384 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(384 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<385 + 1024 * 3,true> { int V __attribute__ ((bitwidth(385 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<385 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(385 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<386 + 1024 * 3,true> { int V __attribute__ ((bitwidth(386 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<386 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(386 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<387 + 1024 * 3,true> { int V __attribute__ ((bitwidth(387 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<387 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(387 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<388 + 1024 * 3,true> { int V __attribute__ ((bitwidth(388 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<388 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(388 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<389 + 1024 * 3,true> { int V __attribute__ ((bitwidth(389 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<389 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(389 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<390 + 1024 * 3,true> { int V __attribute__ ((bitwidth(390 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<390 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(390 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<391 + 1024 * 3,true> { int V __attribute__ ((bitwidth(391 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<391 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(391 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<392 + 1024 * 3,true> { int V __attribute__ ((bitwidth(392 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<392 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(392 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<393 + 1024 * 3,true> { int V __attribute__ ((bitwidth(393 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<393 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(393 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<394 + 1024 * 3,true> { int V __attribute__ ((bitwidth(394 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<394 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(394 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<395 + 1024 * 3,true> { int V __attribute__ ((bitwidth(395 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<395 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(395 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<396 + 1024 * 3,true> { int V __attribute__ ((bitwidth(396 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<396 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(396 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<397 + 1024 * 3,true> { int V __attribute__ ((bitwidth(397 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<397 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(397 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<398 + 1024 * 3,true> { int V __attribute__ ((bitwidth(398 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<398 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(398 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<399 + 1024 * 3,true> { int V __attribute__ ((bitwidth(399 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<399 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(399 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<400 + 1024 * 3,true> { int V __attribute__ ((bitwidth(400 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<400 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(400 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<401 + 1024 * 3,true> { int V __attribute__ ((bitwidth(401 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<401 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(401 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<402 + 1024 * 3,true> { int V __attribute__ ((bitwidth(402 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<402 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(402 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<403 + 1024 * 3,true> { int V __attribute__ ((bitwidth(403 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<403 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(403 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<404 + 1024 * 3,true> { int V __attribute__ ((bitwidth(404 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<404 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(404 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<405 + 1024 * 3,true> { int V __attribute__ ((bitwidth(405 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<405 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(405 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<406 + 1024 * 3,true> { int V __attribute__ ((bitwidth(406 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<406 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(406 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<407 + 1024 * 3,true> { int V __attribute__ ((bitwidth(407 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<407 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(407 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<408 + 1024 * 3,true> { int V __attribute__ ((bitwidth(408 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<408 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(408 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<409 + 1024 * 3,true> { int V __attribute__ ((bitwidth(409 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<409 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(409 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<410 + 1024 * 3,true> { int V __attribute__ ((bitwidth(410 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<410 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(410 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<411 + 1024 * 3,true> { int V __attribute__ ((bitwidth(411 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<411 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(411 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<412 + 1024 * 3,true> { int V __attribute__ ((bitwidth(412 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<412 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(412 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<413 + 1024 * 3,true> { int V __attribute__ ((bitwidth(413 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<413 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(413 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<414 + 1024 * 3,true> { int V __attribute__ ((bitwidth(414 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<414 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(414 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<415 + 1024 * 3,true> { int V __attribute__ ((bitwidth(415 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<415 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(415 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<416 + 1024 * 3,true> { int V __attribute__ ((bitwidth(416 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<416 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(416 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<417 + 1024 * 3,true> { int V __attribute__ ((bitwidth(417 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<417 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(417 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<418 + 1024 * 3,true> { int V __attribute__ ((bitwidth(418 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<418 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(418 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<419 + 1024 * 3,true> { int V __attribute__ ((bitwidth(419 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<419 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(419 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<420 + 1024 * 3,true> { int V __attribute__ ((bitwidth(420 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<420 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(420 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<421 + 1024 * 3,true> { int V __attribute__ ((bitwidth(421 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<421 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(421 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<422 + 1024 * 3,true> { int V __attribute__ ((bitwidth(422 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<422 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(422 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<423 + 1024 * 3,true> { int V __attribute__ ((bitwidth(423 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<423 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(423 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<424 + 1024 * 3,true> { int V __attribute__ ((bitwidth(424 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<424 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(424 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<425 + 1024 * 3,true> { int V __attribute__ ((bitwidth(425 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<425 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(425 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<426 + 1024 * 3,true> { int V __attribute__ ((bitwidth(426 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<426 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(426 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<427 + 1024 * 3,true> { int V __attribute__ ((bitwidth(427 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<427 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(427 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<428 + 1024 * 3,true> { int V __attribute__ ((bitwidth(428 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<428 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(428 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<429 + 1024 * 3,true> { int V __attribute__ ((bitwidth(429 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<429 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(429 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<430 + 1024 * 3,true> { int V __attribute__ ((bitwidth(430 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<430 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(430 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<431 + 1024 * 3,true> { int V __attribute__ ((bitwidth(431 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<431 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(431 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<432 + 1024 * 3,true> { int V __attribute__ ((bitwidth(432 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<432 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(432 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<433 + 1024 * 3,true> { int V __attribute__ ((bitwidth(433 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<433 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(433 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<434 + 1024 * 3,true> { int V __attribute__ ((bitwidth(434 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<434 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(434 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<435 + 1024 * 3,true> { int V __attribute__ ((bitwidth(435 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<435 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(435 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<436 + 1024 * 3,true> { int V __attribute__ ((bitwidth(436 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<436 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(436 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<437 + 1024 * 3,true> { int V __attribute__ ((bitwidth(437 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<437 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(437 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<438 + 1024 * 3,true> { int V __attribute__ ((bitwidth(438 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<438 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(438 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<439 + 1024 * 3,true> { int V __attribute__ ((bitwidth(439 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<439 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(439 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<440 + 1024 * 3,true> { int V __attribute__ ((bitwidth(440 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<440 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(440 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<441 + 1024 * 3,true> { int V __attribute__ ((bitwidth(441 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<441 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(441 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<442 + 1024 * 3,true> { int V __attribute__ ((bitwidth(442 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<442 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(442 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<443 + 1024 * 3,true> { int V __attribute__ ((bitwidth(443 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<443 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(443 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<444 + 1024 * 3,true> { int V __attribute__ ((bitwidth(444 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<444 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(444 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<445 + 1024 * 3,true> { int V __attribute__ ((bitwidth(445 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<445 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(445 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<446 + 1024 * 3,true> { int V __attribute__ ((bitwidth(446 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<446 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(446 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<447 + 1024 * 3,true> { int V __attribute__ ((bitwidth(447 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<447 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(447 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<448 + 1024 * 3,true> { int V __attribute__ ((bitwidth(448 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<448 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(448 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<449 + 1024 * 3,true> { int V __attribute__ ((bitwidth(449 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<449 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(449 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<450 + 1024 * 3,true> { int V __attribute__ ((bitwidth(450 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<450 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(450 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<451 + 1024 * 3,true> { int V __attribute__ ((bitwidth(451 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<451 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(451 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<452 + 1024 * 3,true> { int V __attribute__ ((bitwidth(452 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<452 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(452 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<453 + 1024 * 3,true> { int V __attribute__ ((bitwidth(453 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<453 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(453 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<454 + 1024 * 3,true> { int V __attribute__ ((bitwidth(454 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<454 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(454 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<455 + 1024 * 3,true> { int V __attribute__ ((bitwidth(455 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<455 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(455 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<456 + 1024 * 3,true> { int V __attribute__ ((bitwidth(456 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<456 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(456 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<457 + 1024 * 3,true> { int V __attribute__ ((bitwidth(457 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<457 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(457 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<458 + 1024 * 3,true> { int V __attribute__ ((bitwidth(458 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<458 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(458 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<459 + 1024 * 3,true> { int V __attribute__ ((bitwidth(459 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<459 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(459 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<460 + 1024 * 3,true> { int V __attribute__ ((bitwidth(460 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<460 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(460 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<461 + 1024 * 3,true> { int V __attribute__ ((bitwidth(461 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<461 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(461 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<462 + 1024 * 3,true> { int V __attribute__ ((bitwidth(462 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<462 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(462 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<463 + 1024 * 3,true> { int V __attribute__ ((bitwidth(463 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<463 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(463 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<464 + 1024 * 3,true> { int V __attribute__ ((bitwidth(464 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<464 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(464 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<465 + 1024 * 3,true> { int V __attribute__ ((bitwidth(465 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<465 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(465 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<466 + 1024 * 3,true> { int V __attribute__ ((bitwidth(466 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<466 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(466 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<467 + 1024 * 3,true> { int V __attribute__ ((bitwidth(467 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<467 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(467 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<468 + 1024 * 3,true> { int V __attribute__ ((bitwidth(468 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<468 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(468 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<469 + 1024 * 3,true> { int V __attribute__ ((bitwidth(469 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<469 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(469 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<470 + 1024 * 3,true> { int V __attribute__ ((bitwidth(470 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<470 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(470 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<471 + 1024 * 3,true> { int V __attribute__ ((bitwidth(471 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<471 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(471 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<472 + 1024 * 3,true> { int V __attribute__ ((bitwidth(472 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<472 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(472 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<473 + 1024 * 3,true> { int V __attribute__ ((bitwidth(473 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<473 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(473 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<474 + 1024 * 3,true> { int V __attribute__ ((bitwidth(474 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<474 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(474 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<475 + 1024 * 3,true> { int V __attribute__ ((bitwidth(475 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<475 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(475 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<476 + 1024 * 3,true> { int V __attribute__ ((bitwidth(476 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<476 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(476 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<477 + 1024 * 3,true> { int V __attribute__ ((bitwidth(477 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<477 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(477 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<478 + 1024 * 3,true> { int V __attribute__ ((bitwidth(478 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<478 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(478 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<479 + 1024 * 3,true> { int V __attribute__ ((bitwidth(479 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<479 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(479 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<480 + 1024 * 3,true> { int V __attribute__ ((bitwidth(480 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<480 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(480 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<481 + 1024 * 3,true> { int V __attribute__ ((bitwidth(481 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<481 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(481 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<482 + 1024 * 3,true> { int V __attribute__ ((bitwidth(482 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<482 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(482 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<483 + 1024 * 3,true> { int V __attribute__ ((bitwidth(483 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<483 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(483 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<484 + 1024 * 3,true> { int V __attribute__ ((bitwidth(484 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<484 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(484 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<485 + 1024 * 3,true> { int V __attribute__ ((bitwidth(485 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<485 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(485 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<486 + 1024 * 3,true> { int V __attribute__ ((bitwidth(486 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<486 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(486 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<487 + 1024 * 3,true> { int V __attribute__ ((bitwidth(487 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<487 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(487 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<488 + 1024 * 3,true> { int V __attribute__ ((bitwidth(488 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<488 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(488 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<489 + 1024 * 3,true> { int V __attribute__ ((bitwidth(489 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<489 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(489 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<490 + 1024 * 3,true> { int V __attribute__ ((bitwidth(490 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<490 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(490 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<491 + 1024 * 3,true> { int V __attribute__ ((bitwidth(491 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<491 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(491 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<492 + 1024 * 3,true> { int V __attribute__ ((bitwidth(492 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<492 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(492 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<493 + 1024 * 3,true> { int V __attribute__ ((bitwidth(493 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<493 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(493 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<494 + 1024 * 3,true> { int V __attribute__ ((bitwidth(494 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<494 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(494 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<495 + 1024 * 3,true> { int V __attribute__ ((bitwidth(495 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<495 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(495 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<496 + 1024 * 3,true> { int V __attribute__ ((bitwidth(496 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<496 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(496 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<497 + 1024 * 3,true> { int V __attribute__ ((bitwidth(497 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<497 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(497 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<498 + 1024 * 3,true> { int V __attribute__ ((bitwidth(498 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<498 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(498 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<499 + 1024 * 3,true> { int V __attribute__ ((bitwidth(499 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<499 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(499 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<500 + 1024 * 3,true> { int V __attribute__ ((bitwidth(500 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<500 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(500 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<501 + 1024 * 3,true> { int V __attribute__ ((bitwidth(501 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<501 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(501 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<502 + 1024 * 3,true> { int V __attribute__ ((bitwidth(502 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<502 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(502 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<503 + 1024 * 3,true> { int V __attribute__ ((bitwidth(503 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<503 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(503 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<504 + 1024 * 3,true> { int V __attribute__ ((bitwidth(504 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<504 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(504 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<505 + 1024 * 3,true> { int V __attribute__ ((bitwidth(505 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<505 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(505 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<506 + 1024 * 3,true> { int V __attribute__ ((bitwidth(506 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<506 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(506 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<507 + 1024 * 3,true> { int V __attribute__ ((bitwidth(507 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<507 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(507 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<508 + 1024 * 3,true> { int V __attribute__ ((bitwidth(508 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<508 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(508 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<509 + 1024 * 3,true> { int V __attribute__ ((bitwidth(509 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<509 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(509 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<510 + 1024 * 3,true> { int V __attribute__ ((bitwidth(510 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<510 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(510 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<511 + 1024 * 3,true> { int V __attribute__ ((bitwidth(511 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<511 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(511 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<512 + 1024 * 3,true> { int V __attribute__ ((bitwidth(512 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<512 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(512 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<513 + 1024 * 3,true> { int V __attribute__ ((bitwidth(513 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<513 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(513 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<514 + 1024 * 3,true> { int V __attribute__ ((bitwidth(514 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<514 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(514 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<515 + 1024 * 3,true> { int V __attribute__ ((bitwidth(515 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<515 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(515 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<516 + 1024 * 3,true> { int V __attribute__ ((bitwidth(516 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<516 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(516 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<517 + 1024 * 3,true> { int V __attribute__ ((bitwidth(517 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<517 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(517 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<518 + 1024 * 3,true> { int V __attribute__ ((bitwidth(518 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<518 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(518 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<519 + 1024 * 3,true> { int V __attribute__ ((bitwidth(519 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<519 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(519 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<520 + 1024 * 3,true> { int V __attribute__ ((bitwidth(520 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<520 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(520 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<521 + 1024 * 3,true> { int V __attribute__ ((bitwidth(521 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<521 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(521 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<522 + 1024 * 3,true> { int V __attribute__ ((bitwidth(522 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<522 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(522 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<523 + 1024 * 3,true> { int V __attribute__ ((bitwidth(523 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<523 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(523 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<524 + 1024 * 3,true> { int V __attribute__ ((bitwidth(524 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<524 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(524 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<525 + 1024 * 3,true> { int V __attribute__ ((bitwidth(525 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<525 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(525 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<526 + 1024 * 3,true> { int V __attribute__ ((bitwidth(526 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<526 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(526 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<527 + 1024 * 3,true> { int V __attribute__ ((bitwidth(527 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<527 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(527 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<528 + 1024 * 3,true> { int V __attribute__ ((bitwidth(528 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<528 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(528 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<529 + 1024 * 3,true> { int V __attribute__ ((bitwidth(529 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<529 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(529 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<530 + 1024 * 3,true> { int V __attribute__ ((bitwidth(530 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<530 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(530 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<531 + 1024 * 3,true> { int V __attribute__ ((bitwidth(531 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<531 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(531 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<532 + 1024 * 3,true> { int V __attribute__ ((bitwidth(532 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<532 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(532 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<533 + 1024 * 3,true> { int V __attribute__ ((bitwidth(533 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<533 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(533 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<534 + 1024 * 3,true> { int V __attribute__ ((bitwidth(534 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<534 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(534 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<535 + 1024 * 3,true> { int V __attribute__ ((bitwidth(535 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<535 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(535 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<536 + 1024 * 3,true> { int V __attribute__ ((bitwidth(536 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<536 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(536 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<537 + 1024 * 3,true> { int V __attribute__ ((bitwidth(537 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<537 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(537 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<538 + 1024 * 3,true> { int V __attribute__ ((bitwidth(538 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<538 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(538 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<539 + 1024 * 3,true> { int V __attribute__ ((bitwidth(539 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<539 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(539 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<540 + 1024 * 3,true> { int V __attribute__ ((bitwidth(540 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<540 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(540 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<541 + 1024 * 3,true> { int V __attribute__ ((bitwidth(541 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<541 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(541 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<542 + 1024 * 3,true> { int V __attribute__ ((bitwidth(542 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<542 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(542 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<543 + 1024 * 3,true> { int V __attribute__ ((bitwidth(543 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<543 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(543 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<544 + 1024 * 3,true> { int V __attribute__ ((bitwidth(544 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<544 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(544 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<545 + 1024 * 3,true> { int V __attribute__ ((bitwidth(545 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<545 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(545 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<546 + 1024 * 3,true> { int V __attribute__ ((bitwidth(546 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<546 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(546 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<547 + 1024 * 3,true> { int V __attribute__ ((bitwidth(547 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<547 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(547 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<548 + 1024 * 3,true> { int V __attribute__ ((bitwidth(548 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<548 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(548 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<549 + 1024 * 3,true> { int V __attribute__ ((bitwidth(549 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<549 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(549 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<550 + 1024 * 3,true> { int V __attribute__ ((bitwidth(550 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<550 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(550 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<551 + 1024 * 3,true> { int V __attribute__ ((bitwidth(551 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<551 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(551 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<552 + 1024 * 3,true> { int V __attribute__ ((bitwidth(552 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<552 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(552 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<553 + 1024 * 3,true> { int V __attribute__ ((bitwidth(553 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<553 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(553 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<554 + 1024 * 3,true> { int V __attribute__ ((bitwidth(554 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<554 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(554 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<555 + 1024 * 3,true> { int V __attribute__ ((bitwidth(555 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<555 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(555 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<556 + 1024 * 3,true> { int V __attribute__ ((bitwidth(556 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<556 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(556 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<557 + 1024 * 3,true> { int V __attribute__ ((bitwidth(557 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<557 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(557 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<558 + 1024 * 3,true> { int V __attribute__ ((bitwidth(558 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<558 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(558 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<559 + 1024 * 3,true> { int V __attribute__ ((bitwidth(559 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<559 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(559 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<560 + 1024 * 3,true> { int V __attribute__ ((bitwidth(560 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<560 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(560 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<561 + 1024 * 3,true> { int V __attribute__ ((bitwidth(561 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<561 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(561 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<562 + 1024 * 3,true> { int V __attribute__ ((bitwidth(562 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<562 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(562 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<563 + 1024 * 3,true> { int V __attribute__ ((bitwidth(563 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<563 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(563 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<564 + 1024 * 3,true> { int V __attribute__ ((bitwidth(564 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<564 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(564 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<565 + 1024 * 3,true> { int V __attribute__ ((bitwidth(565 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<565 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(565 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<566 + 1024 * 3,true> { int V __attribute__ ((bitwidth(566 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<566 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(566 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<567 + 1024 * 3,true> { int V __attribute__ ((bitwidth(567 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<567 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(567 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<568 + 1024 * 3,true> { int V __attribute__ ((bitwidth(568 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<568 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(568 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<569 + 1024 * 3,true> { int V __attribute__ ((bitwidth(569 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<569 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(569 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<570 + 1024 * 3,true> { int V __attribute__ ((bitwidth(570 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<570 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(570 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<571 + 1024 * 3,true> { int V __attribute__ ((bitwidth(571 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<571 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(571 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<572 + 1024 * 3,true> { int V __attribute__ ((bitwidth(572 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<572 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(572 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<573 + 1024 * 3,true> { int V __attribute__ ((bitwidth(573 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<573 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(573 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<574 + 1024 * 3,true> { int V __attribute__ ((bitwidth(574 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<574 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(574 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<575 + 1024 * 3,true> { int V __attribute__ ((bitwidth(575 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<575 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(575 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<576 + 1024 * 3,true> { int V __attribute__ ((bitwidth(576 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<576 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(576 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<577 + 1024 * 3,true> { int V __attribute__ ((bitwidth(577 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<577 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(577 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<578 + 1024 * 3,true> { int V __attribute__ ((bitwidth(578 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<578 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(578 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<579 + 1024 * 3,true> { int V __attribute__ ((bitwidth(579 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<579 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(579 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<580 + 1024 * 3,true> { int V __attribute__ ((bitwidth(580 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<580 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(580 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<581 + 1024 * 3,true> { int V __attribute__ ((bitwidth(581 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<581 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(581 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<582 + 1024 * 3,true> { int V __attribute__ ((bitwidth(582 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<582 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(582 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<583 + 1024 * 3,true> { int V __attribute__ ((bitwidth(583 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<583 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(583 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<584 + 1024 * 3,true> { int V __attribute__ ((bitwidth(584 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<584 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(584 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<585 + 1024 * 3,true> { int V __attribute__ ((bitwidth(585 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<585 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(585 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<586 + 1024 * 3,true> { int V __attribute__ ((bitwidth(586 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<586 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(586 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<587 + 1024 * 3,true> { int V __attribute__ ((bitwidth(587 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<587 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(587 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<588 + 1024 * 3,true> { int V __attribute__ ((bitwidth(588 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<588 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(588 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<589 + 1024 * 3,true> { int V __attribute__ ((bitwidth(589 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<589 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(589 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<590 + 1024 * 3,true> { int V __attribute__ ((bitwidth(590 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<590 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(590 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<591 + 1024 * 3,true> { int V __attribute__ ((bitwidth(591 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<591 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(591 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<592 + 1024 * 3,true> { int V __attribute__ ((bitwidth(592 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<592 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(592 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<593 + 1024 * 3,true> { int V __attribute__ ((bitwidth(593 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<593 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(593 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<594 + 1024 * 3,true> { int V __attribute__ ((bitwidth(594 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<594 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(594 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<595 + 1024 * 3,true> { int V __attribute__ ((bitwidth(595 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<595 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(595 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<596 + 1024 * 3,true> { int V __attribute__ ((bitwidth(596 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<596 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(596 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<597 + 1024 * 3,true> { int V __attribute__ ((bitwidth(597 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<597 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(597 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<598 + 1024 * 3,true> { int V __attribute__ ((bitwidth(598 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<598 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(598 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<599 + 1024 * 3,true> { int V __attribute__ ((bitwidth(599 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<599 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(599 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<600 + 1024 * 3,true> { int V __attribute__ ((bitwidth(600 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<600 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(600 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<601 + 1024 * 3,true> { int V __attribute__ ((bitwidth(601 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<601 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(601 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<602 + 1024 * 3,true> { int V __attribute__ ((bitwidth(602 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<602 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(602 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<603 + 1024 * 3,true> { int V __attribute__ ((bitwidth(603 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<603 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(603 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<604 + 1024 * 3,true> { int V __attribute__ ((bitwidth(604 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<604 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(604 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<605 + 1024 * 3,true> { int V __attribute__ ((bitwidth(605 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<605 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(605 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<606 + 1024 * 3,true> { int V __attribute__ ((bitwidth(606 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<606 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(606 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<607 + 1024 * 3,true> { int V __attribute__ ((bitwidth(607 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<607 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(607 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<608 + 1024 * 3,true> { int V __attribute__ ((bitwidth(608 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<608 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(608 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<609 + 1024 * 3,true> { int V __attribute__ ((bitwidth(609 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<609 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(609 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<610 + 1024 * 3,true> { int V __attribute__ ((bitwidth(610 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<610 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(610 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<611 + 1024 * 3,true> { int V __attribute__ ((bitwidth(611 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<611 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(611 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<612 + 1024 * 3,true> { int V __attribute__ ((bitwidth(612 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<612 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(612 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<613 + 1024 * 3,true> { int V __attribute__ ((bitwidth(613 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<613 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(613 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<614 + 1024 * 3,true> { int V __attribute__ ((bitwidth(614 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<614 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(614 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<615 + 1024 * 3,true> { int V __attribute__ ((bitwidth(615 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<615 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(615 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<616 + 1024 * 3,true> { int V __attribute__ ((bitwidth(616 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<616 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(616 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<617 + 1024 * 3,true> { int V __attribute__ ((bitwidth(617 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<617 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(617 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<618 + 1024 * 3,true> { int V __attribute__ ((bitwidth(618 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<618 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(618 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<619 + 1024 * 3,true> { int V __attribute__ ((bitwidth(619 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<619 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(619 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<620 + 1024 * 3,true> { int V __attribute__ ((bitwidth(620 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<620 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(620 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<621 + 1024 * 3,true> { int V __attribute__ ((bitwidth(621 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<621 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(621 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<622 + 1024 * 3,true> { int V __attribute__ ((bitwidth(622 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<622 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(622 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<623 + 1024 * 3,true> { int V __attribute__ ((bitwidth(623 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<623 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(623 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<624 + 1024 * 3,true> { int V __attribute__ ((bitwidth(624 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<624 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(624 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<625 + 1024 * 3,true> { int V __attribute__ ((bitwidth(625 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<625 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(625 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<626 + 1024 * 3,true> { int V __attribute__ ((bitwidth(626 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<626 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(626 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<627 + 1024 * 3,true> { int V __attribute__ ((bitwidth(627 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<627 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(627 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<628 + 1024 * 3,true> { int V __attribute__ ((bitwidth(628 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<628 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(628 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<629 + 1024 * 3,true> { int V __attribute__ ((bitwidth(629 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<629 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(629 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<630 + 1024 * 3,true> { int V __attribute__ ((bitwidth(630 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<630 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(630 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<631 + 1024 * 3,true> { int V __attribute__ ((bitwidth(631 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<631 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(631 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<632 + 1024 * 3,true> { int V __attribute__ ((bitwidth(632 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<632 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(632 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<633 + 1024 * 3,true> { int V __attribute__ ((bitwidth(633 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<633 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(633 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<634 + 1024 * 3,true> { int V __attribute__ ((bitwidth(634 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<634 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(634 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<635 + 1024 * 3,true> { int V __attribute__ ((bitwidth(635 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<635 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(635 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<636 + 1024 * 3,true> { int V __attribute__ ((bitwidth(636 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<636 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(636 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<637 + 1024 * 3,true> { int V __attribute__ ((bitwidth(637 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<637 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(637 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<638 + 1024 * 3,true> { int V __attribute__ ((bitwidth(638 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<638 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(638 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<639 + 1024 * 3,true> { int V __attribute__ ((bitwidth(639 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<639 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(639 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<640 + 1024 * 3,true> { int V __attribute__ ((bitwidth(640 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<640 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(640 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<641 + 1024 * 3,true> { int V __attribute__ ((bitwidth(641 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<641 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(641 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<642 + 1024 * 3,true> { int V __attribute__ ((bitwidth(642 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<642 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(642 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<643 + 1024 * 3,true> { int V __attribute__ ((bitwidth(643 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<643 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(643 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<644 + 1024 * 3,true> { int V __attribute__ ((bitwidth(644 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<644 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(644 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<645 + 1024 * 3,true> { int V __attribute__ ((bitwidth(645 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<645 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(645 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<646 + 1024 * 3,true> { int V __attribute__ ((bitwidth(646 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<646 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(646 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<647 + 1024 * 3,true> { int V __attribute__ ((bitwidth(647 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<647 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(647 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<648 + 1024 * 3,true> { int V __attribute__ ((bitwidth(648 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<648 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(648 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<649 + 1024 * 3,true> { int V __attribute__ ((bitwidth(649 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<649 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(649 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<650 + 1024 * 3,true> { int V __attribute__ ((bitwidth(650 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<650 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(650 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<651 + 1024 * 3,true> { int V __attribute__ ((bitwidth(651 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<651 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(651 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<652 + 1024 * 3,true> { int V __attribute__ ((bitwidth(652 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<652 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(652 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<653 + 1024 * 3,true> { int V __attribute__ ((bitwidth(653 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<653 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(653 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<654 + 1024 * 3,true> { int V __attribute__ ((bitwidth(654 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<654 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(654 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<655 + 1024 * 3,true> { int V __attribute__ ((bitwidth(655 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<655 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(655 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<656 + 1024 * 3,true> { int V __attribute__ ((bitwidth(656 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<656 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(656 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<657 + 1024 * 3,true> { int V __attribute__ ((bitwidth(657 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<657 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(657 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<658 + 1024 * 3,true> { int V __attribute__ ((bitwidth(658 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<658 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(658 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<659 + 1024 * 3,true> { int V __attribute__ ((bitwidth(659 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<659 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(659 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<660 + 1024 * 3,true> { int V __attribute__ ((bitwidth(660 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<660 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(660 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<661 + 1024 * 3,true> { int V __attribute__ ((bitwidth(661 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<661 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(661 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<662 + 1024 * 3,true> { int V __attribute__ ((bitwidth(662 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<662 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(662 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<663 + 1024 * 3,true> { int V __attribute__ ((bitwidth(663 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<663 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(663 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<664 + 1024 * 3,true> { int V __attribute__ ((bitwidth(664 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<664 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(664 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<665 + 1024 * 3,true> { int V __attribute__ ((bitwidth(665 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<665 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(665 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<666 + 1024 * 3,true> { int V __attribute__ ((bitwidth(666 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<666 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(666 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<667 + 1024 * 3,true> { int V __attribute__ ((bitwidth(667 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<667 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(667 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<668 + 1024 * 3,true> { int V __attribute__ ((bitwidth(668 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<668 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(668 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<669 + 1024 * 3,true> { int V __attribute__ ((bitwidth(669 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<669 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(669 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<670 + 1024 * 3,true> { int V __attribute__ ((bitwidth(670 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<670 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(670 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<671 + 1024 * 3,true> { int V __attribute__ ((bitwidth(671 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<671 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(671 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<672 + 1024 * 3,true> { int V __attribute__ ((bitwidth(672 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<672 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(672 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<673 + 1024 * 3,true> { int V __attribute__ ((bitwidth(673 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<673 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(673 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<674 + 1024 * 3,true> { int V __attribute__ ((bitwidth(674 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<674 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(674 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<675 + 1024 * 3,true> { int V __attribute__ ((bitwidth(675 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<675 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(675 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<676 + 1024 * 3,true> { int V __attribute__ ((bitwidth(676 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<676 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(676 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<677 + 1024 * 3,true> { int V __attribute__ ((bitwidth(677 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<677 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(677 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<678 + 1024 * 3,true> { int V __attribute__ ((bitwidth(678 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<678 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(678 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<679 + 1024 * 3,true> { int V __attribute__ ((bitwidth(679 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<679 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(679 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<680 + 1024 * 3,true> { int V __attribute__ ((bitwidth(680 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<680 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(680 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<681 + 1024 * 3,true> { int V __attribute__ ((bitwidth(681 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<681 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(681 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<682 + 1024 * 3,true> { int V __attribute__ ((bitwidth(682 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<682 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(682 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<683 + 1024 * 3,true> { int V __attribute__ ((bitwidth(683 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<683 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(683 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<684 + 1024 * 3,true> { int V __attribute__ ((bitwidth(684 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<684 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(684 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<685 + 1024 * 3,true> { int V __attribute__ ((bitwidth(685 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<685 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(685 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<686 + 1024 * 3,true> { int V __attribute__ ((bitwidth(686 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<686 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(686 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<687 + 1024 * 3,true> { int V __attribute__ ((bitwidth(687 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<687 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(687 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<688 + 1024 * 3,true> { int V __attribute__ ((bitwidth(688 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<688 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(688 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<689 + 1024 * 3,true> { int V __attribute__ ((bitwidth(689 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<689 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(689 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<690 + 1024 * 3,true> { int V __attribute__ ((bitwidth(690 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<690 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(690 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<691 + 1024 * 3,true> { int V __attribute__ ((bitwidth(691 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<691 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(691 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<692 + 1024 * 3,true> { int V __attribute__ ((bitwidth(692 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<692 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(692 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<693 + 1024 * 3,true> { int V __attribute__ ((bitwidth(693 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<693 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(693 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<694 + 1024 * 3,true> { int V __attribute__ ((bitwidth(694 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<694 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(694 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<695 + 1024 * 3,true> { int V __attribute__ ((bitwidth(695 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<695 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(695 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<696 + 1024 * 3,true> { int V __attribute__ ((bitwidth(696 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<696 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(696 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<697 + 1024 * 3,true> { int V __attribute__ ((bitwidth(697 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<697 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(697 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<698 + 1024 * 3,true> { int V __attribute__ ((bitwidth(698 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<698 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(698 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<699 + 1024 * 3,true> { int V __attribute__ ((bitwidth(699 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<699 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(699 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<700 + 1024 * 3,true> { int V __attribute__ ((bitwidth(700 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<700 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(700 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<701 + 1024 * 3,true> { int V __attribute__ ((bitwidth(701 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<701 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(701 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<702 + 1024 * 3,true> { int V __attribute__ ((bitwidth(702 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<702 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(702 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<703 + 1024 * 3,true> { int V __attribute__ ((bitwidth(703 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<703 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(703 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<704 + 1024 * 3,true> { int V __attribute__ ((bitwidth(704 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<704 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(704 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<705 + 1024 * 3,true> { int V __attribute__ ((bitwidth(705 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<705 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(705 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<706 + 1024 * 3,true> { int V __attribute__ ((bitwidth(706 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<706 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(706 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<707 + 1024 * 3,true> { int V __attribute__ ((bitwidth(707 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<707 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(707 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<708 + 1024 * 3,true> { int V __attribute__ ((bitwidth(708 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<708 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(708 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<709 + 1024 * 3,true> { int V __attribute__ ((bitwidth(709 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<709 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(709 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<710 + 1024 * 3,true> { int V __attribute__ ((bitwidth(710 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<710 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(710 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<711 + 1024 * 3,true> { int V __attribute__ ((bitwidth(711 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<711 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(711 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<712 + 1024 * 3,true> { int V __attribute__ ((bitwidth(712 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<712 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(712 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<713 + 1024 * 3,true> { int V __attribute__ ((bitwidth(713 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<713 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(713 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<714 + 1024 * 3,true> { int V __attribute__ ((bitwidth(714 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<714 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(714 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<715 + 1024 * 3,true> { int V __attribute__ ((bitwidth(715 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<715 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(715 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<716 + 1024 * 3,true> { int V __attribute__ ((bitwidth(716 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<716 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(716 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<717 + 1024 * 3,true> { int V __attribute__ ((bitwidth(717 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<717 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(717 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<718 + 1024 * 3,true> { int V __attribute__ ((bitwidth(718 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<718 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(718 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<719 + 1024 * 3,true> { int V __attribute__ ((bitwidth(719 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<719 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(719 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<720 + 1024 * 3,true> { int V __attribute__ ((bitwidth(720 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<720 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(720 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<721 + 1024 * 3,true> { int V __attribute__ ((bitwidth(721 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<721 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(721 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<722 + 1024 * 3,true> { int V __attribute__ ((bitwidth(722 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<722 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(722 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<723 + 1024 * 3,true> { int V __attribute__ ((bitwidth(723 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<723 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(723 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<724 + 1024 * 3,true> { int V __attribute__ ((bitwidth(724 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<724 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(724 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<725 + 1024 * 3,true> { int V __attribute__ ((bitwidth(725 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<725 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(725 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<726 + 1024 * 3,true> { int V __attribute__ ((bitwidth(726 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<726 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(726 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<727 + 1024 * 3,true> { int V __attribute__ ((bitwidth(727 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<727 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(727 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<728 + 1024 * 3,true> { int V __attribute__ ((bitwidth(728 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<728 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(728 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<729 + 1024 * 3,true> { int V __attribute__ ((bitwidth(729 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<729 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(729 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<730 + 1024 * 3,true> { int V __attribute__ ((bitwidth(730 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<730 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(730 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<731 + 1024 * 3,true> { int V __attribute__ ((bitwidth(731 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<731 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(731 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<732 + 1024 * 3,true> { int V __attribute__ ((bitwidth(732 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<732 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(732 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<733 + 1024 * 3,true> { int V __attribute__ ((bitwidth(733 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<733 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(733 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<734 + 1024 * 3,true> { int V __attribute__ ((bitwidth(734 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<734 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(734 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<735 + 1024 * 3,true> { int V __attribute__ ((bitwidth(735 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<735 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(735 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<736 + 1024 * 3,true> { int V __attribute__ ((bitwidth(736 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<736 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(736 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<737 + 1024 * 3,true> { int V __attribute__ ((bitwidth(737 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<737 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(737 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<738 + 1024 * 3,true> { int V __attribute__ ((bitwidth(738 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<738 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(738 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<739 + 1024 * 3,true> { int V __attribute__ ((bitwidth(739 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<739 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(739 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<740 + 1024 * 3,true> { int V __attribute__ ((bitwidth(740 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<740 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(740 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<741 + 1024 * 3,true> { int V __attribute__ ((bitwidth(741 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<741 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(741 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<742 + 1024 * 3,true> { int V __attribute__ ((bitwidth(742 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<742 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(742 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<743 + 1024 * 3,true> { int V __attribute__ ((bitwidth(743 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<743 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(743 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<744 + 1024 * 3,true> { int V __attribute__ ((bitwidth(744 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<744 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(744 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<745 + 1024 * 3,true> { int V __attribute__ ((bitwidth(745 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<745 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(745 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<746 + 1024 * 3,true> { int V __attribute__ ((bitwidth(746 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<746 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(746 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<747 + 1024 * 3,true> { int V __attribute__ ((bitwidth(747 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<747 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(747 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<748 + 1024 * 3,true> { int V __attribute__ ((bitwidth(748 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<748 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(748 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<749 + 1024 * 3,true> { int V __attribute__ ((bitwidth(749 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<749 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(749 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<750 + 1024 * 3,true> { int V __attribute__ ((bitwidth(750 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<750 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(750 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<751 + 1024 * 3,true> { int V __attribute__ ((bitwidth(751 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<751 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(751 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<752 + 1024 * 3,true> { int V __attribute__ ((bitwidth(752 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<752 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(752 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<753 + 1024 * 3,true> { int V __attribute__ ((bitwidth(753 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<753 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(753 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<754 + 1024 * 3,true> { int V __attribute__ ((bitwidth(754 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<754 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(754 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<755 + 1024 * 3,true> { int V __attribute__ ((bitwidth(755 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<755 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(755 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<756 + 1024 * 3,true> { int V __attribute__ ((bitwidth(756 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<756 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(756 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<757 + 1024 * 3,true> { int V __attribute__ ((bitwidth(757 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<757 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(757 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<758 + 1024 * 3,true> { int V __attribute__ ((bitwidth(758 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<758 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(758 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<759 + 1024 * 3,true> { int V __attribute__ ((bitwidth(759 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<759 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(759 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<760 + 1024 * 3,true> { int V __attribute__ ((bitwidth(760 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<760 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(760 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<761 + 1024 * 3,true> { int V __attribute__ ((bitwidth(761 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<761 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(761 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<762 + 1024 * 3,true> { int V __attribute__ ((bitwidth(762 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<762 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(762 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<763 + 1024 * 3,true> { int V __attribute__ ((bitwidth(763 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<763 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(763 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<764 + 1024 * 3,true> { int V __attribute__ ((bitwidth(764 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<764 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(764 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<765 + 1024 * 3,true> { int V __attribute__ ((bitwidth(765 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<765 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(765 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<766 + 1024 * 3,true> { int V __attribute__ ((bitwidth(766 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<766 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(766 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<767 + 1024 * 3,true> { int V __attribute__ ((bitwidth(767 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<767 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(767 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<768 + 1024 * 3,true> { int V __attribute__ ((bitwidth(768 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<768 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(768 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<769 + 1024 * 3,true> { int V __attribute__ ((bitwidth(769 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<769 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(769 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<770 + 1024 * 3,true> { int V __attribute__ ((bitwidth(770 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<770 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(770 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<771 + 1024 * 3,true> { int V __attribute__ ((bitwidth(771 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<771 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(771 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<772 + 1024 * 3,true> { int V __attribute__ ((bitwidth(772 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<772 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(772 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<773 + 1024 * 3,true> { int V __attribute__ ((bitwidth(773 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<773 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(773 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<774 + 1024 * 3,true> { int V __attribute__ ((bitwidth(774 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<774 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(774 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<775 + 1024 * 3,true> { int V __attribute__ ((bitwidth(775 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<775 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(775 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<776 + 1024 * 3,true> { int V __attribute__ ((bitwidth(776 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<776 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(776 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<777 + 1024 * 3,true> { int V __attribute__ ((bitwidth(777 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<777 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(777 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<778 + 1024 * 3,true> { int V __attribute__ ((bitwidth(778 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<778 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(778 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<779 + 1024 * 3,true> { int V __attribute__ ((bitwidth(779 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<779 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(779 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<780 + 1024 * 3,true> { int V __attribute__ ((bitwidth(780 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<780 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(780 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<781 + 1024 * 3,true> { int V __attribute__ ((bitwidth(781 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<781 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(781 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<782 + 1024 * 3,true> { int V __attribute__ ((bitwidth(782 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<782 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(782 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<783 + 1024 * 3,true> { int V __attribute__ ((bitwidth(783 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<783 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(783 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<784 + 1024 * 3,true> { int V __attribute__ ((bitwidth(784 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<784 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(784 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<785 + 1024 * 3,true> { int V __attribute__ ((bitwidth(785 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<785 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(785 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<786 + 1024 * 3,true> { int V __attribute__ ((bitwidth(786 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<786 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(786 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<787 + 1024 * 3,true> { int V __attribute__ ((bitwidth(787 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<787 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(787 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<788 + 1024 * 3,true> { int V __attribute__ ((bitwidth(788 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<788 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(788 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<789 + 1024 * 3,true> { int V __attribute__ ((bitwidth(789 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<789 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(789 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<790 + 1024 * 3,true> { int V __attribute__ ((bitwidth(790 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<790 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(790 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<791 + 1024 * 3,true> { int V __attribute__ ((bitwidth(791 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<791 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(791 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<792 + 1024 * 3,true> { int V __attribute__ ((bitwidth(792 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<792 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(792 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<793 + 1024 * 3,true> { int V __attribute__ ((bitwidth(793 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<793 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(793 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<794 + 1024 * 3,true> { int V __attribute__ ((bitwidth(794 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<794 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(794 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<795 + 1024 * 3,true> { int V __attribute__ ((bitwidth(795 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<795 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(795 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<796 + 1024 * 3,true> { int V __attribute__ ((bitwidth(796 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<796 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(796 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<797 + 1024 * 3,true> { int V __attribute__ ((bitwidth(797 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<797 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(797 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<798 + 1024 * 3,true> { int V __attribute__ ((bitwidth(798 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<798 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(798 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<799 + 1024 * 3,true> { int V __attribute__ ((bitwidth(799 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<799 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(799 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<800 + 1024 * 3,true> { int V __attribute__ ((bitwidth(800 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<800 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(800 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<801 + 1024 * 3,true> { int V __attribute__ ((bitwidth(801 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<801 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(801 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<802 + 1024 * 3,true> { int V __attribute__ ((bitwidth(802 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<802 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(802 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<803 + 1024 * 3,true> { int V __attribute__ ((bitwidth(803 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<803 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(803 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<804 + 1024 * 3,true> { int V __attribute__ ((bitwidth(804 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<804 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(804 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<805 + 1024 * 3,true> { int V __attribute__ ((bitwidth(805 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<805 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(805 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<806 + 1024 * 3,true> { int V __attribute__ ((bitwidth(806 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<806 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(806 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<807 + 1024 * 3,true> { int V __attribute__ ((bitwidth(807 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<807 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(807 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<808 + 1024 * 3,true> { int V __attribute__ ((bitwidth(808 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<808 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(808 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<809 + 1024 * 3,true> { int V __attribute__ ((bitwidth(809 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<809 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(809 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<810 + 1024 * 3,true> { int V __attribute__ ((bitwidth(810 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<810 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(810 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<811 + 1024 * 3,true> { int V __attribute__ ((bitwidth(811 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<811 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(811 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<812 + 1024 * 3,true> { int V __attribute__ ((bitwidth(812 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<812 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(812 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<813 + 1024 * 3,true> { int V __attribute__ ((bitwidth(813 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<813 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(813 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<814 + 1024 * 3,true> { int V __attribute__ ((bitwidth(814 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<814 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(814 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<815 + 1024 * 3,true> { int V __attribute__ ((bitwidth(815 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<815 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(815 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<816 + 1024 * 3,true> { int V __attribute__ ((bitwidth(816 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<816 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(816 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<817 + 1024 * 3,true> { int V __attribute__ ((bitwidth(817 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<817 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(817 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<818 + 1024 * 3,true> { int V __attribute__ ((bitwidth(818 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<818 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(818 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<819 + 1024 * 3,true> { int V __attribute__ ((bitwidth(819 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<819 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(819 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<820 + 1024 * 3,true> { int V __attribute__ ((bitwidth(820 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<820 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(820 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<821 + 1024 * 3,true> { int V __attribute__ ((bitwidth(821 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<821 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(821 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<822 + 1024 * 3,true> { int V __attribute__ ((bitwidth(822 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<822 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(822 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<823 + 1024 * 3,true> { int V __attribute__ ((bitwidth(823 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<823 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(823 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<824 + 1024 * 3,true> { int V __attribute__ ((bitwidth(824 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<824 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(824 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<825 + 1024 * 3,true> { int V __attribute__ ((bitwidth(825 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<825 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(825 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<826 + 1024 * 3,true> { int V __attribute__ ((bitwidth(826 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<826 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(826 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<827 + 1024 * 3,true> { int V __attribute__ ((bitwidth(827 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<827 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(827 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<828 + 1024 * 3,true> { int V __attribute__ ((bitwidth(828 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<828 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(828 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<829 + 1024 * 3,true> { int V __attribute__ ((bitwidth(829 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<829 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(829 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<830 + 1024 * 3,true> { int V __attribute__ ((bitwidth(830 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<830 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(830 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<831 + 1024 * 3,true> { int V __attribute__ ((bitwidth(831 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<831 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(831 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<832 + 1024 * 3,true> { int V __attribute__ ((bitwidth(832 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<832 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(832 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<833 + 1024 * 3,true> { int V __attribute__ ((bitwidth(833 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<833 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(833 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<834 + 1024 * 3,true> { int V __attribute__ ((bitwidth(834 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<834 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(834 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<835 + 1024 * 3,true> { int V __attribute__ ((bitwidth(835 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<835 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(835 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<836 + 1024 * 3,true> { int V __attribute__ ((bitwidth(836 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<836 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(836 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<837 + 1024 * 3,true> { int V __attribute__ ((bitwidth(837 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<837 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(837 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<838 + 1024 * 3,true> { int V __attribute__ ((bitwidth(838 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<838 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(838 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<839 + 1024 * 3,true> { int V __attribute__ ((bitwidth(839 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<839 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(839 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<840 + 1024 * 3,true> { int V __attribute__ ((bitwidth(840 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<840 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(840 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<841 + 1024 * 3,true> { int V __attribute__ ((bitwidth(841 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<841 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(841 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<842 + 1024 * 3,true> { int V __attribute__ ((bitwidth(842 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<842 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(842 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<843 + 1024 * 3,true> { int V __attribute__ ((bitwidth(843 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<843 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(843 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<844 + 1024 * 3,true> { int V __attribute__ ((bitwidth(844 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<844 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(844 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<845 + 1024 * 3,true> { int V __attribute__ ((bitwidth(845 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<845 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(845 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<846 + 1024 * 3,true> { int V __attribute__ ((bitwidth(846 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<846 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(846 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<847 + 1024 * 3,true> { int V __attribute__ ((bitwidth(847 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<847 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(847 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<848 + 1024 * 3,true> { int V __attribute__ ((bitwidth(848 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<848 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(848 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<849 + 1024 * 3,true> { int V __attribute__ ((bitwidth(849 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<849 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(849 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<850 + 1024 * 3,true> { int V __attribute__ ((bitwidth(850 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<850 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(850 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<851 + 1024 * 3,true> { int V __attribute__ ((bitwidth(851 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<851 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(851 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<852 + 1024 * 3,true> { int V __attribute__ ((bitwidth(852 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<852 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(852 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<853 + 1024 * 3,true> { int V __attribute__ ((bitwidth(853 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<853 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(853 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<854 + 1024 * 3,true> { int V __attribute__ ((bitwidth(854 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<854 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(854 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<855 + 1024 * 3,true> { int V __attribute__ ((bitwidth(855 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<855 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(855 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<856 + 1024 * 3,true> { int V __attribute__ ((bitwidth(856 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<856 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(856 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<857 + 1024 * 3,true> { int V __attribute__ ((bitwidth(857 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<857 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(857 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<858 + 1024 * 3,true> { int V __attribute__ ((bitwidth(858 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<858 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(858 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<859 + 1024 * 3,true> { int V __attribute__ ((bitwidth(859 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<859 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(859 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<860 + 1024 * 3,true> { int V __attribute__ ((bitwidth(860 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<860 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(860 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<861 + 1024 * 3,true> { int V __attribute__ ((bitwidth(861 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<861 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(861 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<862 + 1024 * 3,true> { int V __attribute__ ((bitwidth(862 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<862 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(862 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<863 + 1024 * 3,true> { int V __attribute__ ((bitwidth(863 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<863 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(863 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<864 + 1024 * 3,true> { int V __attribute__ ((bitwidth(864 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<864 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(864 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<865 + 1024 * 3,true> { int V __attribute__ ((bitwidth(865 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<865 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(865 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<866 + 1024 * 3,true> { int V __attribute__ ((bitwidth(866 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<866 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(866 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<867 + 1024 * 3,true> { int V __attribute__ ((bitwidth(867 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<867 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(867 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<868 + 1024 * 3,true> { int V __attribute__ ((bitwidth(868 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<868 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(868 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<869 + 1024 * 3,true> { int V __attribute__ ((bitwidth(869 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<869 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(869 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<870 + 1024 * 3,true> { int V __attribute__ ((bitwidth(870 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<870 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(870 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<871 + 1024 * 3,true> { int V __attribute__ ((bitwidth(871 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<871 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(871 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<872 + 1024 * 3,true> { int V __attribute__ ((bitwidth(872 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<872 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(872 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<873 + 1024 * 3,true> { int V __attribute__ ((bitwidth(873 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<873 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(873 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<874 + 1024 * 3,true> { int V __attribute__ ((bitwidth(874 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<874 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(874 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<875 + 1024 * 3,true> { int V __attribute__ ((bitwidth(875 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<875 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(875 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<876 + 1024 * 3,true> { int V __attribute__ ((bitwidth(876 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<876 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(876 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<877 + 1024 * 3,true> { int V __attribute__ ((bitwidth(877 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<877 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(877 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<878 + 1024 * 3,true> { int V __attribute__ ((bitwidth(878 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<878 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(878 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<879 + 1024 * 3,true> { int V __attribute__ ((bitwidth(879 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<879 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(879 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<880 + 1024 * 3,true> { int V __attribute__ ((bitwidth(880 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<880 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(880 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<881 + 1024 * 3,true> { int V __attribute__ ((bitwidth(881 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<881 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(881 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<882 + 1024 * 3,true> { int V __attribute__ ((bitwidth(882 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<882 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(882 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<883 + 1024 * 3,true> { int V __attribute__ ((bitwidth(883 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<883 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(883 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<884 + 1024 * 3,true> { int V __attribute__ ((bitwidth(884 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<884 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(884 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<885 + 1024 * 3,true> { int V __attribute__ ((bitwidth(885 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<885 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(885 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<886 + 1024 * 3,true> { int V __attribute__ ((bitwidth(886 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<886 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(886 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<887 + 1024 * 3,true> { int V __attribute__ ((bitwidth(887 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<887 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(887 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<888 + 1024 * 3,true> { int V __attribute__ ((bitwidth(888 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<888 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(888 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<889 + 1024 * 3,true> { int V __attribute__ ((bitwidth(889 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<889 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(889 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<890 + 1024 * 3,true> { int V __attribute__ ((bitwidth(890 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<890 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(890 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<891 + 1024 * 3,true> { int V __attribute__ ((bitwidth(891 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<891 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(891 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<892 + 1024 * 3,true> { int V __attribute__ ((bitwidth(892 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<892 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(892 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<893 + 1024 * 3,true> { int V __attribute__ ((bitwidth(893 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<893 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(893 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<894 + 1024 * 3,true> { int V __attribute__ ((bitwidth(894 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<894 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(894 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<895 + 1024 * 3,true> { int V __attribute__ ((bitwidth(895 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<895 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(895 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<896 + 1024 * 3,true> { int V __attribute__ ((bitwidth(896 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<896 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(896 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<897 + 1024 * 3,true> { int V __attribute__ ((bitwidth(897 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<897 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(897 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<898 + 1024 * 3,true> { int V __attribute__ ((bitwidth(898 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<898 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(898 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<899 + 1024 * 3,true> { int V __attribute__ ((bitwidth(899 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<899 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(899 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<900 + 1024 * 3,true> { int V __attribute__ ((bitwidth(900 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<900 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(900 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<901 + 1024 * 3,true> { int V __attribute__ ((bitwidth(901 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<901 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(901 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<902 + 1024 * 3,true> { int V __attribute__ ((bitwidth(902 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<902 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(902 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<903 + 1024 * 3,true> { int V __attribute__ ((bitwidth(903 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<903 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(903 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<904 + 1024 * 3,true> { int V __attribute__ ((bitwidth(904 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<904 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(904 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<905 + 1024 * 3,true> { int V __attribute__ ((bitwidth(905 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<905 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(905 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<906 + 1024 * 3,true> { int V __attribute__ ((bitwidth(906 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<906 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(906 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<907 + 1024 * 3,true> { int V __attribute__ ((bitwidth(907 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<907 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(907 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<908 + 1024 * 3,true> { int V __attribute__ ((bitwidth(908 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<908 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(908 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<909 + 1024 * 3,true> { int V __attribute__ ((bitwidth(909 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<909 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(909 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<910 + 1024 * 3,true> { int V __attribute__ ((bitwidth(910 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<910 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(910 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<911 + 1024 * 3,true> { int V __attribute__ ((bitwidth(911 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<911 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(911 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<912 + 1024 * 3,true> { int V __attribute__ ((bitwidth(912 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<912 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(912 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<913 + 1024 * 3,true> { int V __attribute__ ((bitwidth(913 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<913 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(913 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<914 + 1024 * 3,true> { int V __attribute__ ((bitwidth(914 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<914 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(914 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<915 + 1024 * 3,true> { int V __attribute__ ((bitwidth(915 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<915 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(915 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<916 + 1024 * 3,true> { int V __attribute__ ((bitwidth(916 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<916 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(916 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<917 + 1024 * 3,true> { int V __attribute__ ((bitwidth(917 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<917 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(917 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<918 + 1024 * 3,true> { int V __attribute__ ((bitwidth(918 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<918 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(918 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<919 + 1024 * 3,true> { int V __attribute__ ((bitwidth(919 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<919 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(919 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<920 + 1024 * 3,true> { int V __attribute__ ((bitwidth(920 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<920 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(920 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<921 + 1024 * 3,true> { int V __attribute__ ((bitwidth(921 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<921 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(921 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<922 + 1024 * 3,true> { int V __attribute__ ((bitwidth(922 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<922 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(922 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<923 + 1024 * 3,true> { int V __attribute__ ((bitwidth(923 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<923 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(923 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<924 + 1024 * 3,true> { int V __attribute__ ((bitwidth(924 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<924 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(924 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<925 + 1024 * 3,true> { int V __attribute__ ((bitwidth(925 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<925 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(925 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<926 + 1024 * 3,true> { int V __attribute__ ((bitwidth(926 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<926 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(926 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<927 + 1024 * 3,true> { int V __attribute__ ((bitwidth(927 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<927 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(927 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<928 + 1024 * 3,true> { int V __attribute__ ((bitwidth(928 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<928 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(928 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<929 + 1024 * 3,true> { int V __attribute__ ((bitwidth(929 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<929 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(929 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<930 + 1024 * 3,true> { int V __attribute__ ((bitwidth(930 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<930 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(930 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<931 + 1024 * 3,true> { int V __attribute__ ((bitwidth(931 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<931 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(931 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<932 + 1024 * 3,true> { int V __attribute__ ((bitwidth(932 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<932 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(932 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<933 + 1024 * 3,true> { int V __attribute__ ((bitwidth(933 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<933 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(933 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<934 + 1024 * 3,true> { int V __attribute__ ((bitwidth(934 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<934 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(934 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<935 + 1024 * 3,true> { int V __attribute__ ((bitwidth(935 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<935 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(935 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<936 + 1024 * 3,true> { int V __attribute__ ((bitwidth(936 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<936 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(936 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<937 + 1024 * 3,true> { int V __attribute__ ((bitwidth(937 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<937 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(937 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<938 + 1024 * 3,true> { int V __attribute__ ((bitwidth(938 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<938 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(938 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<939 + 1024 * 3,true> { int V __attribute__ ((bitwidth(939 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<939 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(939 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<940 + 1024 * 3,true> { int V __attribute__ ((bitwidth(940 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<940 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(940 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<941 + 1024 * 3,true> { int V __attribute__ ((bitwidth(941 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<941 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(941 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<942 + 1024 * 3,true> { int V __attribute__ ((bitwidth(942 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<942 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(942 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<943 + 1024 * 3,true> { int V __attribute__ ((bitwidth(943 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<943 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(943 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<944 + 1024 * 3,true> { int V __attribute__ ((bitwidth(944 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<944 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(944 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<945 + 1024 * 3,true> { int V __attribute__ ((bitwidth(945 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<945 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(945 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<946 + 1024 * 3,true> { int V __attribute__ ((bitwidth(946 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<946 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(946 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<947 + 1024 * 3,true> { int V __attribute__ ((bitwidth(947 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<947 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(947 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<948 + 1024 * 3,true> { int V __attribute__ ((bitwidth(948 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<948 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(948 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<949 + 1024 * 3,true> { int V __attribute__ ((bitwidth(949 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<949 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(949 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<950 + 1024 * 3,true> { int V __attribute__ ((bitwidth(950 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<950 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(950 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<951 + 1024 * 3,true> { int V __attribute__ ((bitwidth(951 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<951 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(951 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<952 + 1024 * 3,true> { int V __attribute__ ((bitwidth(952 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<952 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(952 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<953 + 1024 * 3,true> { int V __attribute__ ((bitwidth(953 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<953 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(953 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<954 + 1024 * 3,true> { int V __attribute__ ((bitwidth(954 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<954 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(954 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<955 + 1024 * 3,true> { int V __attribute__ ((bitwidth(955 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<955 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(955 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<956 + 1024 * 3,true> { int V __attribute__ ((bitwidth(956 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<956 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(956 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<957 + 1024 * 3,true> { int V __attribute__ ((bitwidth(957 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<957 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(957 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<958 + 1024 * 3,true> { int V __attribute__ ((bitwidth(958 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<958 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(958 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<959 + 1024 * 3,true> { int V __attribute__ ((bitwidth(959 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<959 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(959 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<960 + 1024 * 3,true> { int V __attribute__ ((bitwidth(960 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<960 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(960 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<961 + 1024 * 3,true> { int V __attribute__ ((bitwidth(961 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<961 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(961 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<962 + 1024 * 3,true> { int V __attribute__ ((bitwidth(962 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<962 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(962 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<963 + 1024 * 3,true> { int V __attribute__ ((bitwidth(963 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<963 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(963 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<964 + 1024 * 3,true> { int V __attribute__ ((bitwidth(964 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<964 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(964 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<965 + 1024 * 3,true> { int V __attribute__ ((bitwidth(965 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<965 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(965 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<966 + 1024 * 3,true> { int V __attribute__ ((bitwidth(966 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<966 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(966 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<967 + 1024 * 3,true> { int V __attribute__ ((bitwidth(967 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<967 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(967 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<968 + 1024 * 3,true> { int V __attribute__ ((bitwidth(968 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<968 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(968 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<969 + 1024 * 3,true> { int V __attribute__ ((bitwidth(969 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<969 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(969 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<970 + 1024 * 3,true> { int V __attribute__ ((bitwidth(970 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<970 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(970 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<971 + 1024 * 3,true> { int V __attribute__ ((bitwidth(971 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<971 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(971 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<972 + 1024 * 3,true> { int V __attribute__ ((bitwidth(972 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<972 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(972 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<973 + 1024 * 3,true> { int V __attribute__ ((bitwidth(973 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<973 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(973 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<974 + 1024 * 3,true> { int V __attribute__ ((bitwidth(974 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<974 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(974 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<975 + 1024 * 3,true> { int V __attribute__ ((bitwidth(975 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<975 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(975 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<976 + 1024 * 3,true> { int V __attribute__ ((bitwidth(976 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<976 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(976 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<977 + 1024 * 3,true> { int V __attribute__ ((bitwidth(977 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<977 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(977 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<978 + 1024 * 3,true> { int V __attribute__ ((bitwidth(978 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<978 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(978 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<979 + 1024 * 3,true> { int V __attribute__ ((bitwidth(979 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<979 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(979 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<980 + 1024 * 3,true> { int V __attribute__ ((bitwidth(980 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<980 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(980 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<981 + 1024 * 3,true> { int V __attribute__ ((bitwidth(981 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<981 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(981 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<982 + 1024 * 3,true> { int V __attribute__ ((bitwidth(982 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<982 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(982 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<983 + 1024 * 3,true> { int V __attribute__ ((bitwidth(983 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<983 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(983 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<984 + 1024 * 3,true> { int V __attribute__ ((bitwidth(984 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<984 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(984 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<985 + 1024 * 3,true> { int V __attribute__ ((bitwidth(985 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<985 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(985 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<986 + 1024 * 3,true> { int V __attribute__ ((bitwidth(986 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<986 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(986 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<987 + 1024 * 3,true> { int V __attribute__ ((bitwidth(987 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<987 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(987 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<988 + 1024 * 3,true> { int V __attribute__ ((bitwidth(988 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<988 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(988 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<989 + 1024 * 3,true> { int V __attribute__ ((bitwidth(989 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<989 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(989 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<990 + 1024 * 3,true> { int V __attribute__ ((bitwidth(990 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<990 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(990 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<991 + 1024 * 3,true> { int V __attribute__ ((bitwidth(991 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<991 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(991 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<992 + 1024 * 3,true> { int V __attribute__ ((bitwidth(992 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<992 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(992 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<993 + 1024 * 3,true> { int V __attribute__ ((bitwidth(993 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<993 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(993 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<994 + 1024 * 3,true> { int V __attribute__ ((bitwidth(994 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<994 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(994 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<995 + 1024 * 3,true> { int V __attribute__ ((bitwidth(995 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<995 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(995 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<996 + 1024 * 3,true> { int V __attribute__ ((bitwidth(996 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<996 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(996 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<997 + 1024 * 3,true> { int V __attribute__ ((bitwidth(997 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<997 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(997 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<998 + 1024 * 3,true> { int V __attribute__ ((bitwidth(998 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<998 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(998 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<999 + 1024 * 3,true> { int V __attribute__ ((bitwidth(999 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<999 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(999 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1000 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1000 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1000 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1000 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1001 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1001 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1001 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1001 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1002 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1002 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1002 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1002 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1003 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1003 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1003 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1003 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1004 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1004 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1004 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1004 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1005 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1005 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1005 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1005 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1006 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1006 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1006 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1006 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1007 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1007 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1007 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1007 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1008 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1008 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1008 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1008 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1009 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1009 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1009 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1009 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1010 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1010 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1010 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1010 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1011 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1011 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1011 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1011 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1012 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1012 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1012 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1012 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1013 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1013 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1013 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1013 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1014 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1014 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1014 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1014 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1015 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1015 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1015 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1015 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1016 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1016 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1016 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1016 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1017 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1017 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1017 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1017 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1018 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1018 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1018 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1018 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1019 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1019 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1019 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1019 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1020 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1020 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1020 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1020 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1021 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1021 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1021 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1021 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1022 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1022 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1022 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1022 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1023 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1023 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1023 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1023 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 3 , false>() { }; };
template<> struct ssdm_int<1024 + 1024 * 3,true> { int V __attribute__ ((bitwidth(1024 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 3 ,true>() { }; }; template<> struct ssdm_int<1024 + 1024 * 3, false> { unsigned int V __attribute__ ((bitwidth(1024 + 1024 * 3))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 3 , false>() { }; };
#pragma line 157 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma line 551 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
enum BaseMode { SC_BIN=2, SC_OCT=8, SC_DEC=10, SC_HEX=16 };
#pragma line 594 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
/* autopilot_ssdm_bits.h */
/*
 * Copyright (C) 2011 XILINX, Inc. 
 *
 * $Id$
 */
#pragma line 25 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
#pragma line 1 "c:/xilinx/vivado_hls/2012.2/win_x86/tools/llvm_gcc/bin/../lib/gcc/i686-pc-mingw32/4.2.1/../../../../include/stdlib.h" 1 3
/*
 * stdlib.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Definitions for common types, variables, and functions.
 *
 */
#pragma line 26 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 2
#pragma line 50 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Concatination ----------------*/
#pragma line 60 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Bit get/set ----------------*/
#pragma line 81 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Part get/set ----------------*/
#pragma empty_line
/* GetRange: Notice that the order of the range indices comply with SystemC
 standards. */
#pragma line 95 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* SetRange: Notice that the order of the range indices comply with SystemC
 standards. */
#pragma line 108 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Reduce operations ----------------*/
#pragma line 144 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- String-Integer conversions ----------------*/
#pragma line 595 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 2
#pragma empty_line
#pragma empty_line
/* Forward declaration.*/
template<int _AP_W, bool _AP_S> struct ap_int_base;
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
template<int _AP_W> struct ap_uint;
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2> struct ap_concat_ref;
#pragma empty_line
enum ap_q_mode {
    SC_RND, // rounding to plus infinity
    SC_RND_ZERO, // rounding to zero
    SC_RND_MIN_INF, // rounding to minus infinity
    SC_RND_INF, // rounding to infinity
    SC_RND_CONV, // convergent rounding
    SC_TRN, // truncation
    SC_TRN_ZERO // truncation to zero
#pragma empty_line
};
enum ap_o_mode {
    SC_SAT, // saturation
    SC_SAT_ZERO, // saturation to zero
    SC_SAT_SYM, // symmetrical saturation
    SC_WRAP, // wrap-around (*)
    SC_WRAP_SM // sign magnitude wrap-around (*)
};
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Concatination reference.
 ----------------------------------------------------------------
*/
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
    enum { _AP_WR = _AP_W1+_AP_W2, };
#pragma empty_line
    _AP_T1& mbv1;
    _AP_T2& mbv2;
#pragma empty_line
    inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1,
                          _AP_W2, _AP_T2>& ref):
           mbv1(ref.mbv1), mbv2(ref.mbv2) {}
#pragma empty_line
    inline __attribute__((always_inline)) ap_concat_ref( _AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) { }
#pragma empty_line
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_int_base<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        ap_int_base<_AP_W1,false> Part1;
        Part1.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1+W_ref2-1); __Result__; });
        mbv1.set(Part1);
        ap_int_base<_AP_W2,false> Part2;
        Part2.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2-1); __Result__; });
        mbv2.set(Part2);
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_concat_ref& operator = (unsigned long long val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    /*template<typename _AP_T3>
    INLINE ap_concat_ref& operator = ( const _AP_T3& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator=<_AP_W1+_AP_W2,false>(tmpVal);
    }*/
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_concat_ref<_AP_W1,_AP_T1,_AP_W2,_AP_T2>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_bit_ref<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_range_ref<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const af_range_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = ((const ap_int_base<_AP_W3, false>)(val));
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = (val.to_ap_int_base());
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
    inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false> () const {
        return get();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned long long () const {
        return get().to_uint64();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >
    operator, (const ap_range_ref<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >(*this,
                          const_cast<ap_range_ref<_AP_W3, _AP_S3>& >(a2));
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (ap_int_base<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (volatile ap_int_base<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                 _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                 const_cast<ap_int_base<_AP_W3, _AP_S3>& >(a2));
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (const ap_int_base<_AP_W3, _AP_S3>& a2) {
   ap_int_base<_AP_W3,_AP_S3> op(a2);
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_int_base<_AP_W3, _AP_S3>& >(op));
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (const volatile ap_int_base<_AP_W3, _AP_S3>& a2) {
   ap_int_base<_AP_W3,_AP_S3> op(a2);
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_int_base<_AP_W3, _AP_S3>& >(op));
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
    operator, (const ap_bit_ref<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           1, ap_bit_ref<_AP_W3, _AP_S3> >(*this,
                 const_cast<ap_bit_ref<_AP_W3, _AP_S3>& >(a2));
    }
#pragma empty_line
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3+_AP_W4,
                         ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >
    operator, (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                  _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >(
                 *this, const_cast<ap_concat_ref<_AP_W3,_AP_T3,
                 _AP_W4,_AP_T4>& >(a2));
    }
#pragma empty_line
    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_range_ref< _AP_W3, _AP_I3, _AP_S3, _AP_Q3,
                _AP_O3, _AP_N3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
                 _AP_O3, _AP_N3>& >(a2));
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator & (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() & a2;
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator | (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() | a2;
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator ^ (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() ^ a2;
    }
#pragma line 828 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    inline __attribute__((always_inline)) ap_int_base<_AP_WR,false> get() const {
        ap_int_base<_AP_WR,false> tmpVal(0);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        tmpVal.V = ({ typeof(tmpVal.V) __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof((ap_int_base<_AP_W2,false>(mbv2)).V) __Repl2__ = (ap_int_base<_AP_W2,false>(mbv2)).V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2-1); __Result__; });
#pragma empty_line
        tmpVal.V = ({ typeof(tmpVal.V) __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof((ap_int_base<_AP_W1,false>(mbv1)).V) __Repl2__ = (ap_int_base<_AP_W1,false>(mbv1)).V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1+W_ref2-1); __Result__; });
#pragma empty_line
        return tmpVal;
    }
#pragma empty_line
    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        ap_int_base<_AP_W1,false> tmpVal1;
        tmpVal1.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1+W_ref2-1); __Result__; });
        mbv1.set(tmpVal1);
        ap_int_base<_AP_W2, false> tmpVal2;
        tmpVal2.V=({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2-1); __Result__; });
        mbv2.set(tmpVal2);
    }
#pragma empty_line
    inline __attribute__((always_inline)) int length() const {
      return mbv1.length() + mbv2.length();
    }
};
#pragma line 867 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
/* Range (slice) reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, bool _AP_S>
struct ap_range_ref {
    ap_int_base<_AP_W,_AP_S> &d_bv;
    int l_index;
    int h_index;
#pragma empty_line
public:
    inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref):
      d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref(ap_int_base<_AP_W,_AP_S>* bv, int h, int l) :
        d_bv(*bv), l_index(l), h_index(h) {
        /*AP_ASSERT(h >= l, "Range must be (High, Low)");*/
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false> () const {
        ap_int_base<_AP_W,false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret;
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned long long () const {
        return to_uint64();
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref& operator = (unsigned long long val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)val);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_range_ref<_AP_W, _AP_S>& val) {
        return operator=((const ap_int_base<_AP_W, false>)val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_int_base());
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                      ap_range_ref<_AP_W2,_AP_S2> >(*this,
                      const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (ap_int_base<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W,ap_int_base<_AP_W,_AP_S> >
    operator, (ap_int_base<_AP_W,_AP_S> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W,_AP_S> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (volatile ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this,
                 const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (const ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this,
              const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (const volatile ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                       ap_int_base<_AP_W2,_AP_S2> >(*this,
                       const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,1,ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) ==
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) !=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    }
#pragma empty_line
    inline __attribute__((always_inline)) int length() const {
      return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int to_int() const {
        return (int)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return (unsigned)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) long to_long() const {
        return (long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned long to_ulong() const {
        return (unsigned long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return (ap_slong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return (ap_ulong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
};
#pragma empty_line
#pragma empty_line
/* Bit reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, bool _AP_S>
struct ap_bit_ref {
    ap_int_base<_AP_W, _AP_S>& d_bv;
    int d_index;
#pragma empty_line
public:
    inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref):
            d_bv(ref.d_bv), d_index(ref.d_index) {}
#pragma empty_line
    inline __attribute__((always_inline)) ap_bit_ref(ap_int_base<_AP_W,_AP_S>* bv, int index=0) :
        d_bv(*bv), d_index(index) { }
    inline __attribute__((always_inline)) operator bool () const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }
    inline __attribute__((always_inline)) bool to_bool() const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }
#pragma empty_line
    inline __attribute__((always_inline)) ap_bit_ref& operator = ( unsigned long long val ) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = ( const ap_int_base<_AP_W2,_AP_S2> &val ) {
        return operator =((unsigned long long)(val.V != 0));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2> &val ) {
        return operator =(val.operator ap_int_base<_AP_W2, false>());
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = (const ap_bit_ref<_AP_W2,_AP_S2>& val) {
        return operator =((unsigned long long) (bool) val);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_bit_ref& operator = (const ap_bit_ref<_AP_W,_AP_S>& val) {
        return operator =((unsigned long long) (bool) val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (volatile ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2>
                  >(*this, const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) {
  ap_int_base<_AP_W2,_AP_S2> op(a2);
        return ap_concat_ref<1,ap_bit_ref,_AP_W2,ap_int_base<_AP_W2,
               _AP_S2> >(*this, const_cast<ap_int_base<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (const volatile ap_int_base<_AP_W2, _AP_S2>& a2) {
  ap_int_base<_AP_W2,_AP_S2> op(a2);
        return ap_concat_ref<1,ap_bit_ref,_AP_W2, ap_int_base<_AP_W2,_AP_S2>
                 >(*this, const_cast< ap_int_base<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return
            ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,
                    _AP_S2> >(*this, const_cast<ap_range_ref<_AP_W2, _AP_S2> &>(a2));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
                 const_cast<ap_bit_ref<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >
    operator, (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &a2) {
        return ap_concat_ref<1,ap_bit_ref,_AP_W2+_AP_W3,ap_concat_ref<_AP_W2,
                  _AP_T2,_AP_W3,_AP_T3> >(*this,
                  const_cast<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &>(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() == op.get();
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() != op.get();
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool get() const {
         return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool get() {
         return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        operator = (val);
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool operator ~() const {
        bool bit = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
        return bit ? false : true;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int length() const { return 1; }
};
#pragma empty_line
template<int _AP_W, bool _AP_S, bool _AP_C>
struct conv_cint : public ssdm_int<_AP_W,_AP_S> {
    inline __attribute__((always_inline)) conv_cint() { }
};
#pragma empty_line
template<int _AP_W>
struct conv_cint<_AP_W,false,true> : public ssdm_int<_AP_W,false> {
    inline __attribute__((always_inline)) conv_cint() { }
    inline __attribute__((always_inline)) operator ap_ulong () const { return ssdm_int<_AP_W,false>::V; }
};
#pragma empty_line
template<int _AP_W>
struct conv_cint<_AP_W,true,true> : public ssdm_int<_AP_W,true> {
    inline __attribute__((always_inline)) conv_cint() { }
    inline __attribute__((always_inline)) operator ap_slong () const { return ssdm_int<_AP_W,true>::V; }
};
#pragma empty_line
template<int _AP_W>
struct conv_cint<_AP_W,false,false> : public ssdm_int<_AP_W,false> {
    inline __attribute__((always_inline)) conv_cint() { }
#pragma empty_line
    inline __attribute__((always_inline)) operator ap_ulong () const { return ssdm_int<_AP_W,false>::V; }
#pragma empty_line
};
#pragma empty_line
template<int _AP_W>
struct conv_cint<_AP_W,true,false> : public ssdm_int<_AP_W,true> {
    inline __attribute__((always_inline)) conv_cint() { }
#pragma empty_line
    inline __attribute__((always_inline)) operator ap_slong () const { return ssdm_int<_AP_W,true>::V; }
#pragma empty_line
};
#pragma empty_line
/* ----------------------------------------------------------------
 ap_int_base: AutoPilot integer/Arbitrary precision integer.
 ----------------------------------------------------------------
*/
template<int _AP_W, bool _AP_S=true>
struct ap_int_base : public conv_cint<_AP_W,_AP_S,(_AP_W<=64)> {
#pragma empty_line
public:
    typedef conv_cint<_AP_W, _AP_S, (_AP_W<=64)> Base;
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
#pragma empty_line
        typedef ap_int_base<mult_w, mult_s> mult;
        typedef ap_int_base<plus_w, plus_s> plus;
        typedef ap_int_base<minus_w, minus_s> minus;
        typedef ap_int_base<logic_w, logic_s> logic;
        typedef ap_int_base<div_w, div_s> div;
        typedef ap_int_base<mod_w, mod_s> mod;
        typedef ap_int_base<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };
#pragma empty_line
    /* Constructors.
     ----------------------------------------------------------------
   */
   inline __attribute__((always_inline)) ap_int_base() {
/*
   #ifdef __SC_COMPATIBLE__
       Base::V = 0;
   #endif
*/
   }
#pragma empty_line
    //INLINE ap_int_base(const ap_int_base& op) { Base::V = op.V; }
    //INLINE ap_int_base(const volatile ap_int_base& op) { Base::V = op.V; }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }
#pragma empty_line
 template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }
#pragma empty_line
    /* For C++ basic data types.*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) explicit ap_int_base(bool op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(signed char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_slong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_ulong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(float op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(double op) { Base::V = op; }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op) {
      Base::V = op.to_ap_int_base().V;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator ap_int_base<_AP_W2, false>().V;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator bool();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& ref) {
        const ap_int_base<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>::_AP_WR,false> tmp = ref.get();
        Base::V = tmp.V;
    }
#pragma empty_line
    /* This constructor is not usable yet, because the second parameter of 
     __builtin_bit_from_string(...)
     is required to be a constant C string.
    */
    inline __attribute__((always_inline)) ap_int_base(const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10);
        Base::V = Result;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix);
        Base::V = Result;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = (val.operator ap_int_base<_AP_W2, false> ()).V;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = val.operator bool ();
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base read() volatile {
        ;
        ap_int_base ret;
        ret.V = Base::V;
        return ret;
    }
    inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
        ;
        Base::V = op2.V;
    }
#pragma empty_line
    /* Another form of "write".*/
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }
#pragma empty_line
    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }
#pragma empty_line
    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }
#pragma line 1466 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator = (const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10);
        Base::V = Result;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base& set(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix);
        Base::V = Result;
        return *this;
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base& operator = (unsigned long long op) {
        Base::V = op;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_int_base& operator = (long long op) {
        Base::V = op;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (bool) op2;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& op2) {
      Base::V = op2.get().V;
      return *this;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = op.to_ap_int_base().V;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = (bool) op;
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    /* Explicit conversions to C interger types.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
    inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
    inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
    inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
    inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
    inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
#pragma line 1572 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    inline __attribute__((always_inline)) int length() const { return _AP_W; }
    inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }
#pragma empty_line
    /*INLINE operator ap_ulong () { return (ap_ulong)(Base::V); }*/
#pragma empty_line
    /*Reverse the contents of ap_int_base instance. I.e. LSB becomes MSB and vise versa*/
    inline __attribute__((always_inline)) ap_int_base& reverse () {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
        return *this;
    }
#pragma empty_line
    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool iszero () const {
        return Base::V == 0 ;
    }
#pragma empty_line
    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool is_zero () const {
        return Base::V == 0 ;
    }
#pragma empty_line
    /* x < 0 */
    inline __attribute__((always_inline)) bool sign () const {
        if (_AP_S && ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }))
            return true;
        else
            return false;
    }
#pragma empty_line
    /* x[i] = 0 */
    inline __attribute__((always_inline)) void clear(int i) {
        ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }
#pragma empty_line
    /* x[i] = !x[i]*/
    inline __attribute__((always_inline)) void invert(int i) {
        ;
        bool val = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
        if (val) Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
        else Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) bool test (int i) const {
        ;
        return ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    //Set the ith bit into 1
    inline __attribute__((always_inline)) void set (int i) {
        ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }
#pragma empty_line
    //Set the ith bit into v
    inline __attribute__((always_inline)) void set (int i, bool v) {
        ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }
#pragma empty_line
    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the left
    inline __attribute__((always_inline)) void lrotate(int n) {
         ;
         typeof(Base::V) l_p = Base::V << n;
         typeof(Base::V) r_p = Base::V >> (_AP_W - n);
         Base::V = l_p | r_p;
    }
#pragma empty_line
    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the right 
    inline __attribute__((always_inline)) void rrotate(int n) {
         ;
         typeof(Base::V) l_p = Base::V << (_AP_W - n);
         typeof(Base::V) r_p = Base::V >> n;
         Base::V = l_p | r_p;
    }
#pragma empty_line
    //Set the ith bit into v 
    inline __attribute__((always_inline)) void set_bit (int i, bool v) {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }
#pragma empty_line
    //Get the value of ith bit
    inline __attribute__((always_inline)) bool get_bit (int i) const {
        return (bool)({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    //complements every bit 
    inline __attribute__((always_inline)) void b_not() {
       Base::V = ~Base::V;
    }
     /*Binary Arithmetic. 
     ----------------------------------------------------------------
    */
#pragma line 1692 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::mult operator * ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::mult lhs(*this); typename RType<_AP_W2,_AP_S2>::mult rhs(op2); typename RType<_AP_W2,_AP_S2>::mult r ; r.V = lhs.V * rhs.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::plus operator + ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::plus lhs(*this); typename RType<_AP_W2,_AP_S2>::plus rhs(op2); typename RType<_AP_W2,_AP_S2>::plus r ; r.V = lhs.V + rhs.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::minus operator - ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::minus lhs(*this); typename RType<_AP_W2,_AP_S2>::minus rhs(op2); typename RType<_AP_W2,_AP_S2>::minus r ; r.V = lhs.V - rhs.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::div operator / ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::div r ; r.V = Base::V / op2.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::mod operator % ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::mod r ; r.V = Base::V % op2.V; return r; }
#pragma empty_line
    /* Bitwise and, or, xor.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::logic operator & ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::logic lhs(*this); typename RType<_AP_W2,_AP_S2>::logic rhs(op2); typename RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V & rhs.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::logic operator | ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::logic lhs(*this); typename RType<_AP_W2,_AP_S2>::logic rhs(op2); typename RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V | rhs.V; return r; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_int_base<_AP_W2,_AP_S2> &op2) const { ; typename RType<_AP_W2,_AP_S2>::logic lhs(*this); typename RType<_AP_W2,_AP_S2>::logic rhs(op2); typename RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V ^ rhs.V; return r; }
#pragma line 1713 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    /* Arithmetic assign.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V *= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator += ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V += op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V -= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V /= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V %= op2.V; return *this; }
#pragma empty_line
    /* Bitwise assign: and, or, xor.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V &= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V |= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V ^= op2.V; return *this; }
#pragma empty_line
#pragma empty_line
    /* Prefix increment, decrement.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base& operator ++() {
        operator+=((ap_int_base<1,false>) 1);
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator --() {
        operator-=((ap_int_base<1,false>) 1);
        return *this;
    }
#pragma empty_line
    /* Postfix increment, decrement
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) const ap_int_base operator ++(int) {
        ap_int_base t = *this;
        operator+=((ap_int_base<1,false>) 1);
        return t;
    }
    inline __attribute__((always_inline)) const ap_int_base operator --(int) {
        ap_int_base t = *this;
        operator-=((ap_int_base<1,false>) 1);
        return t;
    }
#pragma empty_line
    /* Unary arithmetic.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base operator +() {
        return *this;
    }
    inline __attribute__((always_inline)) typename RType<1,false>::minus operator -() const {
        return ((ap_int_base<1,false>) 0) - *this;
    }
#pragma empty_line
    /* Not (!)
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool operator ! () const {
        return Base::V == 0;
    }
#pragma empty_line
    /* Bitwise (arithmetic) unary: complement
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base<_AP_W+!_AP_S, true> operator ~() const {
        ap_int_base<_AP_W+!_AP_S, true> r;
        r.V = ~Base::V;
        return r;
    }
#pragma empty_line
    /* Shift (result constrained by left operand).
     ----------------------------------------------------------------
    */
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,true> &op2 ) const {
        ap_int_base r;
        int sh = op2.to_int();
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V >> sh;
        else r.V = Base::V << sh;
        return r;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r ;
        r.V = Base::V << op2.to_uint();
        return r;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,true> &op2 ) const {
        ap_int_base r;
        int sh = op2.to_int();
        bool isNeg = sh & 0x80000000;
        int shamt = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V << shamt;
        else r.V = Base::V >> shamt;
        return r;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r;
        r.V = Base::V >> op2.to_uint();
        return r;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this << (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this >> (op2.operator ap_int_base<_AP_W2, false>());
    }
#pragma empty_line
    /* Shift assign
     ----------------------------------------------------------------
    */
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,true> &op2 ) {
        int sh = op2.to_int();
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) Base::V >>= sh;
        else Base::V <<= sh;
        return *this;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V <<= op2.to_uint();
        return *this;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,true> &op2 ) {
        int sh = op2.to_int();
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) Base::V <<= sh;
        else Base::V >>= sh;
        return *this;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V >>= op2.to_uint();
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this <<= (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this >>= (op2.operator ap_int_base<_AP_W2, false>());
    }
#pragma empty_line
    /* Comparisons.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V == op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return !(Base::V == op2.V);
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V < op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V >= op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V > op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V <= op2.V;
    }
#pragma empty_line
#pragma empty_line
    /* Bit and Part Select
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        ;
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
           const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
           const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }
#pragma line 1978 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (int index) {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_int_base<_AP_W2,_AP_S2> &index) {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool operator [] (int index) const {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator [] (const ap_int_base<_AP_W2,_AP_S2>& index) const {
        ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this),
                                   index.to_int());
        return br.to_bool();
    }
#pragma empty_line
     inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (const ap_int_base<_AP_W2,_AP_S2> &index) {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool bit (int index) const {
        ;
        ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool bit (const ap_int_base<_AP_W2,_AP_S2>& index) const {
        ;
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }
#pragma line 2041 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(const ap_int_base<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                                                      const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(ap_int_base<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                     const_cast< ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(*this,
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this), const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                     const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this & a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this | a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this ^ a2.get();
    }
#pragma empty_line
    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        Base::V = val.V;
    }
#pragma empty_line
    /* Reduce operations.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool and_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool and_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }
#pragma empty_line
    /* Output as a string.
     ----------------------------------------------------------------
     */
     void to_string(char* str, int len, BaseMode mode, bool sign = false) const {
        for (int i = 0; i <= len; ++i) str[i] = '\0';
        if (mode == SC_BIN) {
            int size = ((_AP_W) < (len) ? (_AP_W) : (len));
            for (int bit = size; bit > 0; --bit) {
                if (({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), bit-1, bit-1); (bool)(__Result__ & 1); })) str[size-bit] = '1';
                else str[size-bit] = '0';
            }
        } /*else if (mode == AP_HEX) {
            typeof(Base::V) tmpV = Base::V;
            int idx = 0;
            int size = AP_MIN((_AP_W+3)/4, len);
            while (idx < size) {
                char hexb = tmpV & 0xF;
                if (hexb > 9) hexb = hexb - 10 + 'a';
                else hexb += '0';
                str[size-1-idx] = hexb;
                tmpV >> 4;
                idx ++;
            }
            } */ else if (mode == SC_OCT || mode == SC_DEC) {
            ;
        } else {
            ;
        }
    }
#pragma empty_line
    inline __attribute__((always_inline)) char* to_string(BaseMode mode, bool sign=false) const {
          return 0;
    }
#pragma empty_line
    inline __attribute__((always_inline)) char* to_string(signed char mode, bool sign=false) const {
          return to_string(BaseMode(mode), sign);
    }
};
#pragma empty_line
#pragma empty_line
/* Output streaming.
 ----------------------------------------------------------------
*/
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream &os, const ap_int_base<_AP_W,_AP_S> &x) {
    //os << x.to_string(AP_DEC);
    return os;
}
#pragma empty_line
/* Input streaming.
......................................................
*/
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::istream& operator >> (std::istream& in, ap_int_base<_AP_W,_AP_S> &op) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    return in;
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream &os, const ap_range_ref<_AP_W,_AP_S> &x) {
    //os << x.to_string(AP_DEC);
    return os;
}
#pragma empty_line
/* Input streaming.
......................................................
*/
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::istream& operator >> (std::istream& in, ap_range_ref<_AP_W,_AP_S> &op) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    return in;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Operators mixing Integers with AP_Int
 ----------------------------------------------------------------
*/
#pragma line 2389 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::mult operator * ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator * (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::plus operator + ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator + (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::minus operator - ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator - (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::div operator / ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator / (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::mod operator % ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator % (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator >> (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator << (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::logic operator & ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator & (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::logic operator | ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator | (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op.operator ^ (ap_int_base<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( bool op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator += (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator -= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator *= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator /= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator %= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator >>= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator <<= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator &= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator |= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator ^= (ap_int_base<1,false>(op2)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::mult operator * ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator * (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::plus operator + ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator + (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::minus operator - ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator - (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::div operator / ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator / (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::mod operator % ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator % (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator & ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator & (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator | ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator | (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op.operator ^ (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator += (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator -= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator *= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator /= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator %= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator >>= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator <<= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator &= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator |= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator ^= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::mult operator * ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator * (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::plus operator + ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator + (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::minus operator - ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator - (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::div operator / ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator / (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::mod operator % ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator % (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator & ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator & (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator | ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator | (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op.operator ^ (ap_int_base<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator += (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator -= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator *= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator /= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator %= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator >>= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator <<= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator &= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator |= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator ^= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator * (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator + (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator - (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator / (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator % (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator >> (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator << (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator & (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator | (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator ^ (ap_int_base<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator += (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator -= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator *= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator /= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator %= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >>= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <<= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator &= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator |= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator ^= (ap_int_base<8,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::mult operator * ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator * (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::plus operator + ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator + (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::minus operator - ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator - (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::div operator / ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator / (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::mod operator % ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator % (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator >> (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator << (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::logic operator & ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator & (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::logic operator | ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator | (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op.operator ^ (ap_int_base<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator += (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator -= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator *= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator /= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator %= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator >>= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator <<= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator &= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator |= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator ^= (ap_int_base<16,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator * (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator + (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator - (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator / (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator % (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator >> (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator << (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator & (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator | (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator ^ (ap_int_base<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator += (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator -= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator *= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator /= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator %= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >>= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <<= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator &= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator |= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator ^= (ap_int_base<16,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator * (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator + (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator - (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::div operator / ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator / (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator % (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator >> (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator << (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator & (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator | (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op.operator ^ (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator += (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator -= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator *= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator /= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator %= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator >>= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator <<= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator &= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator |= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator ^= (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator * (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator + (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator - (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator / (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator % (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator >> (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator << (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator & (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator | (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator ^ (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator += (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator -= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator *= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator /= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator %= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >>= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <<= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator &= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator |= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator ^= (ap_int_base<32,false>(op2)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator * (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator + (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator - (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::div operator / ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator / (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator % (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator >> (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator << (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator & (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator | (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op.operator ^ (ap_int_base<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator += (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator -= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator *= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator /= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator %= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator >>= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator <<= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator &= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator |= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator ^= (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator * (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator + (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator - (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator / (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator % (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator >> (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator << (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator & (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator | (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator ^ (ap_int_base<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator += (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator -= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator *= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator /= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator %= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >>= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <<= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator &= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator |= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator ^= (ap_int_base<32,false>(op2)); }
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::mult operator * ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator * (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::plus operator + ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator + (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::minus operator - ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator - (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::div operator / ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator / (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::mod operator % ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator % (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::arg1 operator >> ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator >> (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::arg1 operator << ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator << (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::logic operator & ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator & (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::logic operator | ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator | (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator ^ (ap_int_base<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator += (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator -= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator *= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator /= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator %= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >>= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <<= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator &= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator |= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator ^= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::mult operator * ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator * (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::plus operator + ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator + (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::minus operator - ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator - (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::div operator / ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator / (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::mod operator % ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator % (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::arg1 operator >> ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator >> (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::arg1 operator >> ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator >> (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::arg1 operator << ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator << (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::arg1 operator << ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator << (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::logic operator & ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator & (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::logic operator | ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator | (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator ^ (ap_int_base<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator += (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator -= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator *= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator /= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator %= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >>= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <<= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator &= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator |= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator ^= (ap_int_base<64,false>(op2)); }
#pragma line 2446 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator += ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator += ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator -= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator -= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator *= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator *= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator /= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator /= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator %= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator %= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator >>= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator >>= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator <<= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator <<= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator &= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator &= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator |= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator |= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator ^= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator ^= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (op2.operator ap_int_base<_AP_W2, false>()); }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_int_base<_AP_W2, false>(op2)); }
#pragma line 2511 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator += ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator += ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator -= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator -= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator *= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator *= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator /= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator /= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator %= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator %= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator >>= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator >>= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator <<= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator <<= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator &= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator &= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator |= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator |= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator ^= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator ^= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (ap_int_base<1, false>(op2)); }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::plus operator + ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::minus operator - ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::mult operator * ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::div operator / ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::mod operator % ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator >> ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator << ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator & ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator | ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator ^ ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_int_base<1, false>(op2)); }
#pragma line 2575 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<1,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<8,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<16,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,true>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator > (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator < (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator >= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator <= (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator == (ap_int_base<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_int_base<64,false>(op2).operator != (ap_int_base<_AP_W + _AP_W1, false>(op)); }
#pragma line 2617 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::plus operator + ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::minus operator - ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::mult operator * ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::div operator / ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::mod operator % ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::arg1 operator >> ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::arg1 operator << ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator & ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator | ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator ^ ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::plus operator + ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::minus operator - ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mult operator * ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::div operator / ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mod operator % ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator >> ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator << ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator & ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator | ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator ^ ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::plus operator + ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::minus operator - ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mult operator * ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::div operator / ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mod operator % ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator >> ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator << ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator & ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator | ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator ^ ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::plus operator + ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::minus operator - ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::mult operator * ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::div operator / ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::mod operator % ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator & ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator | ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::plus operator + ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::minus operator - ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::mult operator * ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::div operator / ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::mod operator % ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::arg1 operator >> ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::arg1 operator << ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator & ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator | ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator ^ ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::plus operator + ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::minus operator - ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::mult operator * ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::div operator / ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::mod operator % ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator & ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator | ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::plus operator + ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::minus operator - ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mult operator * ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::div operator / ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mod operator % ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator >> ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator << ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator & ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator | ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator ^ ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::plus operator + ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::minus operator - ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mult operator * ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::div operator / ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mod operator % ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator & ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator | ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::plus operator + ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::minus operator - ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mult operator * ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::div operator / ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mod operator % ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator >> ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator << ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator & ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator | ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator ^ ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::plus operator + ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::minus operator - ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mult operator * ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::div operator / ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mod operator % ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator & ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator | ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::plus operator + ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::minus operator - ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mult operator * ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::div operator / ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mod operator % ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator >> ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator << ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator & ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator | ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator ^ ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator + (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::plus operator + ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator - (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::minus operator - ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator * (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mult operator * ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator / (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::div operator / ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator % (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mod operator % ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator % (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator >> (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator >> ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator << (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator << ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator & (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator & ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator | (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator | ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator ^ (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator ^ ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2).operator ^ (ap_int_base<_AP_W, false>(op)); }
#pragma line 2642 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator + (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator + (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator - (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator - (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator * (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator * (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator / (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator / (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator % (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator % (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >> (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator >> (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator << (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator << (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator & (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator & (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator | (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator | (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^ (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs).operator ^ (ap_int_base<_AP_W2, false>(rhs)); }
#pragma line 2772 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 1, ap_int_base<1, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 1, ap_int_base<1, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_int_base<1, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (bool op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<1, false> val(op1); return ap_concat_ref<1, ap_int_base<1, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 1, ap_int_base<1, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 1, ap_int_base<1, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_int_base<1, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1, false> val(op1); return ap_concat_ref<1, ap_int_base<1, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 1, ap_int_base<1, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 1, ap_int_base<1, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 1, ap_int_base<1, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1, false> val(op1); return ap_concat_ref<1, ap_int_base<1, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 1, ap_int_base<1, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 1, ap_int_base<1, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<1, ap_int_base<1, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1, false> val(op1); return ap_concat_ref< 1, ap_int_base<1, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 1, ap_int_base<1, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 1, ap_int_base<1, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, ap_int_base<1, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1, false> val(op1); return ap_concat_ref<1, ap_int_base<1, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 1, ap_int_base<1, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,1, ap_int_base<1, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, ap_int_base<1, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1, false> val(op1); return ap_concat_ref<1, ap_int_base<1, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (char op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 8, ap_int_base<8, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref< 8, ap_int_base<8, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,8, ap_int_base<8, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (signed char op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 8, ap_int_base<8, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref< 8, ap_int_base<8, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,8, ap_int_base<8, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, true> val(op1); return ap_concat_ref<8, ap_int_base<8, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 8, ap_int_base<8, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (unsigned char op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8, false> val(op1); return ap_concat_ref<8, ap_int_base<8, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 8, ap_int_base<8, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, false> val(op1); return ap_concat_ref<8, ap_int_base<8, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 8, ap_int_base<8, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 8, ap_int_base<8, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8, false> val(op1); return ap_concat_ref<8, ap_int_base<8, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 8, ap_int_base<8, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8, false> val(op1); return ap_concat_ref< 8, ap_int_base<8, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, false> val(op1); return ap_concat_ref<8, ap_int_base<8, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 8, ap_int_base<8, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,8, ap_int_base<8, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<8, ap_int_base<8, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8, false> val(op1); return ap_concat_ref<8, ap_int_base<8, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 16, ap_int_base<16, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 16, ap_int_base<16, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (short op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<16, true> val(op1); return ap_concat_ref<16, ap_int_base<16, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 16, ap_int_base<16, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 16, ap_int_base<16, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<16, true> val(op1); return ap_concat_ref<16, ap_int_base<16, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 16, ap_int_base<16, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 16, ap_int_base<16, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 16, ap_int_base<16, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<16, true> val(op1); return ap_concat_ref<16, ap_int_base<16, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 16, ap_int_base<16, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 16, ap_int_base<16, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<16, true> val(op1); return ap_concat_ref< 16, ap_int_base<16, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16, true> val(op1); return ap_concat_ref<16, ap_int_base<16, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<16, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,16, ap_int_base<16, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16, true> val(op1); return ap_concat_ref<16, ap_int_base<16, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 16, ap_int_base<16, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 16, ap_int_base<16, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (unsigned short op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<16, false> val(op1); return ap_concat_ref<16, ap_int_base<16, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 16, ap_int_base<16, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 16, ap_int_base<16, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<16, false> val(op1); return ap_concat_ref<16, ap_int_base<16, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 16, ap_int_base<16, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 16, ap_int_base<16, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 16, ap_int_base<16, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<16, false> val(op1); return ap_concat_ref<16, ap_int_base<16, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 16, ap_int_base<16, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 16, ap_int_base<16, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<16, false> val(op1); return ap_concat_ref< 16, ap_int_base<16, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16, false> val(op1); return ap_concat_ref<16, ap_int_base<16, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 16, ap_int_base<16, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<16, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,16, ap_int_base<16, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<16, ap_int_base<16, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16, false> val(op1); return ap_concat_ref<16, ap_int_base<16, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (int op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 32, ap_int_base<32, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref< 32, ap_int_base<32, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,32, ap_int_base<32, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (unsigned int op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 32, ap_int_base<32, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref< 32, ap_int_base<32, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,32, ap_int_base<32, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (long op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 32, ap_int_base<32, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref< 32, ap_int_base<32, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<32, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,32, ap_int_base<32, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, true> val(op1); return ap_concat_ref<32, ap_int_base<32, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (unsigned long op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 32, ap_int_base<32, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 32, ap_int_base<32, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 32, ap_int_base<32, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref< 32, ap_int_base<32, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 32, ap_int_base<32, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<32, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,32, ap_int_base<32, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<32, ap_int_base<32, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32, false> val(op1); return ap_concat_ref<32, ap_int_base<32, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 64, ap_int_base<64, true> > operator, (ap_int_base<_AP_W, _AP_S>& op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 64, ap_int_base<64, true> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, true>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (ap_slong op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64, true> val(op1); return ap_concat_ref<64, ap_int_base<64, true>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 64, ap_int_base<64, true> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 64, ap_int_base<64, true> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64, true> val(op1); return ap_concat_ref<64, ap_int_base<64, true>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 64, ap_int_base<64, true> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 64, ap_int_base<64, true> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 64, ap_int_base<64, true>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64, true> val(op1); return ap_concat_ref<64, ap_int_base<64, true>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 64, ap_int_base<64, true> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 64, ap_int_base<64, true> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64, true> val(op1); return ap_concat_ref< 64, ap_int_base<64, true>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, true> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, true> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64, true> val(op1); return ap_concat_ref<64, ap_int_base<64, true>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, true> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<64, true> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,64, ap_int_base<64, true> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64, true> val(op1); return ap_concat_ref<64, ap_int_base<64, true>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 64, ap_int_base<64, false> > operator, (ap_int_base<_AP_W, _AP_S>& op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref< _AP_W, ap_int_base<_AP_W, _AP_S>, 64, ap_int_base<64, false> >(op1, val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, false>, _AP_W, ap_int_base<_AP_W, _AP_S> > operator, (ap_ulong op1, ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64, false> val(op1); return ap_concat_ref<64, ap_int_base<64, false>, _AP_W, ap_int_base<_AP_W, _AP_S> >(val, op2); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 64, ap_int_base<64, false> > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref<_AP_W, ap_range_ref<_AP_W, _AP_S>, 64, ap_int_base<64, false> >(const_cast<ap_range_ref< _AP_W, _AP_S>& >(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> > operator, (ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64, false> val(op1); return ap_concat_ref<64, ap_int_base<64, false>, _AP_W, ap_range_ref<_AP_W, _AP_S> >(val, const_cast< ap_range_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 64, ap_int_base<64, false> > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref<1, ap_bit_ref<_AP_W, _AP_S>, 64, ap_int_base<64, false> >(const_cast<ap_bit_ref<_AP_W, _AP_S> &>(op1), val); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_concat_ref< 64, ap_int_base<64, false>, 1, ap_bit_ref<_AP_W, _AP_S> > operator, (ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64, false> val(op1); return ap_concat_ref<64, ap_int_base<64, false>, 1, ap_bit_ref<_AP_W, _AP_S> >(val, const_cast<ap_bit_ref<_AP_W, _AP_S>& >(op2)); } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 64, ap_int_base<64, false> > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref<_AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2>, 64, ap_int_base<64, false> > ( const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op1), val);}template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > operator, (ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64, false> val(op1); return ap_concat_ref< 64, ap_int_base<64, false>, _AP_W + _AP_W2, ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> > (val, const_cast<ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &>(op2));}template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, false> > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref<_AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, false> > (const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64, false> val(op1); return ap_concat_ref<64, ap_int_base<64, false>, _AP_W, af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> >(val, const_cast<af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>, 64, ap_int_base<64, false> > operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<64, false> val(op2); return ap_concat_ref<1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>,64, ap_int_base<64, false> >(const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& >(op1), val); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_concat_ref<64, ap_int_base<64, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > operator, (ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64, false> val(op1); return ap_concat_ref<64, ap_int_base<64, false>, 1, af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> > (val, const_cast<af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &>(op2)); }
#pragma line 2798 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
#pragma line 15 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int.h" 2
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h" 1
// -*- c++ -*-
#pragma empty_line
/*
 * Copyright (C) 2011 XILINX, Inc.
 *
 */
#pragma line 16 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
/// ap_fixed_base
// -----------------------------------------------------------------------------
//#include <math.h>
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int_syn.h" 1
/* -*- c++ -*-*/
/*
 * Copyright (C) 2011 XILINX, Inc.
 *
 */
#pragma line 20 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h" 2
#pragma line 31 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
//enum ap_q_mode { SC_TRN, SC_RND, SC_TRN_ZERO, SC_RND_ZERO, 
//                 SC_RND_INF, SC_RND_MIN_INF, SC_RND_CONV };
#pragma empty_line
//enum ap_o_mode { SC_WRAP, SC_SAT, SC_SAT_ZERO, SC_SAT_SYM,SC_WRAP_SM };
#pragma empty_line
/// Forward declaration.
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed_base;
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_bit_ref {
    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& d_bv;
    int d_index;
#pragma empty_line
public:
    inline __attribute__((always_inline)) af_bit_ref(const af_bit_ref<_AP_W,_AP_I,_AP_S,
              _AP_Q,_AP_O,_AP_N>&ref):
              d_bv(ref.d_bv), d_index(ref.d_index) {}
#pragma empty_line
    inline __attribute__((always_inline)) af_bit_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>* bv, int index = 0) :
        d_bv(*bv), d_index(index) {}
    inline __attribute__((always_inline)) operator bool () const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }
#pragma empty_line
    inline __attribute__((always_inline)) af_bit_ref& operator = (unsigned long long val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        return operator =(val.to_uint64());
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_bit_ref& operator = (const af_bit_ref<_AP_W2,_AP_I2,
                                  _AP_S2,_AP_Q2,_AP_O2,_AP_N2>& val) {
        return operator =((unsigned long long) (bool) val);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_bit_ref& operator = (const af_bit_ref<_AP_W,_AP_I,
                                  _AP_S,_AP_Q,_AP_O,_AP_N>& val) {
        return operator =((unsigned long long) (bool) val);
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = ( const ap_bit_ref<_AP_W2, _AP_S2> &val) {
        return operator =((unsigned long long) (bool) val);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator =((const ap_int_base<_AP_W2, false>) val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) af_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_int_base<_AP_W2, _AP_S2> >(*this, op);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, 1,
                 ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
                  ap_range_ref<_AP_W2, _AP_S2> >(*this,
                  const_cast< ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& > (op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator == (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() == op.get();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator != (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() != op.get();
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool get() const {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool operator ~ () const {
        bool bit = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
        return bit ? false : true;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int length() const {
        return 1;
    }
#pragma empty_line
};
/* Range (slice) reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
struct af_range_ref {
    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& d_bv;
    int l_index;
    int h_index;
#pragma empty_line
public:
    inline __attribute__((always_inline)) af_range_ref(const af_range_ref<_AP_W,_AP_I,_AP_S,
           _AP_Q,_AP_O, _AP_N>&ref):
           d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>* bv
                        , int h, int l) :
        d_bv(*bv), l_index(l), h_index(h) {
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator ap_int_base<_AP_W,false> () const {
        ap_int_base<_AP_W, false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret;
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned long long () const {
        ap_int_base<_AP_W, false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret.to_uint64();
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref& operator = (unsigned long long val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const af_range_ref<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        ap_int_base<_AP_W2, false> tmp(val);
        return operator=(tmp);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_fixed_base<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_int_base());
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref& operator= (const af_range_ref<_AP_W,
                          _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& val) {
        ap_int_base<_AP_W, false> tmp(val);
        return operator=(tmp);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_range_ref<_AP_W2, _AP_S2>& val) {
        return operator=((ap_int_base<_AP_W2, false>)val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) ==
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) !=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator == (const af_range_ref<_AP_W2, _AP_I2,
                              _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) ==
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator != (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) !=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator < (const af_range_ref<_AP_W2, _AP_I2,
                            _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator <= (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) <=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator > (const af_range_ref<_AP_W2, _AP_I2,
                               _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator >= (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }) >=
               ({ typeof(op2.d_bv.V) __Result__ = 0; typeof(op2.d_bv.V) __Val2__ = op2.d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), op2.l_index, op2.h_index); __Result__; });
    }
#pragma empty_line
    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_int_base<_AP_W2, _AP_S2> >(*this, op);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                       _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) int length() const {
      return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int to_int() const {
        return (int)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return (unsigned)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) long to_long() const {
        return (long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned long to_ulong() const {
        return (unsigned long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return (ap_slong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return (ap_ulong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
};
#pragma empty_line
// -----------------------------------------------------------------------------
/// ap_fixed_base: AutoPilot fixed point.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S=true,
         ap_q_mode _AP_Q=SC_TRN, ap_o_mode _AP_O=SC_WRAP, int _AP_N=0>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
#pragma empty_line
public:
    typedef ssdm_int<_AP_W, _AP_S> Base;
#pragma empty_line
    __attribute__((weak)) void overflow_adjust(bool underflow, bool overflow,bool lD, bool sign) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
#pragma empty_line
        if (!underflow && !overflow) return;
        if (_AP_O==SC_WRAP) {
            if (_AP_N == 0)
                return;
            if (_AP_S) {
                //signed SC_WRAP 
                //n_bits == 1
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
                if (_AP_N > 1) {
                //n_bits > 1
                    ap_int_base<_AP_W, false> mask(-1);
                    if (sign) mask.V = 0;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
#pragma empty_line
                }
            } else {
                //unsigned SC_WRAP 
                ap_int_base<_AP_W, false> mask(-1);
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
#pragma empty_line
            }
        } else if (_AP_O==SC_SAT_ZERO) {
              Base::V = 0;
        }
        else if (_AP_O == SC_WRAP_SM && _AP_S) {
            bool Ro = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); });
            if (_AP_N == 0) {
                if (lD != Ro) {
                    Base::V = ~Base::V;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
                }
            } else {
                if (_AP_N == 1 && sign != Ro) {
                   Base::V = ~Base::V;
                } else if (_AP_N > 1) {
                    bool lNo = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_N, _AP_W - _AP_N); (bool)(__Result__ & 1); });
                    if (lNo == sign)
                        Base::V = ~Base::V;
                    ap_int_base<_AP_W, false> mask(-1);
                    if (sign) mask.V = 0;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
#pragma empty_line
                }
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
#pragma empty_line
            }
        } else {
            if (_AP_S) {
                if (overflow)
                    Base::V = ~(ap_int_base<_AP_W,false>(1)<<(_AP_W-1)).V;
                else if (underflow) {
                    Base::V = (ap_int_base<_AP_W,false>(1) << (_AP_W-1)).V;
                    if (_AP_O==SC_SAT_SYM)
                        Base::V |= 1;
                }
            }
            else {
                if (overflow)
                    Base::V = ~(ap_int_base<_AP_W,false>(0).V);
                else if (underflow)
                    Base::V = 0;
            }
        }
    }
#pragma empty_line
    __attribute__((weak)) bool quantization_adjust(bool qb, bool r, bool s) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        bool carry=(bool)({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); });
        if (_AP_Q==SC_TRN)
            return false;
        if (_AP_Q==SC_RND_ZERO)
            qb &= s || r;
        else if (_AP_Q==SC_RND_MIN_INF)
            qb &= r;
        else if (_AP_Q==SC_RND_INF)
            qb &= !s || r;
        else if (_AP_Q==SC_RND_CONV)
            qb &= ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 0); (bool)(__Result__ & 1); }) || r;
        else if (_AP_Q==SC_TRN_ZERO)
            qb = s && ( qb || r );
        Base::V += qb;
        //return qb;
        return carry&&(!(bool)({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); }));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2>
    struct RType {
        enum {
            _AP_F=_AP_W-_AP_I,
            F2=_AP_W2-_AP_I2,
            mult_w = _AP_W+_AP_W2,
            mult_i = _AP_I+_AP_I2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            plus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            minus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
#pragma empty_line
            div_w = _AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)) + _AP_S2,
#pragma empty_line
#pragma empty_line
#pragma empty_line
            div_i = _AP_I + _AP_W2 -_AP_I2 + _AP_S2,
            div_s = _AP_S||_AP_S2,
            logic_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            logic_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
#pragma empty_line
        typedef ap_fixed_base<mult_w, mult_i, mult_s> mult;
        typedef ap_fixed_base<plus_w, plus_i, plus_s> plus;
        typedef ap_fixed_base<minus_w, minus_i, minus_s> minus;
        typedef ap_fixed_base<logic_w, logic_i, logic_s> logic;
        typedef ap_fixed_base<div_w, div_i, div_s> div;
        typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1;
    };
#pragma empty_line
    /// Constructors.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base() {
        ;
/*
    #ifdef __SC_COMPATIBLE__
        Base::V = 0;
    #endif
*/
    }
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    __attribute__((weak)) ap_fixed_base (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2> &op) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        enum { N2=_AP_W2, _AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2,
               QUAN_INC = F2>_AP_F && !(_AP_Q==SC_TRN || _AP_Q==SC_TRN_ZERO && !_AP_S2) };
        bool carry = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
        // handle quantization
        unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
        bool signbit = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W2-1, _AP_W2-1); (bool)(__Result__ & 1); });
#pragma empty_line
        bool isneg = signbit && _AP_S2;
        if (F2 == _AP_F)
            Base::V = op.V;
        else if (F2 > _AP_F) {
            if (sh_amt < _AP_W2)
                Base::V = op.V >> sh_amt;
            else {
                if (isneg) Base::V = -1;
                else Base::V = 0;
            }
            if (_AP_Q!=SC_TRN && !(_AP_Q==SC_TRN_ZERO && !_AP_S2)) {
                bool qbit = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), F2-_AP_F-1, F2-_AP_F-1); (bool)(__Result__ & 1); });
#pragma empty_line
                bool qb = (F2-_AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
#pragma empty_line
                bool r = (F2 > _AP_F+1) ?
                         ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, F2-_AP_F-2<_AP_W2?F2-_AP_F-2:_AP_W2-1); __Result__; })!=0 : false;
#pragma empty_line
#pragma empty_line
                carry = quantization_adjust(qb, r, _AP_S2 && signbit);
            }
        }
        else { // no quantization
            Base::V = op.V;
            if (sh_amt < _AP_W)
                Base::V = Base::V << sh_amt;
            else
                Base::V = 0;
        }
#pragma empty_line
        // handle overflow/underflow
        if ((_AP_O != SC_WRAP || _AP_N != 0) && (!_AP_S && _AP_S2 ||
             _AP_I-_AP_S < _AP_I2-_AP_S2+(QUAN_INC ||
              _AP_S2 && _AP_O==SC_SAT_SYM))) { // saturation
            bool deleted_zeros = _AP_S2?true:!carry,
                 deleted_ones = true;
            bool neg_src = isneg;
            bool lD = false;
#pragma empty_line
            bool newsignbit = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); });
            int pos1 = F2 - _AP_F + _AP_W;
            int pos2 = F2 - _AP_F + _AP_W + 1;
            if (pos1 < _AP_W2 && pos1 >= 0)
                lD = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, pos1); (bool)(__Result__ & 1); });
#pragma empty_line
#pragma empty_line
#pragma empty_line
            if(pos1 < _AP_W2)
            {
                bool Range1_all_ones = true;
                bool Range1_all_zeros = true;
                bool Range2_all_ones = true;
                ap_int_base<_AP_W2,false> Range1(0);
                ap_int_base<_AP_W2,false> Range2(0);
                ap_int_base<_AP_W2,false> all_ones(-1);
#pragma empty_line
                if (pos2 < _AP_W2 && pos2 >= 0) {
                    Range2.V = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2-1); __Result__; });
#pragma empty_line
#pragma empty_line
                    Range2_all_ones = Range2 == all_ones >> pos2;
                } else if (pos2 < 0)
                    Range2_all_ones = false;
#pragma empty_line
                if (pos1 >= 0 && pos2 < _AP_W2) {
                    Range1.V = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2-1); __Result__; });
#pragma empty_line
#pragma empty_line
#pragma empty_line
                    Range1_all_ones = Range1 == all_ones >> pos1;
                    Range1_all_zeros = !Range1.V ;
                } else if (pos2 == _AP_W2) {
                    Range1_all_ones = lD;
                    Range1_all_zeros = !lD;
                } else if (pos1 < 0) {
                    Range1_all_zeros = !op.V;
                    Range1_all_ones = false;
                }
#pragma empty_line
#pragma empty_line
                deleted_zeros = deleted_zeros && (carry ? Range1_all_ones: Range1_all_zeros);
                deleted_ones = carry ? Range2_all_ones &&
                               (pos1 < 0 || !lD): Range1_all_ones;
                neg_src = isneg && !(carry&&Range1_all_ones);
            } else
                neg_src = isneg && newsignbit;
            bool neg_trg = _AP_S && newsignbit;
            bool overflow = (neg_trg || !deleted_zeros) && !isneg;
            bool underflow = (!neg_trg || !deleted_ones) && neg_src;
            if ((_AP_O == SC_SAT_SYM) && _AP_S2 && _AP_S)
                underflow |= neg_src && (_AP_W > 1 ?
                  ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0 : true);
#pragma empty_line
            overflow_adjust(underflow, overflow, lD, neg_src);
        }
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
        *this = const_cast<ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base (const ap_int_base<_AP_W2,_AP_S2>& op) {
        ;
        ap_fixed_base<_AP_W2,_AP_W2,_AP_S2> f_op;
        f_op.V = op.V;
        *this = f_op;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base( bool b ) { *this = (ap_fixed_base<1, 1, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( char b ) { *this = (ap_fixed_base<8, 8, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed char b ) { *this = (ap_fixed_base<8, 8, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned char b ) { *this = (ap_fixed_base<8, 8, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed short b ) { *this = (ap_fixed_base<16, 16, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned short b ) { *this = (ap_fixed_base<16, 16, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed int b ) { *this = (ap_fixed_base<32, 32, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned int b ) { *this = (ap_fixed_base<32, 32, false>) b; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base( signed long b ) { *this = (ap_fixed_base<32, 32, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned long b ) { *this = (ap_fixed_base<32, 32, false>) b; }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base( ap_slong b ) { *this = (ap_fixed_base<64, 64, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( ap_ulong b ) { *this = (ap_fixed_base<64, 64, false>) b; }
   inline __attribute__((always_inline)) ap_fixed_base(const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10);
        Base::V = Result;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix);
        Base::V = Result;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        *this = ((bool)op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
        *this = (ap_int_base<_AP_W2, false>(op));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
         *this = (bool(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        *this = (ap_int_base<_AP_W2, false>(op));
    }
#pragma empty_line
    // helper function.
    inline __attribute__((always_inline)) unsigned long long doubleToRawBits(double pf) const {
        union {
            unsigned long long __L;
            double __D;
        } LD;
        LD.__D = pf;
        return LD.__L;
    }
#pragma empty_line
    inline __attribute__((always_inline)) double rawBitsToDouble(unsigned long long pi) const {
        union {
            unsigned long long __L;
            double __D;
        } LD;
        LD.__L = pi;
        return LD.__D;
    }
#pragma empty_line
    inline __attribute__((always_inline)) float rawBitsToFloat (unsigned int pi) const {
        union {
            unsigned int __L;
            float __D;
        } LD;
        LD.__L = pi;
        return LD.__D;
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base(double d) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_int_base<64,false> ireg;
        ireg.V = doubleToRawBits(d);
        bool isneg = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 63, 63); (bool)(__Result__ & 1); });
#pragma empty_line
        ap_int_base<11,true> exp;
        exp.V = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 -1); __Result__; }) - ((1<<(11 -1))-1);
#pragma empty_line
#pragma empty_line
        ap_int_base<52 + 2, true> man;
        man.V = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });
        man.V = ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
        if(isneg) man = -man;
        if ( (ireg.V & 0x7fffffffffffffffLL)==0 ) {
            Base::V = 0;
        } else {
            int _AP_W2=52 +2, _AP_I2=exp.V+2, _AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2;
            bool _AP_S2 = true,
                 QUAN_INC = F2>_AP_F && !(_AP_Q==SC_TRN || _AP_Q==SC_TRN_ZERO && !_AP_S2);
            bool carry = false;
            // handle quantization
            unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
            if (F2 == _AP_F)
                Base::V = man.V;
            else if (F2 > _AP_F) {
                if (sh_amt < 52 + 2)
                   Base::V = man.V >> sh_amt;
                else {
                   if (isneg) Base::V = -1;
                   else Base::V = 0;
                }
                if ((_AP_Q != SC_TRN) && !((_AP_Q == SC_TRN_ZERO) && !_AP_S2)) {
#pragma empty_line
                    bool qb = (F2-_AP_F > _AP_W2) ?
                        isneg : (bool) ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), F2 - _AP_F - 1, F2 - _AP_F - 1); (bool)(__Result__ & 1); });
                    bool r = (F2 > _AP_F + 1) ? ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2): (_AP_W2 - 1)); __Result__; }) !=
#pragma empty_line
                             0 : false;
                    carry = quantization_adjust(qb, r, isneg);
                }
            }
            else { // no quantization 
                Base::V = man.V;
                if (sh_amt < _AP_W)
                    Base::V = Base::V << sh_amt;
                else
                    Base::V = 0;
            }
            // handle overflow/underflow
            if ((_AP_O != SC_WRAP || _AP_N != 0) && (!_AP_S && _AP_S2
                || _AP_I - _AP_S < _AP_I2 - _AP_S2 + (QUAN_INC ||
                _AP_S2 && (_AP_O == SC_SAT_SYM))) ) { // saturation
                bool deleted_zeros = _AP_S2?true:!carry,
                     deleted_ones = true;
                bool neg_src = isneg;
                bool lD = false;
                int pos1 =F2 - _AP_F + _AP_W;
                int pos2 =F2 - _AP_F + _AP_W + 1;
                bool newsignbit = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); });
                if (pos1 < _AP_W2 && pos1 >= 0)
                  //lD = _ssdm_op_get_bit(man.V, pos1);
                  lD = (man.V >> pos1) & 1;
                if (pos1 < _AP_W2 ) {
                    bool Range1_all_ones = true;
                    bool Range1_all_zeros = true;
                    bool Range2_all_ones = true;
                    ap_int_base<52 +2,false> Range2;
                    ap_int_base<52 +2,false> all_ones(-1);
#pragma empty_line
                    if (pos2 >= 0 && pos2 < _AP_W2) {
                        //Range2.V = _ssdm_op_get_range(man.V, 
                        //                        pos2, _AP_W2 - 1);
                        Range2.V = man.V;
                        Range2.V >>= pos2;
                        Range2_all_ones = Range2 == (all_ones >> pos2);
                    } else if (pos2 < 0)
                        Range2_all_ones = false;
                    if (pos1 >= 0 && pos2 < _AP_W2) {
                        Range1_all_ones = Range2_all_ones && lD;
                        Range1_all_zeros = !Range2.V && !lD;
                    } else if (pos2 == _AP_W2) {
                        Range1_all_ones = lD;
                        Range1_all_zeros = !lD;
                    } else if (pos1 < 0) {
                        Range1_all_zeros = !man.V;
                        Range1_all_ones = false;
                    }
#pragma empty_line
                    deleted_zeros = deleted_zeros && (carry ? Range1_all_ones: Range1_all_zeros);
                    deleted_ones = carry ? Range2_all_ones &&
                                   ( pos1 < 0 || !lD): Range1_all_ones;
                    neg_src=isneg && !(carry&&Range1_all_ones);
                } else
                    neg_src = isneg && newsignbit;
                bool neg_trg = _AP_S && newsignbit;
                bool overflow = (neg_trg || !deleted_zeros) && !isneg;
                bool underflow =(!neg_trg || !deleted_ones) && neg_src;
                if ((_AP_O == SC_SAT_SYM) && _AP_S2 && _AP_S)
                   underflow |= neg_src && (_AP_W > 1 ?
                     ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0 : true);
                overflow_adjust(underflow, overflow, lD, neg_src);
            }
        }
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base& operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op)
    {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base& operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op)
    {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
    // Set this ap_fixed_base with a bits string. That means the ssdm_int::V
    // inside this ap_fixed_base is assigned by bv.
    // Note the input parameter should be a fixed-point formatted bit string.
    inline __attribute__((always_inline)) ap_fixed_base& setBits(unsigned long long bv) {
      Base::V = bv;
      return *this;
    }
    // Return a ap_fixed_base object whose ssdm_int::V is assigned by bv.
    // Note the input parameter should be a fixed-point formatted bit string.
    static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(unsigned long long bv) {
      ap_fixed_base Tmp;
      Tmp.V = bv;
      return Tmp;
    }
#pragma empty_line
    // Explicit conversion functions to ap_int_base that captures 
    // all integer bits (bits are truncated)
    inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S>
    to_ap_int_base(bool Cnative = true) const {
        //return ap_int_base<AP_MAX(_AP_I,1),_AP_S>(_AP_I > 1 ? 
        // _ssdm_op_get_range(const_cast<ap_fixed_base*>(this)->Base::V,_AP_W-_AP_I,_AP_W-1) : 0);
        ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ret(0);
        if(_AP_I > 0 && _AP_I <= _AP_W)
            ret.V = ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
#pragma empty_line
#pragma empty_line
        else if (_AP_I > _AP_W)
        {
            ret.V = ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
#pragma empty_line
            unsigned int shift = _AP_I - _AP_W;
            ret.V <<= shift;
        }
        if (Cnative) {
            //Follow C native data type, conversion from double to int
            if (_AP_S && ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); })
#pragma empty_line
                && (_AP_I < _AP_W) && (({ typeof(const_cast<ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast<ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I >= 0 ? _AP_W - _AP_I - 1: _AP_W - 1); __Result__; }) != 0))
#pragma empty_line
#pragma empty_line
                ret.V += 1;
        } else {
        //Follow OSCI library, conversion from sc_fixed to sc_int
        }
        return ret;
    };
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) operator ap_int_base<_AP_W2,_AP_S2> () const {
        return (ap_int_base<_AP_W2,_AP_S2>)to_ap_int_base();
    }
#pragma empty_line
    // Explicit conversion function to C built-in integral type.
    inline __attribute__((always_inline)) int to_int() const {
        return to_ap_int_base().to_int();
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return to_ap_int_base().to_uint();
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return to_ap_int_base().to_int64();
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return to_ap_int_base().to_uint64();
    }
    __attribute__((weak)) double to_double() const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_int_base<64,true> res;
        res.V = 0;
        if (Base::V == 0)
            return 0;
        bool isneg = _AP_S ? ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }) : false;
#pragma empty_line
        ap_int_base<_AP_W+_AP_S,_AP_S> tmp;
        tmp.V = Base::V;
        if (isneg) tmp.V = -Base::V;
        if(_AP_W-_AP_I > 0 || _AP_W > 64) {
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(isneg) __Repl2__ = !!isneg; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63, 63); __Result__; });
            int i = _AP_W-1;
            int j = _AP_W-1;
            bool hit_msb = false;
            for (i = _AP_W-1; i >=0; i--) {
                   j = hit_msb ? j : i;
                   hit_msb |= (({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); }) & 0x01);
            }
            int exp = _AP_I-(_AP_W-j);
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp + ((1<<(11 -1))-1)) __Repl2__ = exp + ((1<<(11 -1))-1); __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 62); __Result__; });
            if (j == 0)
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(0) __Repl2__ = 0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 52 - 1); __Result__; });
            else {
                ap_int_base<52,false> man;
                man.V = ({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), j > 52 ? j - 52 : 0, j - 1); __Result__; });
#pragma empty_line
                man.V <<= 52 > j ? 52 -j : 0;
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(man.V) __Repl2__ = man.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 52 - 1); __Result__; });
            }
        } else
            return double(to_int64());
        double dp = rawBitsToDouble(res.to_int64());
        return dp;
    }
#pragma empty_line
    __attribute__((weak)) float to_float() const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_int_base<32,true> res;
        res.V = 0;
        if (Base::V == 0)
            return 0;
        bool isneg = _AP_S ? ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }) : false;
#pragma empty_line
        ap_int_base<_AP_W+_AP_S,_AP_S> tmp;
        tmp.V = Base::V;
        if (isneg) tmp.V = -Base::V;
        if(_AP_W-_AP_I > 0 || _AP_W > 64) {
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(isneg) __Repl2__ = !!isneg; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 31, 31); __Result__; });
            int i = _AP_W-1;
            int j = _AP_W-1;
            bool hit_msb = false;
            for (i = _AP_W-1; i >=0; i--) {
                   j = hit_msb ? j : i;
                   hit_msb |= (({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); }) & 0x01);
            }
#pragma empty_line
            int exp = _AP_I-(_AP_W-j);
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp + ((1<<(8 -1))-1)) __Repl2__ = exp + ((1<<(8 -1))-1); __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 30); __Result__; });
            if (j == 0)
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(0) __Repl2__ = 0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 23 - 1); __Result__; });
            else {
                ap_int_base<23,false> man;
                man.V = ({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), j > 23 ? j - 23 : 0, j - 1); __Result__; });
#pragma empty_line
                man.V <<= 23 > j ? 23 -j: 0;
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(man.V) __Repl2__ = man.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 23 - 1); __Result__; });
            }
        } else
            return float(to_uint64());
        double dp = rawBitsToFloat(res.to_uint());
        return dp;
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) operator double () const {
        return to_double();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator float () const {
        return to_float();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator char () const {
        return (char) to_int();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned char () const {
        return (unsigned char) to_uint();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator short () const {
        return (short) to_int();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned short () const {
        return (unsigned short) to_uint();
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) operator int () const {
        return to_int();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned int () const {
        return to_uint();
    }
#pragma line 1104 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
    inline __attribute__((always_inline)) operator long () const {
        return (long)to_int();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned long () const {
        return (unsigned long) to_uint();
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) operator unsigned long long () const {
        return to_uint64();
    }
#pragma empty_line
    inline __attribute__((always_inline)) operator long long () const {
        return to_int64();
    }
#pragma empty_line
    inline __attribute__((always_inline)) int length() const { return _AP_W; };
    // Count the number of zeros from the most significant bit 
    // to the first one bit. Note this is only for ap_fixed_base whose 
    // _AP_W <= 64, otherwise will incur assertion.
    inline __attribute__((always_inline)) int countLeadingZeros() {
      ;
#pragma empty_line
      return __builtin_clzll((unsigned long long)Base::V) - (64 - _AP_W);
    }
#pragma empty_line
    // Arithmetic : Binary
    // -------------------------------------------------------------------------
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::mult
    operator *(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::mult r;
        ap_int_base<_AP_W+_AP_W2,_AP_S> OP1;
        OP1.V = Base::V;
        ap_int_base<_AP_W+_AP_W2,_AP_S2> OP2;
        OP2.V = op2.V ;
        r.V = OP1.V * OP2.V;
        return r;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::div
    operator /(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::div r;
#pragma empty_line
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),
                      _AP_I, _AP_S> t(*this);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        r.V = t.V / op2.V;
        //r = double(to_double() / op2.to_double());
        return r;
    }
#pragma line 1174 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::plus operator + (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::plus r, lhs(*this), rhs(op2); ; r.V = lhs.V + rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::minus operator - (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::minus r, lhs(*this), rhs(op2); ; r.V = lhs.V - rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator & (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V & rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator | (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V | rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator ^ (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V ^ rhs.V; return r; }
#pragma empty_line
#pragma empty_line
    // Arithmetic : assign
    // -------------------------------------------------------------------------
#pragma line 1192 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator += (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator + (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator - (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator * (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator / (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator & (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator | (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator ^ (op2); return *this; }
#pragma empty_line
#pragma empty_line
    // Prefix increment, decrement.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base& operator ++() {
        operator+=(ap_fixed_base<_AP_W-_AP_I+1,1,false>(1));
        return *this;
    }
    inline __attribute__((always_inline)) ap_fixed_base& operator --() {
        operator-=(ap_fixed_base<_AP_W-_AP_I+1,1,false>(1));
        return *this;
    }
#pragma empty_line
    // Postfix increment, decrement
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) const ap_fixed_base
    operator ++(int) {
        ap_fixed_base t(*this);
        operator++();
        return t;
    }
    inline __attribute__((always_inline)) const ap_fixed_base
    operator --(int) {
        ap_fixed_base t(*this);
        operator--();
        return t;
    }
#pragma empty_line
    // Unary arithmetic.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base operator +() {
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator -() const {
        ap_fixed_base<_AP_W + 1, _AP_I + 1, true> ret(*this);
        ret.V = - ret.V;
        return ret;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O,_AP_N> getNeg() {
        ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O,_AP_N> Tmp(*this);
        Tmp.V = -Tmp.V;
        return Tmp;
    }
#pragma empty_line
    // Not (!)
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) bool operator !() const {
        return Base::V == 0;
    }
#pragma empty_line
    // Bitwise complement
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator ~() const {
        ap_fixed_base<_AP_W, _AP_I, _AP_S> ret;
        ret.V=~Base::V;
        return ret;
    }
#pragma empty_line
    // Shift
    // -------------------------------------------------------------------------
     template<int _AP_SHIFT>
     inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift () const {
         ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
         r.V = Base::V;
         return r;
     }
#pragma empty_line
     template<int _AP_SHIFT>
     inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift () const {
         ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
         r.V = Base::V;
         return r;
     }
#pragma empty_line
     __attribute__((weak)) ap_fixed_base
     operator << (int sh) const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_fixed_base r;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V >> sh;
        else r.V = Base::V << sh;
#pragma line 1323 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return r;
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_int_base<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator << (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base
    operator << (unsigned int sh) const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_fixed_base r;
        r.V = Base::V << sh;
#pragma line 1368 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_int_base<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator << (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base
    operator >> (int sh) const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_fixed_base r;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V << sh;
        else r.V = Base::V >> sh;
#pragma line 1426 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_int_base<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator >> (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base
    operator >> (unsigned sh) const {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        ap_fixed_base r;
        r.V = Base::V >> sh;
#pragma line 1458 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_int_base<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator >> (sh);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator >> (op2.to_ap_int_base());
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator << (op2.to_ap_int_base());
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    // Shift assign
    // -------------------------------------------------------------------------
    __attribute__((weak)) ap_fixed_base&
    operator <<= (int sh) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        if (sh == 0) return *this;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
#pragma line 1527 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        if (isNeg) Base::V >>= sh;
        else Base::V <<= sh;
#pragma line 1541 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return *this;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_int_base<_AP_W2,true>& op2) {
        int sh = op2.to_int();
        return operator <<= (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base&
    operator <<= (unsigned int sh) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma line 1576 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        Base::V <<= sh;
#pragma line 1588 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return *this;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_int_base<_AP_W2,false>& op2) {
        unsigned int sh = op2.to_uint();
        return operator <<= (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base&
    operator >>= (int sh) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma empty_line
        if (sh == 0) return *this;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
#pragma line 1636 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        if (isNeg) Base::V <<= sh;
        else Base::V >>= sh;
#pragma line 1650 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        return *this;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_int_base<_AP_W2,true>& op2) {
        int sh = op2.to_int();
        return operator >>= (sh);
    }
#pragma empty_line
    __attribute__((weak)) ap_fixed_base&
    operator >>= (unsigned int sh) {
#pragma empty_line
#pragma AUTOPILOT inline self
#pragma line 1680 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
        Base::V >>= sh;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        return *this;
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_int_base<_AP_W2,false>& op2) {
        unsigned int sh = op2.to_uint();
        return operator >>= (sh);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator >>= (op2.to_ap_int_base());
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator <<= (op2.to_ap_int_base());
    }
#pragma empty_line
    // Comparisons.
    // -------------------------------------------------------------------------
#pragma line 1727 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator == (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V == op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator != (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V != op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator > (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V > op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V >= op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator < (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V < op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V <= op2.V; return false; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) bool operator == (double d) const { return to_double() == d; }
    inline __attribute__((always_inline)) bool operator != (double d) const { return to_double() != d; }
    inline __attribute__((always_inline)) bool operator > (double d) const { return to_double() > d; }
    inline __attribute__((always_inline)) bool operator >= (double d) const { return to_double() >= d; }
    inline __attribute__((always_inline)) bool operator < (double d) const { return to_double() < d; }
    inline __attribute__((always_inline)) bool operator <= (double d) const { return to_double() <= d; }
#pragma empty_line
    // Bit and Slice Select
    inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> operator[] (unsigned index) {
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> operator [] (const ap_int_base<_AP_W2,_AP_S2>& index) {
        ;
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int());
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool operator [] (unsigned index) const {
        ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index, index); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> bit(unsigned index) {
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index);
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> bit (const ap_int_base<_AP_W2,_AP_S2>& index) {
        ;
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int());
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool bit (unsigned index) const {
        ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index, index); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> get_bit (const ap_int_base<_AP_W2, true>& index) {
        ;
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int() + _AP_W - _AP_I);
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool get_bit (int index) const {
        ;
        ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index + _AP_W - _AP_I, index + _AP_W - _AP_I); (bool)(__Result__ & 1); });
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> get_bit (int index) {
        ;
        ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index + _AP_W - _AP_I);
    }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) bool get_bit (const ap_int_base<_AP_W2, true>& index) const {
        ;
        ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index.to_int() + _AP_W - _AP_I, index.to_int() + _AP_W - _AP_I); (bool)(__Result__ & 1); });
    }
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) {
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) {
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) const {
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
          const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
          const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() {
        return this->range(_AP_W - 1, 0);
    }
#pragma empty_line
    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() const {
        return this->range(_AP_W - 1, 0);
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool is_zero () const {
        return Base::V == 0;
    }
#pragma empty_line
    inline __attribute__((always_inline)) bool is_neg () const {
        if (_AP_S && ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }))
           return true;
        return false;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int wl () const {
        return _AP_W;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int iwl () const {
        return _AP_I;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_q_mode q_mode () const {
        return _AP_Q;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_o_mode o_mode () const {
        return _AP_O;
    }
#pragma empty_line
    inline __attribute__((always_inline)) int n_bits () const {
        return _AP_N;
    }
#pragma empty_line
    inline __attribute__((always_inline)) char* to_string(BaseMode mode) {
          return 0;
    }
#pragma empty_line
    inline __attribute__((always_inline)) char* to_string(signed char mode) {
          return to_string(BaseMode(mode));
    }
};
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_not(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = ~ op.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_and(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V & op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_or(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V | op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_xor(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V ^ op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N, int _AP_W2, int _AP_I2,
         bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    ap_fixed_base<_AP_W2+!_AP_S2, _AP_I2+!_AP_S2, true, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = - op.V;
    ret = Tmp;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N, int _AP_W2, int _AP_I2,
         bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_W2 - _AP_I2 + ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = op.V;
    Tmp.V <<= i;
    ret = Tmp;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_I2 + ((_AP_W - _AP_I) > (_AP_W2 - _AP_I2) ? (_AP_W - _AP_I) : (_AP_W2 - _AP_I2)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    const int val = _AP_W - _AP_I - (_AP_W2 - _AP_I2);
    Tmp.V = op.V;
    if (val > 0) Tmp.V <<= val;
    Tmp.V >>= i;
    ret = Tmp;
}
#pragma line 2000 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
template<> inline __attribute__((always_inline)) ap_fixed_base<1,1,true,SC_TRN,SC_WRAP>::ap_fixed_base(bool i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<1,1,false,SC_TRN,SC_WRAP>::ap_fixed_base(bool i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed short i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed short i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned short i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned short i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed int i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed int i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned int i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned int i_op) { Base::V = i_op; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(long i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(long i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned long i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned long i_op) { Base::V = i_op; }
#pragma empty_line
template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(ap_slong i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(ap_slong i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(ap_ulong i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(ap_ulong i_op) { Base::V = i_op; }
#pragma empty_line
#pragma empty_line
/// Output streamimg.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) std::ostream&
operator << (std::ostream& os, const ap_fixed_base<_AP_W,_AP_I,
             _AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    // os << x.to_double();
    return os;
}
#pragma empty_line
/// Input streamimg.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) std::istream&
operator >> (std::istream& in, ap_fixed_base<_AP_W,_AP_I,
             _AP_S,_AP_Q,_AP_O, _AP_N>& x) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    return in;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
/// Operators mixing Integers with ap_fixed_base
// -----------------------------------------------------------------------------
#pragma line 2118 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator + (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator - (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator * (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator / (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >> (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator << (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator & (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator | (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^ (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator == (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator != (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator > (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator < (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator += (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>= (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<= (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^= (ap_fixed_base<1,1,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator + (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator - (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator * (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator / (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >> (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator << (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator & (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator | (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^ (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator == (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator != (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator > (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator < (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator += (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>= (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<= (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^= (ap_fixed_base<8,8,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator + (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator - (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator * (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator / (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >> (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator << (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator & (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator | (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator ^ (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator == (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator != (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator > (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator < (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator <= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator += (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator -= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator *= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator /= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >>= (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator <<= (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator &= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator |= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator ^= (ap_fixed_base<16,16,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator + (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator - (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator * (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator / (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >> (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator << (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator & (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator | (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^ (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator == (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator != (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator > (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator < (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator += (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>= (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<= (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^= (ap_fixed_base<16,16,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator >> (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator << (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator >>= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed int i_op) { return op.operator <<= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed int i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >> (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator << (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >> (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator << (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >> (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator << (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >> (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator << (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >> (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator << (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }
#pragma line 2168 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::plus operator + ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::plus operator + ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator + (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::minus operator - ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::minus operator - ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator - (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::mult operator * ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::mult operator * ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator * (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::div operator / ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::div operator / ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator / (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator & ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator & ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator & (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator | ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator | ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator | (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator ^ ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator ^ ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator ^ (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator == ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator == (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator != ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator != (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator > ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator > (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator >= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator >= (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator < ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator < (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator <= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator <= (op); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator += (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator += ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator += (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator -= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator -= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator -= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator *= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator *= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator *= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator /= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator /= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator /= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator &= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator &= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator &= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator |= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator |= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator |= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator ^= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator ^= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator ^= (op.to_ap_int_base()); }
#pragma empty_line
// Relational Operators with double
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator == ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator == (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator != ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator != (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
        ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator > ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator < (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator >= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator <= (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
        ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator < ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator > (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator <= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator >= (op1);
}
#pragma line 2253 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma line 2293 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_int_base<1,false>(op)); }
#pragma line 16 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int.h" 2
//Forward declaration
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_fixed;
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_ufixed;
template<int _AP_W> struct ap_int;
template<int _AP_W> struct ap_uint;
#pragma empty_line
//AP_INT
//--------------------------------------------------------
template<int _AP_W>
struct ap_int: ap_int_base<_AP_W, true> {
    typedef ap_int_base<_AP_W, true> Base;
    //Constructor
    inline __attribute__((always_inline)) ap_int(): Base() {}
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const ap_int<_AP_W2> &op) {Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_int<_AP_W2> &op) {Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const ap_uint<_AP_W2> &op) { Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_uint<_AP_W2> &op) { Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op){ Base::V = op.V; }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_int(bool val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(signed char val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned char val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(short val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned short val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(int val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned int val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned long long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(long long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(float val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(double val) {Base::V = val; }
#pragma empty_line
     inline __attribute__((always_inline)) ap_int(const char* str):Base(str) {}
     inline __attribute__((always_inline)) ap_int(const char* str, signed char radix):Base(str, radix) {}
     //Assignment
     //Assignment
     //Another form of "write"
     inline __attribute__((always_inline)) void operator = (const ap_int<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }
#pragma empty_line
     inline __attribute__((always_inline)) void operator = (const volatile ap_int<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }
#pragma empty_line
     inline __attribute__((always_inline)) ap_int& operator = (const volatile ap_int<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
#pragma empty_line
     inline __attribute__((always_inline)) ap_int& operator = (const ap_int<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
};
#pragma empty_line
//AP_UINT
//---------------------------------------------------------------
template<int _AP_W>
struct ap_uint: ap_int_base<_AP_W, false> {
    typedef ap_int_base<_AP_W, false> Base;
    //Constructor
    inline __attribute__((always_inline)) ap_uint(): Base() {}
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const ap_uint<_AP_W2> &op) { Base::V = op.V; }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const ap_int<_AP_W2> &op) { Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_uint<_AP_W2> &op) { Base::V = op.V; }
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_int<_AP_W2> &op) { Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op){ Base::V = op.V;}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_uint(bool val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(signed char val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned char val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(short val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned short val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(int val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned int val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned long long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(long long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(float val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(double val) { Base::V = val; }
#pragma empty_line
    inline __attribute__((always_inline)) ap_uint(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_uint(const char* str, signed char radix):Base(str, radix) {}
     //Assignment
     //Another form of "write"
     inline __attribute__((always_inline)) void operator = (const ap_uint<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }
#pragma empty_line
     inline __attribute__((always_inline)) void operator = (const volatile ap_uint<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }
#pragma empty_line
     inline __attribute__((always_inline)) ap_uint& operator = (const volatile ap_uint<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
#pragma empty_line
     inline __attribute__((always_inline)) ap_uint& operator = (const ap_uint<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
};
#pragma empty_line
#pragma empty_line
//AP_FIXED
//---------------------------------------------------------------------  
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = SC_TRN,
         ap_o_mode _AP_O = SC_WRAP, int _AP_N = 0>
struct ap_fixed: ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
    typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;
     //Constructor
    inline __attribute__((always_inline)) ap_fixed():Base() {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                    _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                          true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const ap_int<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const ap_uint<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                    _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                          true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_int<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_uint<_AP_W2>& op):
                   Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op): Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed(bool v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(signed char v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned char v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(short v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned short v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(int v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned int v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(float v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(double v):Base(v) {}
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_fixed(const char* str, signed char radix):Base(str, radix) {}
#pragma empty_line
    //Assignment
    inline __attribute__((always_inline)) ap_fixed& operator = (const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                        _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_fixed& operator = (const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
#pragma empty_line
};
//AP_UFIXED
//-------------------------------------------------------------------
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = SC_TRN,
         ap_o_mode _AP_O = SC_WRAP, int _AP_N = 0>
struct ap_ufixed: ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
    typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;
     //Constructor
    inline __attribute__((always_inline)) ap_ufixed():Base() {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                      _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                     _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_int<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_uint<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                      _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                     _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_int<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_uint<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op): Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline __attribute__((always_inline)) ap_ufixed(bool v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(signed char v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned char v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(short v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned short v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(int v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned int v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(float v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(double v):Base(v) {}
#pragma empty_line
    inline __attribute__((always_inline)) ap_ufixed(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_ufixed(const char* str, signed char radix):Base(str, radix) {}
#pragma empty_line
    //Assignment
    inline __attribute__((always_inline)) ap_ufixed& operator = (const ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
    inline __attribute__((always_inline)) ap_ufixed& operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }
#pragma empty_line
};
#pragma line 50 "ap_axi_sdata.h" 2
#pragma empty_line
template<int D,int U,int TI,int TD>
  struct ap_axis{
    ap_int<D> data;
    ap_int<(D+7)/8> strb;
    ap_int<U> user;
    ap_int<1> last;
    // ap_int<TI> tid;
    ap_int<TD> tdest;
  };
#pragma empty_line
template<int D,int U,int TI,int TD>
  struct ap_axiu{
    ap_uint<D> data;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    //    ap_uint<TI> tid;
    ap_uint<TD> tdest;
  };
#pragma empty_line
//typedef ap_axis<int D, int U, int TI, int TD> ap_axis_unsigned<int D, int U, int TI, int TD>;
#pragma line 51 "sobel.h" 2
#pragma line 1 "ap_interfaces.h" 1
/*******************************************************************************
Vendor: Xilinx 
Associated Filename: ap_interfaces.h
Purpose: Interface definiation header file for AutoESL
Revision History: February 13, 2012 - initial release
#pragma empty_line
*******************************************************************************
© Copyright 2008 - 2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
is protected under U.S. and international copyright and other intellectual 
property laws.
#pragma empty_line
DISCLAIMER
This disclaimer is not a license and does not grant any rights to the materials 
distributed herewith. Except as otherwise provided in a valid license issued to 
you by Xilinx, and to the maximum extent permitted by applicable law: 
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
in contract or tort, including negligence, or under any other theory of 
liability) for any loss or damage of any kind or nature related to, arising under 
or in connection with these materials, including for any direct, or any indirect, 
special, incidental, or consequential loss or damage (including loss of data, 
profits, goodwill, or any type of loss or damage suffered as a result of any 
action brought by a third party) even if such damage or loss was reasonably 
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
CRITICAL APPLICATIONS
Xilinx products are not designed or intended to be fail-safe, or for use in any 
application requiring fail-safe performance, such as life-support or safety 
devices or systems, Class III medical devices, nuclear facilities, applications 
related to the deployment of airbags, or any other applications that could lead 
to death, personal injury, or severe property or environmental damage 
(individually and collectively, "Critical Applications"). Customer assumes the 
sole risk and liability of any use of Xilinx products in Critical Applications, 
subject only to applicable laws and regulations governing limitations on product 
liability. 
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
ALL TIMES.
#pragma empty_line
*******************************************************************************/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_stream.h" 1
/* -*- c++ -*-*/
/*
 * Copyright (C) 2011 XILINX, Inc. 
 *
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/etc/autopilot_enum.h" 1
/*
 * Copyright (C) 2011 XILINX, Inc. 
 *
 * $Id$
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Data Types */
enum SsdmDataTypes {
    _ssdm_sc_int = 0,
    _ssdm_c_int = _ssdm_sc_int,
    _ssdm_sc_uint = 1,
    _ssdm_c_uint = _ssdm_sc_uint,
    _ssdm_sc_bigint = 2,
    _ssdm_sc_biguint = 3,
};
#pragma empty_line
#pragma empty_line
/* Ports */
enum SsdmPortTypes {
    _ssdm_sc_in = 0,
    _ssdm_sc_out = 1,
    _ssdm_sc_inout = 2,
    _ssdm_sc_in_clk,
#pragma empty_line
    _ssdm_fifo_in,
    _ssdm_sc_fifo_in = _ssdm_fifo_in,
    _ssdm_tlm_fifo_in = _ssdm_fifo_in,
    _ssdm_fifo_out,
    _ssdm_sc_fifo_out = _ssdm_fifo_out,
    _ssdm_tlm_fifo_out = _ssdm_fifo_out,
    _ssdm_fifo_inout,
    _ssdm_sc_fifo_inout = _ssdm_fifo_inout,
    _ssdm_tlm_fifo_inout = _ssdm_fifo_inout,
    _ssdm_sc_bus,
#pragma empty_line
    _ssdm_port_end,
};
#pragma empty_line
#pragma empty_line
/* Threads (Processes) */
enum SsdmProcessTypes {
    _ssdm_method = 0,
    _ssdm_sc_method = _ssdm_method,
    _ssdm_thread = 1,
    _ssdm_sc_thread = _ssdm_thread,
    _ssdm_cthread = 2,
    _ssdm_sc_cthread = _ssdm_cthread,
    _ssdm_process_end,
};
#pragma empty_line
#pragma empty_line
/* Threads (Processes) */
enum SsdmSensitiveTypes {
    _ssdm_sensitive = 0,
    _ssdm_sensitive_pos,
    _ssdm_sensitive_neg,
    _ssdm_sensitive_reset0, /* Level = High*/
    _ssdm_sensitive_reset1, /* Level = Low*/
    _ssdm_sensitive_end,
};
#pragma empty_line
#pragma empty_line
/* Channels */
enum SsdmChannelTypes {
    _ssdm_sc_sig,
    _ssdm_fifo,
    _ssdm_sc_fifo = _ssdm_fifo,
    _ssdm_sc_mem_fifo,
};
#pragma empty_line
/* Regions */
enum SsdmRegionTypes {
    _ssdm_region_reset,
    _ssdm_region_protocol,
    _ssdm_region_pipeline,
    _ssdm_region_parallel,
};
#pragma line 11 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_stream.h" 2
#pragma line 47 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_stream.h"
// Default streaming mode
#pragma line 60 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_stream.h"
// FIFO stream
#pragma line 69 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_stream.h"
// HS stream
#pragma line 51 "ap_interfaces.h" 2
#pragma empty_line
/*
 * Enum of available interfaces in AUTOESL
 */
enum AP_AUTO_INTERFACES {AP_NONE,AP_ACK,AP_VLD,AP_OVLD,AP_HS,AP_CTRL_NONE,AP_CTRL_HS,AP_MEM,AP_FIFO,AP_BUS};
#pragma empty_line
/*
 * GCC pre-processor directive to insert pragmas from macro code
 * AutoESL requires that all hardware centric commands be either in the
 * form of a directive or pragma before hardware synthesis.
 */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Allows the user to define the type of AP_INTERFACE to be used.
 * AutoESL generated block in an EDK environment.
 */
/* Array streaming required by AP_HS on arrays */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Set the unregistered interface */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Set a registered interface */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Special case for array streaming using ap_hs */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Allows the user to define their own bus type for connection of the 
 * AutoESL generated block in an EDK environment.
 */
/* Basic Definition of a User Declared Bus */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Connects a user defined bus to a function port variable */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_HS */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_FIFO on an input */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_FIFO on an output */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_VLD */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_OVLD */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_ACK */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Provides mapping of ports when the basic AutoESL interfae used is AP_NONE */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Declaration of a function control bus */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Declaration of a user custom data bus*/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/*
 * Create Standard XILINX bus interfaces
 */
#pragma empty_line
/* AXI4 Interfaces - require axi4 library to be loaded in solution */
/* Create an AXI4 Lite interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create an AXI4 master interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create a basic AXI4 stream interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create an AXI4 stream input interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create an FSL interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create a PLBv46 slave interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create a PLBv46 master interface at the system level layer */
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
/* Create an NPI interface at the system level layer */
#pragma line 52 "sobel.h" 2
#pragma line 1 "ap_bmp.h" 1
/*******************************************************************************
Vendor: Xilinx 
Associated Filename: ap_bmp.h
Purpose: BMP image reader and writer header file for AutoESL  
Revision History: February 13, 2012 - initial release
#pragma empty_line
*******************************************************************************
© Copyright 2008 - 2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
is protected under U.S. and international copyright and other intellectual 
property laws.
#pragma empty_line
DISCLAIMER
This disclaimer is not a license and does not grant any rights to the materials 
distributed herewith. Except as otherwise provided in a valid license issued to 
you by Xilinx, and to the maximum extent permitted by applicable law: 
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
in contract or tort, including negligence, or under any other theory of 
liability) for any loss or damage of any kind or nature related to, arising under 
or in connection with these materials, including for any direct, or any indirect, 
special, incidental, or consequential loss or damage (including loss of data, 
profits, goodwill, or any type of loss or damage suffered as a result of any 
action brought by a third party) even if such damage or loss was reasonably 
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
CRITICAL APPLICATIONS
Xilinx products are not designed or intended to be fail-safe, or for use in any 
application requiring fail-safe performance, such as life-support or safety 
devices or systems, Class III medical devices, nuclear facilities, applications 
related to the deployment of airbags, or any other applications that could lead 
to death, personal injury, or severe property or environmental damage 
(individually and collectively, "Critical Applications"). Customer assumes the 
sole risk and liability of any use of Xilinx products in Critical Applications, 
subject only to applicable laws and regulations governing limitations on product 
liability. 
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
ALL TIMES.
#pragma empty_line
*******************************************************************************/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Basic color definitions
#pragma empty_line
#pragma empty_line
#pragma empty_line
// Maximum image size 
#pragma empty_line
#pragma empty_line
#pragma empty_line
//File Information Header
typedef struct{
  unsigned short FileType;
  unsigned int FileSize;
  unsigned short Reserved1;
  unsigned short Reserved2;
  unsigned short Offset;
}BMPHeader;
#pragma empty_line
typedef struct{
  unsigned int Size;
  unsigned int Width;
  unsigned int Height;
  unsigned short Planes;
  unsigned short BitsPerPixel;
  unsigned int Compression;
  unsigned int SizeOfBitmap;
  unsigned int HorzResolution;
  unsigned int VertResolution;
  unsigned int ColorsUsed;
  unsigned int ColorsImportant;
}BMPImageHeader;
#pragma empty_line
typedef struct{
  BMPHeader *file_header;
  BMPImageHeader *image_header;
  unsigned int *colors;
  unsigned char *data;
  unsigned char R[1080][1920];
  unsigned char G[1080][1920];
  unsigned char B[1080][1920];
  unsigned char Y[1080][1920];
  char U[1080][1920];
  char V[1080][1920];
}BMPImage;
#pragma empty_line
//Read Function
int BMP_Read(char *file, int row, int col, unsigned char *R, unsigned char *G, unsigned char *B);
#pragma empty_line
//Write Function
int BMP_Write(char *file, int row, int col, unsigned char *R, unsigned char *G, unsigned char *B);
#pragma line 53 "sobel.h" 2
#pragma line 1 "ap_video.h" 1
/*******************************************************************************
Vendor: Xilinx 
Associated Filename: ap_video.h
Purpose: Video datatype header file for AutoESL
Revision History: February 13, 2012 - initial release
#pragma empty_line
*******************************************************************************
© Copyright 2008 - 2012 Xilinx, Inc. All rights reserved. 
#pragma empty_line
This file contains confidential and proprietary information of Xilinx, Inc. and 
is protected under U.S. and international copyright and other intellectual 
property laws.
#pragma empty_line
DISCLAIMER
This disclaimer is not a license and does not grant any rights to the materials 
distributed herewith. Except as otherwise provided in a valid license issued to 
you by Xilinx, and to the maximum extent permitted by applicable law: 
(1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX 
HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether 
in contract or tort, including negligence, or under any other theory of 
liability) for any loss or damage of any kind or nature related to, arising under 
or in connection with these materials, including for any direct, or any indirect, 
special, incidental, or consequential loss or damage (including loss of data, 
profits, goodwill, or any type of loss or damage suffered as a result of any 
action brought by a third party) even if such damage or loss was reasonably 
foreseeable or Xilinx had been advised of the possibility of the same.
#pragma empty_line
CRITICAL APPLICATIONS
Xilinx products are not designed or intended to be fail-safe, or for use in any 
application requiring fail-safe performance, such as life-support or safety 
devices or systems, Class III medical devices, nuclear facilities, applications 
related to the deployment of airbags, or any other applications that could lead 
to death, personal injury, or severe property or environmental damage 
(individually and collectively, "Critical Applications"). Customer assumes the 
sole risk and liability of any use of Xilinx products in Critical Applications, 
subject only to applicable laws and regulations governing limitations on product 
liability. 
#pragma empty_line
THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
ALL TIMES.
#pragma empty_line
*******************************************************************************/
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Xilinx/Vivado_HLS/2012.2/common/technology/autopilot/ap_int.h" 1
// -*- c++ -*-
/*
 * Copyright (C) 2011 XILINX, Inc.
 *
 */
#pragma line 50 "ap_video.h" 2
#pragma empty_line
#pragma empty_line
/* Parametrized RGB structure */
template <int A, int D, int C>
  struct ap_rgb{
    ap_uint<A> B;
    ap_uint<D> G;
    ap_uint<C> R;
  };
#pragma empty_line
/* Parametrized YUV structure */
template <int A, int B, int C>
  struct ap_yuv{
    ap_uint<A> Y;
    ap_int<B> U;
    ap_int<C> V;
  };
#pragma empty_line
/* Line buffer class definition */
template <typename T, int LROW, int LCOL>
  class ap_linebuffer{
 public:
  T M[LROW][LCOL];
#pragma empty_line
  ap_linebuffer(){
#pragma AP ARRAY_PARTITION variable=M dim=1 complete
    //#pragma AP data_pack variable=M
    //#pragma AP dependence variable=M intra false
    //#pragma AP dependence variable=M inter false
};
  ~ap_linebuffer(){};
  void shift_up(int col);
  void shift_down(int col);
  void insert_top(T value, int col);
  void insert_bottom(T value, int col);
  void print(int StartCol, int EndCol);
  T getval(int RowIndex,int ColIndex);
};
#pragma empty_line
/* Line buffer print function.
 * Prints the values of all rows in the line buffer
 * between StartCol and EndCol
 */
template <typename T, int LROW, int LCOL>
  void ap_linebuffer<T,LROW,LCOL>::print(int StartCol, int EndCol)
{
  int i, j;
  for(i = LROW-1; i > -1; i--){
    printf("Line %d:\t",i);
    for(j=StartCol; j < EndCol; j++){
      printf("%d\t",M[i][j]);
    }
    printf("\n");
  }
  printf("\n");
}
#pragma empty_line
/* Line buffer shift up
 * Assumes new data pixel will be entered at the bottom of the line buffer
 * The bottom is row = 0
 */
template <typename T, int LROW, int LCOL>
  void ap_linebuffer<T,LROW,LCOL>::shift_up(int col)
{
#pragma AP inline
  int i;
  for(i = LROW-1; i > 0; i--){
#pragma AP unroll
    M[i][col] = M[i-1][col];
  }
}
#pragma empty_line
/* Line buffer shift down
 * Assumes new data pixel will be entered at the top of the line buffer
 * The bottom is row = LROW - 1
 */
template <typename T, int LROW, int LCOL>
  void ap_linebuffer<T,LROW,LCOL>::shift_down(int col)
{
#pragma AP inline
  int i;
  for(i = 0; i < LROW-1; i++){
#pragma AP unroll
    M[i][col] = M[i+1][col];
  }
}
#pragma empty_line
/* Line buffer insert bottom
 * Inserts a new value in the bottom row of the line buffer at column = col
 * The bottom is row = 0
 */
template <typename T, int LROW, int LCOL>
  void ap_linebuffer<T,LROW,LCOL>::insert_bottom(T value, int col)
{
#pragma AP inline
#pragma empty_line
  M[0][col] = value;
}
#pragma empty_line
/* Line buffer insert top
 * Inserts a new value in the top row of the line buffer at column = col
 * The bottom is row = LROW - 1
 */
template <typename T, int LROW, int LCOL>
  void ap_linebuffer<T,LROW,LCOL>::insert_top(T value, int col)
{
#pragma AP inline
#pragma empty_line
  M[LROW-1][col] = value;
}
#pragma empty_line
/* Line buffer getval
 * Returns the data value in the line buffer at position RowIndex, ColIndex
 */
template <typename T, int LROW, int LCOL>
  T ap_linebuffer<T,LROW,LCOL>::getval(int RowIndex,int ColIndex)
{
#pragma AP inline
#pragma empty_line
  T return_value;
  return_value = M[RowIndex][ColIndex];
  return return_value;
}
#pragma empty_line
/* Memory window class definition */
template <typename T, int LROW, int LCOL>
  class ap_window{
 public:
  T M[LROW][LCOL];
#pragma empty_line
  ap_window(){
#pragma AP ARRAY_PARTITION variable=M dim=0 complete
    //#pragma AP data_pack variable=M
};
  ~ap_window(){};
  void shift_right();
  void shift_left();
  void shift_up();
  void shift_down();
  void insert(T value, int row,int col);
  void print();
  T getval(int RowIndex,int ColIndex);
};
#pragma empty_line
/* Window print
 * Prints the entire contents of the memory window
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::print()
{
  int i, j;
  printf("Window Size = %d x %d\n",LROW,LCOL);
  printf("Col \t");
  for(j = 0; j < LCOL; j++){
    printf("%d \t",j);
  }
  printf("\n");
  for(i = LROW-1; i > -1; i--){
    printf("Row %d: \t",i);
    for(j=0; j < LCOL; j++){
      printf("%d\t",M[i][j]);
    }
    printf("\n");
  }
  printf("\n");
}
#pragma empty_line
/* Window shift right
 * Moves all the contents of the window horizontally
 * Assumes new values will be placed in column = LCOL-1
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::shift_right()
{
#pragma AP inline
  int i, j;
  for(i = 0; i < LROW; i++){
#pragma AP unroll
    for(j=0; j < LCOL-1; j++){
#pragma AP unroll
      M[i][j] = M[i][j+1];
    }
  }
}
#pragma empty_line
/* Window shift left
 * Moves all the contents of the window horizontally
 * Assumes new values will be placed in column = 0
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::shift_left()
{
#pragma AP inline
  int i, j;
  for(i = 0; i < LROW; i++){
#pragma AP unroll
    for(j=LCOL-1; j > 0; j--){
#pragma AP unroll
      M[i][j] = M[i][j-1];
    }
  }
}
#pragma empty_line
/* Window shift up
 * Moves all the contents of the window vertically
 * Assumes new values will be placed in row = 0
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::shift_up()
{
#pragma AP inline
  int i, j;
  for(i = LROW-1; i > 0; i--){
#pragma AP unroll
    for(j=0; j < LCOL; j++){
#pragma AP unroll
      M[i][j] = M[i-1][j];
    }
  }
}
#pragma empty_line
/* Window shift down
 * Moves all the contents of the window vertically
 * Assumes new values will be placed in row = LROW - 1
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::shift_down()
{
#pragma AP inline
  int i, j;
  for(i = 0; i < LROW-1; i++){
#pragma AP unroll
    for(j=0; j < LCOL; j++){
#pragma AP unroll
      M[i][j] = M[i+1][j];
    }
  }
}
#pragma empty_line
/* Window insert
 * Inserts a new value at any location of the window
 */
template <typename T, int LROW, int LCOL>
  void ap_window<T,LROW,LCOL>::insert(T value, int row, int col)
{
#pragma AP inline
  M[row][col] = value;
}
#pragma empty_line
/* Window getval
 * Returns the value of any window location
 */
template <typename T, int LROW, int LCOL>
  T ap_window<T,LROW,LCOL>::getval(int RowIndex, int ColIndex)
{
#pragma AP inline
  T return_value;
  return_value = M[RowIndex][ColIndex];
  return return_value;
}
#pragma line 54 "sobel.h" 2
#pragma line 62 "sobel.h"
// I/O Image Settings
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef ap_rgb<8,8,8> RGB;
typedef ap_axiu<32,1,1,1> AXI_PIXEL;
typedef ap_window<unsigned char,3,3> WINDOW;
typedef ap_linebuffer<unsigned char, 3, 1920> Y_BUFFER;
typedef ap_linebuffer<RGB,2,1920> RGB_BUFFER;
#pragma empty_line
#pragma empty_line
void sobel_filter(
    AXI_PIXEL inter_pix[1080][1920],
    AXI_PIXEL out_pix[1080][1920],
    int row,
    int col
    );
#pragma line 48 "sobel.cpp" 2
#pragma empty_line
// RGB to Y Conversion 
// Resulting luminance value used in edge detection
unsigned char rgb2y(RGB pix)
{
  unsigned char y;
#pragma empty_line
  y = ((66 * pix.R.to_int() + 129 * pix.G.to_int() + 25 * pix.B.to_int() + 128) >> 8) + 16;
#pragma empty_line
  return y;
}
#pragma empty_line
//Sobel Computation using a 3x3 neighborhood
RGB sobel_operator(WINDOW *window)
{
  short x_weight = 0;
  short y_weight = 0;
#pragma empty_line
  short edge_weight;
  unsigned char edge_val;
  RGB pixel;
#pragma empty_line
  char i;
  char j;
#pragma empty_line
#pragma empty_line
  const char x_op[3][3] = { {-1,0,1},
       {-2,0,2},
       {-1,0,1}};
#pragma empty_line
  const char y_op[3][3] = { {1,2,1},
       {0,0,0},
       {-1,-2,-1}};
#pragma empty_line
  //Compute approximation of the gradients in the X-Y direction
  for(i=0; i < 3; i++){
    for(j = 0; j < 3; j++){
#pragma empty_line
      // X direction gradient
      x_weight = x_weight + (window->getval(i,j) * x_op[i][j]);
#pragma empty_line
      // Y direction gradient
      y_weight = y_weight + (window->getval(i,j) * y_op[i][j]);
    }
  }
#pragma empty_line
  edge_weight = ((x_weight>0)? x_weight : -x_weight) + ((y_weight>0)? y_weight : -y_weight);
#pragma empty_line
  edge_val = (255-(unsigned char)(edge_weight));
#pragma empty_line
  //Edge thresholding
  if(edge_val > 200)
    edge_val = 255;
  else if(edge_val < 100)
    edge_val = 0;
#pragma empty_line
  pixel.R = pixel.G = pixel.B = edge_val;
#pragma empty_line
  return pixel;
}
#pragma empty_line
//Main function for Sobel Filtering
//This function includes a line buffer for a streaming implementation
void sobel_filter(AXI_PIXEL inter_pix[1080][1920],AXI_PIXEL out_pix[1080][1920], int rows, int cols)
{
  //Place the 8-bit color components in a 24-bit container. R is least significant byte
#pragma empty_line
  //Create AXI streaming interfaces for the core
  { {
#pragma line 116 "sobel.cpp"
#pragma AP interface ap_fifo port=inter_pix
#pragma line 116 "sobel.cpp"
 ; };
#pragma line 116 "sobel.cpp"
#pragma AP resource core=AXIS variable=inter_pix metadata="-bus_bundle INPUT_STREAM"
#pragma line 116 "sobel.cpp"
 ;
#pragma line 116 "sobel.cpp"
#pragma AP resource core=AXIS variable=inter_pix port_map={{inter_pix_data_V TDATA} {inter_pix_strb_V TSTRB} {inter_pix_user_V TUSER} {inter_pix_last_V TLAST} {inter_pix_tdest_V TDEST}}
#pragma line 116 "sobel.cpp"
 ; };
  { {
#pragma line 117 "sobel.cpp"
#pragma AP interface ap_fifo port=out_pix
#pragma line 117 "sobel.cpp"
 ; };
#pragma line 117 "sobel.cpp"
#pragma AP resource core=AXIS variable=out_pix metadata="-bus_bundle OUTPUT_STREAM"
#pragma line 117 "sobel.cpp"
 ;
#pragma line 117 "sobel.cpp"
#pragma AP resource core=AXIS variable=out_pix port_map={{out_pix_data_V TDATA} {out_pix_strb_V TSTRB} {out_pix_user_V TUSER} {out_pix_last_V TLAST} {out_pix_tdest_V TDEST}}
#pragma line 117 "sobel.cpp"
 ; };
  {
#pragma line 118 "sobel.cpp"
#pragma AP interface ap_none port=rows
#pragma line 118 "sobel.cpp"
 ; };
  {
#pragma line 119 "sobel.cpp"
#pragma AP interface ap_none port=cols
#pragma line 119 "sobel.cpp"
 ; };
  {
#pragma line 120 "sobel.cpp"
#pragma AP resource core=AXI_SLAVE variable=rows metadata="-bus_bundle CONTROL_BUS"
#pragma line 120 "sobel.cpp"
 ; };
  {
#pragma line 121 "sobel.cpp"
#pragma AP resource core=AXI_SLAVE variable=cols metadata="-bus_bundle CONTROL_BUS"
#pragma line 121 "sobel.cpp"
 ; };
  {
#pragma line 122 "sobel.cpp"
#pragma AP resource core=AXI_SLAVE variable=return metadata="-bus_bundle CONTROL_BUS" port_map={{ap_start START} {ap_done DONE} {ap_idle IDLE} {ap_return RETURN}}
#pragma line 122 "sobel.cpp"
 ; };
#pragma empty_line
  int row;
  int col;
#pragma empty_line
  Y_BUFFER buff_A;
  RGB_BUFFER buff_B;
  WINDOW buff_C;
#pragma empty_line
  for(row = 0; row < rows+1; row++){
    for(col = 0; col < cols+1; col++){
#pragma AP loop_flatten off
#pragma AP dependence variable=&buff_A false
#pragma AP PIPELINE II = 1
#pragma empty_line
      // Temp values are used to reduce the number of memory reads
      unsigned char temp;
      RGB tempx;
      unsigned char test_val;
#pragma empty_line
      //Line Buffer fill
      if(col < cols){
 buff_A.shift_up(col);
 temp = buff_A.getval(0,col);
      }
#pragma empty_line
      //There is an offset to accomodate the active pixel region
      //There are only MAX_WIDTH and MAX_HEIGHT valid pixels in the image
      if(col < cols & row < rows){
 RGB new_pix;
 AXI_PIXEL input_pixel;
 input_pixel = inter_pix[row][col];
 new_pix.B = input_pixel.data.range(7,0);
 new_pix.G = input_pixel.data.range(15,8);
 new_pix.R = input_pixel.data.range(23,16);
 tempx = new_pix;;
 buff_A.insert_bottom(rgb2y(tempx),col);
      }
#pragma empty_line
      //Shift the processing window to make room for the new column
      buff_C.shift_right();
#pragma empty_line
      //The Sobel processing window only needs to store luminance values
      //rgb2y function computes the luminance from the color pixel
      if(col < cols){
 buff_C.insert(buff_A.getval(2,col),0,2);
 buff_C.insert(temp,1,2);
 buff_C.insert(rgb2y(tempx),2,2);
      }
      RGB edge;
#pragma empty_line
      //The sobel operator only works on the inner part of the image
      //This design assumes there are no edges on the boundary of the image
      if( row <= 1 || col <= 1 || row > (rows-1) || col > (cols-1)){
 edge.R = edge.G = edge.B = 0;
      }
      else{
#pragma empty_line
 //Sobel operation on the inner portion of the image
 edge = sobel_operator(&buff_C);
      }
#pragma empty_line
      //The output image is offset from the input to account for the line buffer
      if(row > 0 && col > 0){
 AXI_PIXEL output_pixel;
 ap_uint<8> padding = 0xff;
 output_pixel.data = (edge.R,edge.G);
 output_pixel.data = (output_pixel.data, edge.B);
 output_pixel.data = (padding,output_pixel.data);
 output_pixel.strb = 15;
 output_pixel.user = 1;
 output_pixel.tdest = 1;
 if((col == cols))
   output_pixel.last = 1;
 else
   output_pixel.last = 0;
 out_pix[row-1][col-1] = output_pixel;
      }
    }
  }
}
